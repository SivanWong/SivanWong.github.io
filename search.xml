<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React-Native：开发指南]]></title>
    <url>%2F2022%2F06%2F28%2FReact%2FReact-Native%EF%BC%9A%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[环境设置可以使用Expo CLI/React Native CLI Expo CLI需要node &gt;= 12.13.0 安装1$ npm install -g expo-cli 初始化1$ expo init [project name] 选择template：tabs (TypeScript) several example screens and tabs using react-navigation and TypeScript 启动 npm install expo start 真机运行 在您的 iOS 或 Android 手机上安装Expo客户端应用程序（Expo Go）并连接到与您的计算机相同的无线网络。 在 Android 上，使用 Expo 应用程序从您的终端扫描 QR 码以打开您的项目。 在 iOS 上，使用相机应用程序的内置二维码扫描器。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React：合成事件机制]]></title>
    <url>%2F2022%2F06%2F28%2FReact%2FReact%EF%BC%9A%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[由于fiber机制的特点，生成一个fiber节点时，它对应的dom节点有可能还未挂载，onClick这样的事件处理函数作为fiber节点的prop，也就不能直接被绑定到真实的DOM节点上。 为此，React提供了一种“顶层注册，事件收集，统一触发”的事件机制。 顶层注册：是在document上绑定一个统一的事件处理函数（React17的事件是注册到root上而非document），此函数并非我们写在组件中的事件处理函数。 事件收集：事件触发时（实际上是上述被绑定的事件处理函数被执行），构造合成事件对象，按照冒泡或捕获的路径去组件中收集真正的事件处理函数。 统一触发：发生在收集过程之后，对所收集的事件逐一执行，并共享同一个合成事件对象。 事件注册 与之前版本不同，React17的事件是注册到root上而非document，这主要是为了渐进升级，避免多版本的React共存的场景中事件系统发生冲突。 当我们为一个元素绑定事件时，会这样写： 1&lt;div onClick=&#123;() =&gt; &#123;/*do something*/&#125;&#125;&gt;React&lt;/div&gt; 这个div节点最终要对应一个fiber节点，onClick则作为它的prop。当这个fiber节点进入==render阶段的complete阶段==时，名称为onClick的prop会被识别为事件进行处理。 react有一个对象registrationNameDependencies，存储了所有React事件对应的原生DOM事件的集合，这是识别prop是否为事件的依据。如果是事件类型的prop，那么将会调用ensureListeningTo去绑定事件。 绑定过程： 根据React的事件名称寻找该事件依赖。例如onMouseEnter事件依赖了mouseout和mouseover两个原生事件，onClick只依赖了click一个原生事件。 依据组件中写的事件名识别其属于哪个阶段的事件（冒泡或捕获）。例如onClickCapture这样的React事件名称就代表是需要事件在捕获阶段触发，而onClick代表事件需要在冒泡阶段触发。 根据React事件名，找出对应的原生事件名。例如click，并根据上一步来判断是否需要在捕获阶段触发，调用addEventListener，将事件监听绑定到document上。 若事件需要更新，那么先移除事件监听，再重新绑定，绑定过程重复以上三步。 经过这一系列过程，==事件监听器listener==最终被绑定到document上。 事件监听器listener上面绑定事件的过程中，会在document中绑定一个事件监听函数，一开始在说顶层注册的时候有提到，这个事件监听函数并不是我们直接在组件里写的事件处理函数。 react通过调用一个方法createEventListenerWrapperWithPriority，来生成listener，绑定在document上的就是这个listener。 createEventListenerWrapperWithPriority根据事件名或者传入的优先级（如果没有传入优先级，会根据传入的事件名称先去找对应的事件优先级），返回不同的事件监听函数。123456789101112131415161718192021222324// 根据事件名称，创建不同优先级的事件监听器。 let listener = createEventListenerWrapperWithPriority( targetContainer, domEventName, eventSystemFlags, listenerPriority, ); // 绑定事件 if (isCapturePhaseListener) &#123; ... unsubscribeListener = addEventCaptureListener( targetContainer, domEventName, listener, ); &#125; else &#123; ... unsubscribeListener = addEventBubbleListener( targetContainer, domEventName, listener, ); &#125; 123456789101112131415161718192021222324252627282930export function createEventListenerWrapperWithPriority( targetContainer: EventTarget, domEventName: DOMEventName, eventSystemFlags: EventSystemFlags, priority?: EventPriority,): Function &#123; const eventPriority = priority === undefined ? getEventPriorityForPluginSystem(domEventName) : priority; let listenerWrapper; switch (eventPriority) &#123; case DiscreteEvent: listenerWrapper = dispatchDiscreteEvent; break; case UserBlockingEvent: listenerWrapper = dispatchUserBlockingUpdate; break; case ContinuousEvent: default: listenerWrapper = dispatchEvent; break; &#125; return listenerWrapper.bind( null, domEventName, eventSystemFlags, targetContainer, );&#125; 优先级：事件优先级，是根据事件的交互程度划分的。优先级和事件名的映射关系存在于一个Map结构中。 离散事件（DiscreteEvent）：click、keydown、focusin等，这些事件的触发不是连续的，优先级为0。 用户阻塞事件（UserBlockingEvent）：drag、scroll、mouseover等，特点是连续触发，阻塞渲染，优先级为1。 连续事件（ContinuousEvent）：canplay、error、audio标签的timeupdate和canplay，优先级最高，为2。 事件监听包装器：真正绑定在document上的就是这个事件监听包装器。不同包装器持有各自的优先级，当对应的事件触发时，调用的其实是这个包含优先级的事件监听。 dispatchDiscreteEvent: 处理离散事件 dispatchUserBlockingUpdate：处理用户阻塞事件 dispatchEvent：处理连续事件 参数eventSystemFlags： 事件系统的一个标志，记录事件的各种标记，其中一个标记就是IS_CAPTURE_PHASE，这表明了当前的事件是捕获阶段触发。当事件名含有Capture后缀时，eventSystemFlags会被赋值为IS_CAPTURE_PHASE。 在以优先级创建对应的事件监听时，eventSystemFlags会作为事件监听函数执行时的入参，传递进去。因此，在事件触发的时候就可以知道组件中的事件是以冒泡或是捕获的顺序执行。 123456789101112131415function dispatchDiscreteEvent( domEventName, eventSystemFlags, container, nativeEvent,) &#123; ... discreteUpdates( dispatchEvent, domEventName, eventSystemFlags, // 传入事件执行阶段的标志 container, nativeEvent, );&#125; 小结 事件处理函数不是绑定到组件的元素上的，而是绑定到root上，这和fiber树的结构特点有关，即事件处理函数只能作为fiber的prop。 绑定到root上的事件监听不是我们在组件里写的事件处理函数，而是一个持有事件优先级，并能传递事件执行阶段标志的监听器。 事件触发概括 —— 事件监听器listener做了什么负责以不同的优先级权重来触发真正的事件流程，并传递事件执行阶段标志（eventSystemFlags）。 也就是说绑定到document上的事件监听listener只是相当于一个传令官，它按照事件的优先级去安排接下来的工作： 事件对象的合成 将事件处理函数收集到执行路径 事件执行 这样在后面的调度过程中，scheduler才能获知当前任务的优先级，然后展开调度。 如何将优先级传递出去？ 利用scheduler中的runWithPriority函数，通过调用它，将优先级记录到利用scheduler中，所以调度器才能在调度的时候知道当前任务的优先级。 runWithPriority的第二个参数，会去安排上面提到的三个工作。 以用户阻塞的优先级级别为例：123456789101112131415161718function dispatchUserBlockingUpdate( domEventName, eventSystemFlags, container, nativeEvent,) &#123; ... runWithPriority( UserBlockingPriority, dispatchEvent.bind( null, domEventName, eventSystemFlags, container, nativeEvent, ), );&#125; dispatchEventsForPlugins事件监听最终触发的是dispatchEventsForPlugins。这个函数体可看成两部分：==事件对象的合成和事件收集==、==事件执行==，涵盖了上述三个过程。 123456789101112131415161718192021222324function dispatchEventsForPlugins( domEventName: DOMEventName, eventSystemFlags: EventSystemFlags, nativeEvent: AnyNativeEvent, targetInst: null | Fiber, targetContainer: EventTarget,): void &#123; const nativeEventTarget = getEventTarget(nativeEvent); const dispatchQueue: DispatchQueue = []; // 事件对象的合成，收集事件到执行路径上 extractEvents( dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer, ); // 执行收集到的组件中真正的事件 processDispatchQueue(dispatchQueue, eventSystemFlags);&#125; dispatchEventsForPlugins函数中事件的流转有一个重要的载体： dispatchQueue：它承载了本次合成的事件对象和收集到事件执行路径上的事件处理函数。其元素中包含两个对象： listeners是事件执行路径 event是合成事件对象 事件对象的合成和事件的收集合成事件对象在组件中的事件处理函数中拿到的事件对象并不是原生的事件对象，而是经过React合成的==SyntheticEvent==对象。它解决了不同浏览器之间的兼容性差异。 事件执行路径当事件对象合成完毕，会将事件收集到事件执行路径上。 什么是事件执行路径呢？在浏览器的环境中，若父子元素绑定了相同类型的事件，除非手动干预，那么这些事件都会按照冒泡或者捕获的顺序触发。 在React中也是如此，从触发事件的元素开始，依据fiber树的层级结构向上查找，累加上级元素中所有相同类型的事件，最终形成一个具有所有相同类型事件的数组，这个数组就是事件执行路径。通过这个路径，React自己模拟了一套事件捕获与冒泡的机制。 因为不同的事件会有不同的行为和处理机制，所以合成事件对象的构造和收集事件到执行路径需要通过插件实现。一共有5种Plugin：SimpleEventPlugin，EnterLeaveEventPlugin，ChangeEventPlugin，SelectEventPlugin，BeforeInputEventPlugin。它们的使命完全一样，只是处理的事件类别不同，所以内部会有一些差异。 创建合成事件对象这个统一的事件对象由SyntheticEvent函数构造而成，它自己遵循W3C的规范又实现了一遍浏览器的事件对象接口，这样可以抹平差异，而原生的事件对象只不过是它的一个属性（nativeEvent）。 12345678// 构造合成事件对象const event = new SyntheticEvent( reactName, null, nativeEvent, nativeEventTarget, EventInterface,); 收集事件到执行路径这个过程是将组件中真正的事件处理函数收集到数组中，等待下一步的批量执行。 函数内部最重要的操作无疑是收集事件到执行路径，为了实现这一操作，需要在fiber树中从触发事件的源fiber节点开始，向上一直找到root（react17后是挂载在root上），形成一条完整的冒泡或者捕获的路径。同时，沿途路过fiber节点时，根据事件名，从props中获取我们真正写在组件中的事件处理函数，push到路径中，等待下一步的批量执行。 收集的过程由accumulateSinglePhaseListeners完成。 1234567accumulateSinglePhaseListeners( targetInst, dispatchQueue, event, inCapturePhase, accumulateTargetOnly,); 无论事件是在冒泡阶段执行，还是捕获阶段执行，都以同样的顺序（冒泡的顺序）push到dispatchQueue的listeners中，而冒泡或者捕获事件的执行顺序不同是由于清空listeners数组的顺序不同。 注意，每次收集只会收集与事件源相同类型的事件，比如子元素绑定了onClick，父元素绑定了onClick和onClickCapture，那么点击子元素时，收集的将是onClickChild 和 onClickParent。 合成事件对象如何参与到事件执行过程上面我们说过，dispatchQueue的结构如下面这样 123456[ &#123; event: SyntheticEvent, listeners: [ listener1, listener2, ... ] &#125;] event就代表着合成事件对象，可以将它认为是这些listeners共享的一个事件对象。 listeners则是以冒泡顺序收集到的同源事件的事件处理函数，此处函数是写在组件上的函数，绑定到document上时才会创建之前提到的事件监听器。 当清空listeners数组执行到每一个事件监听函数时，这个事件监听可以改变event上的currentTarget，也可以调用它上面的stopPropagation方法来阻止冒泡。event作为一个共享资源被这些事件监听消费，消费的行为发生在事件执行时。 事件执行进入到事件执行过程，从头到尾循环该路径，依次调用每一项中的监听函数。这个过程的重点在于事件冒泡和捕获的模拟，以及合成事件对象的应用，如下是从dispatchQueue中提取出事件对象和时间执行路径的过程。12345678910111213141516export function processDispatchQueue( dispatchQueue: DispatchQueue, eventSystemFlags: EventSystemFlags,): void &#123; const inCapturePhase = (eventSystemFlags &amp; IS_CAPTURE_PHASE) !== 0; for (let i = 0; i &lt; dispatchQueue.length; i++) &#123; // 从dispatchQueue中取出事件对象和事件监听数组 const &#123;event, listeners&#125; = dispatchQueue[i]; // 将事件监听交由processDispatchQueueItemsInOrder去触发，同时传入事件对象供事件监听使用 processDispatchQueueItemsInOrder(event, listeners, inCapturePhase); &#125; // 捕获错误 rethrowCaughtError();&#125; 模拟冒泡和捕获冒泡和捕获的执行顺序是不一样的，但是当初在收集事件的时候，无论是冒泡还是捕获，事件都是直接push到路径里的。那么执行顺序的差异是如何体现的呢？答案是循环路径的顺序不一样导致了执行顺序有所不同。 首先回顾一下dispatchQueue中的listeners中的事件处理函数排列顺序：触发事件的目标元素的事件处理函数排在第一个，上层组件的事件处理函数依次往后排。 1234567&lt;div onClick=&#123;onClickParent&#125;&gt; 父元素 &lt;div onClick=&#123;onClickChild&#125;&gt; 子元素 &lt;/div&gt;&lt;/div&gt;listeners: [ onClickChild, onClickParent ] 从左往右循环的时候，目标元素的事件先触发，父元素事件依次执行，这与冒泡的顺序一样，那捕获的顺序自然是从右往左循环了。模拟冒泡和捕获执行事件的代码如下： 其中判断事件执行阶段的依据inCapturePhase，它的来源在上面的透传透传事件执行阶段标志的内容里已经提到过，是根据eventSystemFlags产生的。 12345678910111213141516171819202122232425262728293031function processDispatchQueueItemsInOrder( event: ReactSyntheticEvent, dispatchListeners: Array&lt;DispatchListener&gt;, inCapturePhase: boolean,): void &#123; let previousInstance; if (inCapturePhase) &#123; // 事件捕获倒序循环 for (let i = dispatchListeners.length - 1; i &gt;= 0; i--) &#123; const &#123;instance, currentTarget, listener&#125; = dispatchListeners[i]; if (instance !== previousInstance &amp;&amp; event.isPropagationStopped()) &#123; return; &#125; // 执行事件，传入event对象，和currentTarget executeDispatch(event, listener, currentTarget); previousInstance = instance; &#125; &#125; else &#123; // 事件冒泡正序循环 for (let i = 0; i &lt; dispatchListeners.length; i++) &#123; const &#123;instance, currentTarget, listener&#125; = dispatchListeners[i]; // 如果事件对象阻止了冒泡，则return掉循环过程 if (instance !== previousInstance &amp;&amp; event.isPropagationStopped()) &#123; return; &#125; executeDispatch(event, listener, currentTarget); previousInstance = instance; &#125; &#125;&#125; 至此，我们写在组件中的事件处理函数就被执行掉了，合成事件对象在这个过程中充当了一个公共角色，每个事件执行时，都会检查合成事件对象，有没有调用阻止冒泡的方法，另外会将当前挂载事件监听的元素作为currentTarget挂载到事件对象上，最终传入事件处理函数，我们得以获取到这个事件对象。 总结由于fiber树的特点，一个组件如果含有事件的prop，那么将会在对应fiber节点的==commit阶段==绑定一个事件监听到root上，这个事件监听是持有优先级的，这将它和优先级机制联系了起来，可以把合成事件机制当作一个协调者，负责去协调合成事件对象、收集事件、触发真正的事件处理函数这三个过程。 在React底层，主要对合成事件做了两件事： 事件委派：React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。 自动绑定：React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。 过程 当这个fiber节点进入render阶段的complete阶段时，名称为onClick的prop会被识别为事件进行处理（如果是事件类型则会调用方法进行事件绑定）。 当fiber节点进入commit阶段时，会将对应事件监听绑定在root/document上，此时绑定的是根据优先级创建的事件监听器listener。绑定过程： 根据React的事件名称寻找该事件依赖。 依据组件中写的事件名识别其属于哪个阶段的事件（冒泡或捕获）。 根据React事件名，找出对应的原生事件名。调用addEventListener，将事件监听绑定到document上。 若事件需要更新，那么先移除事件监听，再重新绑定，绑定过程重复以上三步。 click元素后，绑定在document上的listener被触发，listener将根据优先级进行以下工作： 从目标元素开始，根据监听器中透传的事件（执行阶段标志eventSystemFlags也是以这种方式入参）进行事件对象的合成， 以冒泡的顺序将事件处理函数push到执行路径中 根据执行阶段标志执行事件（捕获为从右到左，冒泡为从左到右）。每个事件执行时，都会检查合成事件对象里是否有调用阻止冒泡的方法，有的话会return掉循环（两种阶段一样，可参考上述模拟冒泡和捕获中的代码） 阻止冒泡事件执行顺序 document原生事件（捕获阶段） react事件（捕获阶段） 原生事件（捕获/冒泡） react事件（冒泡阶段） document原生事件（冒泡阶段） 在原生事件中阻止冒泡所有下层原生事件无法执行，react事件无法执行，document原生事件无法执行 在react事件中阻止冒泡所有下层react事件无法执行，document原生事件无法执行 无论冒泡阶段还是捕获阶段执行的react事件，下层都会被中断（即onClick和onClickCapture都一样下层会被阻断） react合成事件和原生事件 - 原生事件 react合成事件 事件命名方式 全小写(onclick) 驼峰(onClick) 事件处理函数语法 字符串 函数 阻止默认行为方式 可以return false 只能e.preventDefault() 参考 深入React合成事件机制原理]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React：一些知识点]]></title>
    <url>%2F2022%2F05%2F20%2FReact%2FReact%EF%BC%9A%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[setState是同步还是异步？ 是指调用 setState 之后 this.state 能否立即更新。 setState的表现形式是异步的，是在合成事件和钩子函数调用之后才触发更新的，导致在合成事件和钩子函数中没法立马拿到更新后的值。 每次调用setState都会触发更新，异步操作是为了提高性能，将多个状态合并一起更新，减少re-render调用。 18之前promise、setTimeout以及原生事件中的setState不会进行批处理；18之后所有更新都自动批处理]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：基础类型和引用类型]]></title>
    <url>%2F2022%2F05%2F08%2FJS%2FJS%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[基础类型 undefined，null，boolean，string，number，bigint，symbol symbol代表唯一的值，通常被用作对象的key 在内存中是栈存储，自动分配内存，自动释放。存储的是值 栈中数据的存取是先进后出的 引用类型 array，object，function，date，regExp，特殊的基本包装类型(String、Number、Boolean)以及单体内置对象(Global、Math) 在内存中是堆存储，动态分配内存，大小不定，不会自动释放。存储的是地址 堆是一个优先队列，按优先级来排序]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：数据类型检测方式（typeof和instanceof）]]></title>
    <url>%2F2022%2F05%2F08%2FJS%2FJS%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F%EF%BC%88typeof%E5%92%8Cinstanceof%EF%BC%89%2F</url>
    <content type="text"><![CDATA[typeof是一个一元运算，放在一个运算数之前，运算数可以是任意类型。返回一个用来表示表达式的数据类型的字符串。一般返回如下结果： number（NaN） string boolean object（对象、数组、null） undefined function instanceof语法：object instanceof constructor用来检测 constructor.prototype 是否存在于参数 object 的原型链上。用于判断一个变量是否某个对象的实例。 可以用来判断一个对象是否为数组 String和Date对象同时也属于Object类型 123456789内部实现方法while(object.__proto__!==null) &#123; if(object.__proto__===constructor.prototype) &#123; return true; break; &#125; object.__proto__ = object.__proto__.proto__;&#125;if(object.__proto__==null) &#123;return false;&#125; instanceof只能正确判断引用数据类型，而不能判断基本数据类型。 constructor语法：object.constructor 判断数据的类型 对象实例通过 constructor 对象访问它的构造函数。 如果创建一个对象来改变它的原型，constructor就不能用来判断数据类型了：12345678function Fn()&#123;&#125;; Fn.prototype = new Array(); var f = new Fn(); console.log(f.constructor===Fn); // falseconsole.log(f.constructor===Array); // true Object.prototype.toString.call()语法：Object.prototype.toString.call() 使用 Object 对象的原型方法 toString 来判断数据类型。 同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？ 这是因为toString是Object的原型方法，而Array、function等类型作为Object的实例，都重写了toString方法。 不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型） 所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：事件循环机制Event Loop]]></title>
    <url>%2F2022%2F04%2F29%2FJS%2FJS%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6Event%20Loop%2F</url>
    <content type="text"><![CDATA[前言JavaScript的事件分两种，宏任务(macro-task)和微任务(micro-task) 宏任务：包括整体代码script，setTimeout，setInterval 微任务：Promise.then(new Promise是定义后立即执行的)，process.nextTick(node中) 事件循环 先执行同步任务，同步任务立即执行，对于异步任务则是把函数放进event table中，等到满足触发条件后加载到对应的Event Queue中。 所有同步宏任务执行完毕后，如果发现微任务的Event Queue中有未执行的任务，会先执行其中的任务，这样算是完成了一次事件循环。 接下来查看宏任务的Event Queue中是否有未执行的任务，有的话，就开始第二轮事件循环，依此类推。 注意一次事件循环范围并不是一个函数内，而是所有被涉及到的函数都算入范围 12345678910function a () &#123; b(); console.log(&apos;1&apos;)&#125;function b() &#123; setTimeout(() =&gt; console.log(&apos;2&apos;), this, 0)&#125;a(); // 1 2 例子12345678910111213Promise.resolve().then(() =&gt; &#123; console.log(&apos;promise1&apos;); const timer2 = setTimeout(() =&gt; &#123; console.log(&apos;timer2&apos;) &#125;, 0)&#125;);const timer1 = setTimeout(() =&gt; &#123; console.log(&apos;timer1&apos;) Promise.resolve().then(() =&gt; &#123; console.log(&apos;promise2&apos;) &#125;)&#125;, 0)console.log(&apos;start&apos;); 12345startpromise1timer1promise2timer2 首先，Promise.resolve().then是一个微任务，加入==当前轮次==的微任务队列 宏任务 微任务 当前同步代码⬅ Promise.resolve().then 执行timer1，它是一个宏任务，但同时也是一个异步任务，因此加入event table等待满足触发条件后加入宏任务队列。因为delay为0，所以可以立即加入==下一轮==的宏任务队列。 宏任务 微任务 event table 当前同步代码⬅ Promise.resolve().then timer1 宏任务 微任务 当前同步代码⬅ Promise.resolve().then timer1 继续执行下面的同步代码，打印出start 这样第一轮宏任务就执行完了，开始执行微任务Promise.resolve().then，打印出promise1 宏任务 微任务 当前同步代码 Promise.resolve().then⬅ timer1 遇到timer2，它是一个宏任务，但同时也是一个异步任务，因此加入event table等待满足触发条件后将其加入宏任务队列。因为delay为0，所以可以立即加入==下一轮==的宏任务队列。 宏任务 微任务 event table 当前同步代码 Promise.resolve().then⬅ timer1 timer2 宏任务 微任务 当前同步代码 Promise.resolve().then⬅ timer1 timer2 此时宏任务队列有两个任务，分别是timer1、timer2。 这样第一轮微任务就执行完了，开始执行第二轮宏任务，因为定时器timer1已满足触发条件加入宏任务，打印timer1。 遇到Promise.resolve().then，它是一个微任务，加入==当前轮次==微任务队列。 宏任务 微任务 当前同步代码 Promise.resolve().then timer1⬅ romise.resolve().then timer2 开始执行微任务队列中的任务，打印promise2。 宏任务 微任务 当前同步代码 Promise.resolve().then timer1 romise.resolve().then⬅ timer2 最后执行宏任务timer2定时器，打印出timer2。宏任务 | 微任务—|—当前同步代码| Promise.resolve().thentimer1 | romise.resolve().thentimer2⬅ | 注意： 每一轮都是先宏任务再微任务，异步函数由于不能立即加入宏任务队列，所以当前轮次轮不上，只有当满足触发条件后加入进去才有机会进入时间循环。 宏任务与微任务是两个队列，只是每次事件循环，都取队头的]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Css：stylelint]]></title>
    <url>%2F2022%2F04%2F26%2FCSS%2FCSS%EF%BC%9Astylelint%2F</url>
    <content type="text"><![CDATA[安装1npm install -D stylelint 官方推荐基本配置1npm install -D stylelint-config-standard stylelint-config-prettier 共享配置扩展 1npm install -D stylelint-config-standard-scss stylelint-config-prettier-scss 配置文件.stylelintrc.js123456789module.exports = &#123; extends: [ &quot;stylelint-config-standard-scss&quot;, &quot;stylelint-config-prettier-scss&quot; ], rules: &#123; &#125;&#125; vscode插件 安装插件stylelint 修改setting.json 12345&quot;stylelint.enable&quot;: true,&quot;css.validate&quot;: false,&quot;less.validate&quot;: false,&quot;scss.validate&quot;: false,&quot;stylelint.validate&quot;: [&quot;css&quot;, &quot;scss&quot;, &quot;less&quot;] ==修改完成后需要重启编辑器== webpack插件安装1npm i -D stylelint-webpack-plugin 使用 123456const StyleLintPlugin = require(&apos;stylelint-webpack-plugin&apos;);new StyleLintPlugin(&#123; context: &quot;src&quot;, configFile: path.resolve(__dirname, &apos;.stylelintrc.js&apos;), // 指定 stylelint 配置的文件 quiet: true&#125;), 问题 TypeError: Class extends value undefined is not a constructor or null 1npm i -D postcss@8 2.]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDK：SDK框架搭建]]></title>
    <url>%2F2022%2F04%2F26%2FSDK%2FSDK%EF%BC%9ASDK%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[踩坑 eslint安装，需要node 10以上 注意rollup plugins的顺序，看eslint要使用在打包前还是后 本地调试包时，若包内容有修改，不需要重连，如果修改不起作用，可以尝试先断开连接，重新link package.json rollup配置 eslint babel jest 本地测试 创建项目12345678├── bin // 用于存放可执行二进制文件的目录├── dist // 产物输出目录├── package.json├── README.md // 包说明，会在npm展示├── scripts // rollup配置脚本├── src // 源码├── test // 单元测试└── ... // 一些配置文件（eg: eslint、babel） rollup配置通用配置 @rollup/plugin-json rollup-plugin-clear @rollup/plugin-alias @rollup/plugin-node-resolve @rollup/plugin-commonjs rollup-plugin-typescript2 @rollup/plugin-eslint @rollup/plugin-babel 123456789101112131415161718192021222324252627282930313233// scripts/rollup.config.base.js import json from &apos;@rollup/plugin-json&apos;;import clear from &apos;rollup-plugin-clear&apos;;import alias from &apos;@rollup/plugin-alias&apos;;import nodeResolve from &apos;rollup-plugin-node-resolve&apos;;import commonjs from &apos;@rollup/plugin-commonjs&apos;;import typescript from &apos;rollup-plugin-typescript2&apos;;import &#123; eslint &#125; from &apos;rollup-plugin-eslint&apos;;import babel from &apos;@rollup/plugin-babel&apos;; export default &#123; input: &apos;src/index.ts&apos;, // 源文件入口 output: &#123; file: &apos;dist/index.js&apos;, format: &apos;umd&apos;, name: &apos;SPGAT&apos;, &#125;, plugins: [ json(), clear(&#123; targets: [&apos;dist/index.js&apos;] &#125;), alias(), nodeResolve(), commonjs(&#123; include: &apos;node_modules/**&apos; &#125;), eslint(&#123; throwOnError: true, // 抛出异常并阻止打包 include: [&apos;src/*.ts&apos;], exclude: [&apos;node_modules/**&apos;, &apos;dist/**&apos;] &#125;), typescript(), babel(&#123; babelHelpers: &apos;bundled&apos; &#125;), ]&#125;; 开发环境配置 rollup-plugin-serve rollup-plugin-livereload 1234567891011121314151617181920// scripts/rollup.config.dev.jsimport baseConfig from &apos;./rollup.config.base&apos;;import serve from &apos;rollup-plugin-serve&apos;;import livereload from &apos;rollup-plugin-livereload&apos;; export default &#123; ...baseConfig, plugins: [ ...baseConfig.plugins, serve(&#123; port: 8080, contentBase: [&apos;dist&apos;, &apos;examples/browser&apos;], openPage: &apos;index.html&apos; &#125;), livereload(&#123; watch: &apos;examples/browser&apos; &#125;) ]&#125; 正式环境配置 rollup-plugin-obfuscator rollup-plugin-filesize 123456789101112131415161718192021222324252627282930313233343536373839404142434445// scripts/rollup.config.prod.jsimport baseConfig from &apos;./rollup.config.base&apos;;import filesize from &apos;rollup-plugin-filesize&apos;;import JavascriptObfuscator from &apos;rollup-plugin-obfuscator&apos;;export default &#123; ...baseConfig, plugins: [ ...baseConfig.plugins, JavascriptObfuscator(&#123; globalOptions: &#123; compact: true, controlFlowFlattening: true, controlFlowFlatteningThreshold: 0.75, deadCodeInjection: true, deadCodeInjectionThreshold: 0.4, debugProtection: true, debugProtectionInterval: true, disableConsoleOutput: true, identifierNamesGenerator: &apos;hexadecimal&apos;, log: false, numbersToExpressions: true, renameGlobals: false, selfDefending: true, simplify: true, splitStrings: true, splitStringsChunkLength: 10, stringArray: true, stringArrayEncoding: [&apos;rc4&apos;], stringArrayIndexShift: true, stringArrayRotate: true, stringArrayShuffle: true, stringArrayWrappersCount: 2, stringArrayWrappersChainedCalls: true, stringArrayWrappersParametersMaxCount: 4, stringArrayWrappersType: &apos;function&apos;, stringArrayThreshold: 0.75, transformObjectKeys: true, unicodeEscapeSequence: false &#125;, compact: true &#125;), filesize() ]&#125; eslint使用@typescript-eslint/parser解析器 执行eslint时报错 1TypeError: Failed to load plugin &apos;vue&apos; declared in &apos;.eslintrc.js&apos; : createRequire is not a function 应注意node版本，升级到12即可 jest使用ts进行编写1npm i -D jest @types-jest ts-jest 注意：由于业务中有涉及TextEncoder、TextDecoder，jest使用jsdom，但其没有包含这两个类，因此需要自己在自定义环境中注入。 1234567891011121314151617// custom-test-env.jsconst Environment = require(&apos;jest-environment-jsdom&apos;);/** * A custom environment to set the TextEncoder that is required by TensorFlow.js. */module.exports = class CustomTestEnvironment extends Environment &#123; async setup() &#123; await super.setup(); if (typeof this.global.TextEncoder === &apos;undefined&apos;) &#123; const &#123; TextEncoder, TextDecoder &#125; = require(&apos;util&apos;); this.global.TextEncoder = TextEncoder; this.global.TextDecoder = TextDecoder; &#125; &#125;&#125;; 123456// package.json&quot;jest&quot;: &#123; &quot;preset&quot;: &quot;ts-jest&quot;, &quot;testEnvironment&quot;: &quot;./test/custom-test-env.js&quot; &#125;, 本地测试在包的根目录执行，将包发布到本地全局 1$ npm link 在另一个可运行的项目中执行 12// name 为包的名字，即package.json中的name$ npm link &lt;name&gt; 引入使用即可 12// name 为包的名字，即package.json中的nameimport &lt;name&gt;; 参考 开发一个规范的 npm 包 手把手教你使用Rollup打包📦并发布自己的工具库🔧 开发一个规范的 npm 包]]></content>
      <categories>
        <category>SDK</category>
      </categories>
      <tags>
        <tag>SDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDK：反作弊SDK实现]]></title>
    <url>%2F2022%2F04%2F26%2FSDK%2FSDK%EF%BC%9A%E5%8F%8D%E4%BD%9C%E5%BC%8ASDK%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[行为数据src目录结构123456789├── bridgeUtil.ts // jsBridge├── config.ts ├── encode.ts // 编码模块├── index.ts├── record.ts // 记录模块├── report.ts // 上报模块├── service.ts // 最底层的服务├── type.ts // 类型定义└── util.ts // 一些公共方法 行为监听 touchstart touchmove touchend didTapBack viewWillReappear viewDidDisappear shake 对于cocos，window.addEventListener并不起作用，原因是底层阻止冒泡。因此touch事件在捕获阶段进行监听 12345window.addEventListener(eventName[op], (ev: TouchEvent) =&gt; &#123; const touch = ev.type === eventName[OperationType.touchend] ? ev.changedTouches[0] : ev.touches[0]; console.log(&#123; x: Math.round(touch.pageX), y: Math.round(touch.pageY) &#125;); // record&#125;, true); didTapBack、viewWillReappear、viewDidDisappear、shake可以通过jsBridge进行监听 12345window[&apos;bridgeInit&apos;](() =&gt; &#123; window[&apos;bridgeRegisterHandler&apos;](&apos;didTapBack&apos;, (e: any) =&gt; &#123; // record &#125;);&#125;); 12345678910111213141516171819202122232425262728## 行为数据存储按module和token进行存储- 一个项目可以有多个module，每个module也可以有多个token，token可选。- 例如，module可以分为home、game。home中不区分token，全部存储成一份。game中每一局游戏都有一个不一样的token，每一局的行为数据将分别存储。## 行为数据上报### 初始化module/token记录当前module及token，并对当前模块进行初始化，时间戳、数据均清空### 上报#### 批量上报- 存储第一个动作时开始计时，满60s进行上报，重新计时- 存储的动作满60个- 触发flush方法，会把现存的未上报的动作全部上报#### 打包上报- 触发report方法，传参start，开始进行动作的存储。- 触发report方法，传参end，结束存储并全部上报### 二进制通过ArrayBuffer、TypedArray、DataView、TextEncoder进行二进制的存储及操作。- ArrayBuffer：用来表示通用的、固定长度的原始二进制数据缓冲区。是一个字节数组。- TypedArray：一个描述二进制数据缓冲区（buffer）的视图（view），这个视图是一个 类数组。- DataView：用于从 ArrayBuffer 缓冲区中读写数据的视图接口，其特点就是考虑了 字节序 的问题。- TextEncoder：将传入的文本转换成该数据对应的 类型化数组，与之对应的是TextDecoder#### 十进制和二进制 // 编码numberEncode(value: number | bigint, byteLength: number) { const functionKey = { 1: ‘setInt8’, 2: ‘setInt16’, 4: ‘setInt32’, 8: ‘setBigInt64’ }; const buffer = new ArrayBuffer(byteLength); const view = new DataView(buffer); if(byteLength === 8) value = BigInt(value); viewfunctionKey[byteLength]; return buffer;} // 解码numberDecode(buffer: ArrayBuffer, byteLength: number) { const functionKey = { 1: ‘getInt8’, 2: ‘getInt16’, 4: ‘getInt32’, 8: ‘getBigInt64’ } const view = new DataView(buffer); let value = viewfunctionKey[byteLength]; if(byteLength === 8) value = Number(value); return value;}12#### 字符串和二进制 textEncode(str: string) { const encoder = new TextEncoder(); const array = encoder.encode(str); return array.buffer; // 如果需要兼容低版本机型，用下面的方法 // return new Int8Array(str.split(‘’).map(v=&gt; v.charCodeAt(0))).buffer;} textDecode(buffer: ArrayBuffer) { const decoder = new TextDecoder(); const text = decoder.decode(buffer); return text;}12#### array buffer拼接 concatArrayBuffer(…arrays: ArrayBuffer[]) { const totalByteLength = arrays.reduce((previous, current) =&gt; previous + current.byteLength, 0); const result = new Uint8Array(totalByteLength); let offset = 0; arrays.forEach(item =&gt; { result.set(new Uint8Array(item), offset); offset += item.byteLength; }); return result.buffer;}12### 异或加密 getXORKey() { // 随机生成8位的key} getXORMessage(message: ArrayBuffer, key: number) { let result = new Uint8Array(message); result = result.map(val =&gt; val ^ key); return result.buffer;}1234### 二进制和十六进制（不需要了）- [JS:Uint8Array 数组类型、arraybuffer对象类型与十六进制字符串互转](https://blog.csdn.net/sinat_36728518/article/details/117132147) buffer2Hex(buffer: ArrayBuffer) { return Array.prototype.map.call(new Uint8Array(buffer), x =&gt; (‘00’ + x.toString(16)).slice(-2)).join(‘’);} hex2Buffer(hex: string) { const typedArray = new Uint8Array(hex.match(/[\da-f]{2}/gi).map(h =&gt; parseInt(h, 16))); return typedArray.buffer;}1### 获取url上的参数 getUrlParam(name: string) { let value = ‘’; let query = window.location.search.substr(1); if (query) { query = query.replace(/\?/g, ‘&amp;’); // 经常出现添加参数的时候使用?添加，这里做个兜底 const queryArr = query.split(‘&amp;’); queryArr.find((queryStr) =&gt; { const [key, val] = queryStr.split(‘=’); if (key === name) value = val; return queryStr; }); } return value;}` 遗留的问题开发联调过程中发现可以优化或待处理的问题 touchmove的数量稍微有点多，后续可以进行优化过滤一下 参考 XOR 加密简介 JavaScript与二进制数据的恩怨情仇 JavaScript 处理二进制数据 JavaScript 二进制数组（ArrayBuffer、Typed Arrays、DataView） JS ArrayBuffer 类型转换及拼接 ArrayBuffer DataView TypedArray npm包发布注意：只发布dist目录的内容。 发布前先执行一下npm run build 修改好package.json中的版本号 执行npm publish进行发布即可，此时需要注意npm地址 若需要测试则发布测试版本，版本号后加上-alpha]]></content>
      <categories>
        <category>SDK</category>
      </categories>
      <tags>
        <tag>SDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vite]]></title>
    <url>%2F2022%2F04%2F26%2F%E5%89%8D%E7%AB%AF%2Fvite%2F</url>
    <content type="text"><![CDATA[1.概述 项目基本是基于webpack进行打包的，随着模块的增多及需求的迭代，启动、发布等都会越来越慢，为了对此进行优化，开展对vite的调研。 调研 Vite 打包工具 与AN业务的适用性，与 Webpack 相比的差异。 2.调研方法 使用webiste进行调研。 修改配置及处理启动时的报错。 使用vite进行打包，修改打包时的报错。 打包后执行命令进行预览，修改预览时的报错。3.调研过程 以下是webpack迁移vite会遇到的一些问题 12345&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vite&quot;, &quot;build&quot;: &quot;vite build --debug&quot;, &quot;serve&quot;: &quot;vite preview&quot;,&#125; 3.1 启动3.1.1 环境变量引入 新建本地文件 .env.local ，该文件需添加进 .gitignore 中。 变量名需要以 VITE_xxx 的方式命名。 在配置文件中使用： 123456789101112131415//.env.localVITE_COUNTRY = vnVITE_ENVIRONMENT = test// vite.config.jsimport &#123; defineConfig, loadEnv &#125; from &apos;vite&apos;;export default (&#123; mode &#125;) =&gt; &#123; const env = loadEnv(mode, process.cwd()); const environment = env.VITE_ENV || env.VITE_ENVIRONMENT || &apos;test&apos; const country = env.VITE_CID || env.VITE_COUNTRY || &apos;my&apos; return defineConfig(&#123; //... &#125;)&#125; 3.1.2 别名12345678910// vite.config.jsexport default (&#123; mode &#125;) =&gt; &#123; // ... return defineConfig(&#123; resolve: &#123; alias: [&#123; find: &apos;@/&apos;, replacement: &apos;/src/&apos; &#125;], &#125; &#125;)&#125; 3.1.3 样式问题1: [vite] Internal server error: Preprocessor dependency “sass” not found. Did you install it? 安装sass 问题2: [vite] Internal server error: Inline JavaScript is not enabled. Is it set in your options? 12345678910return defineConfig(&#123; css: &#123; preprocessorOptions: &#123; less: &#123; javascriptEnabled: true, modifyVars: theme &#125; &#125; &#125;&#125;) 问题3: [vite] Internal server error: ‘~antd/dist/antd.less’ wasn’t found. Tried - /Users/xinweiwang/Desktop/affiliate/web-affiliate/src/~antd/dist/antd.less,node_modules/~antd/dist/antd.less,npm://~antd/dist/antd.less,~antd/dist/antd.less 把theme.js中的 @import “~antd/dist/antd.less”; 注释。 添加插件vite-plugin-imp按需加载antd 123456789101112return defineConfig(&#123; plugins: [ vitePluginImp(&#123; libList: [ &#123; libName: &quot;antd&quot;, style: (name) =&gt; `antd/es/$&#123;name&#125;/style/`, &#125;, ], &#125;) ],&#125;) 问题4：不支持 ‘:export’ 问题5：Unknown theme type: undefined, name: undefined https://github.com/ant-design/ant-design/issues/19002 1234567return defineConfig(&#123; resolve: &#123; alias: &#123; &apos;@ant-design/icons/lib/dist&apos;: &apos;@ant-design/icons/lib/index.es.js&apos; &#125;, &#125;, &#125;) 3.1.4 配置代理123456789101112return defineConfig(&#123; server: &#123; port: 8888, host: &apos;0.0.0.0&apos;, proxy: &#123; &apos;/api&apos;: &#123; target: `https://affiliate.$&#123;environment&#125;.$&#123;BASE_DOMAIN_ALL[country]&#125;/`, changeOrigin: true &#125; &#125; &#125;&#125;) 3.1.5 引入入口文件12// index.html &lt;script type=&quot;module&quot; src=&quot;/src/index.tsx&quot;&gt;&lt;/script&gt; 3.1.6 启动时各种408，请求超时 ，可以删除node_modules，重新install 3.1.7 Uncaught SyntaxError: The requested module ‘/global.config.js?t=1647918620356’ does not provide an export named ‘default’vite不支持cjs，https://github.com/vitejs/vite/issues/3024 方案一：可以通过预捆绑的方式处理，但那代表着需要捆绑很多个文件 方案二：把global.config.js中的module.exports改为export default，所有文件的module.exports及require都需要更改 3.1.8 Uncaught ReferenceError: global is not defined方案一 1234// index.html&lt;script&gt; global = globalThis;&lt;/script&gt; 方案二：缺点是打包时会把同名文件的文件名修改掉 123456// vite.config.js return defineConfig(&#123; define: &#123; global: JSON.stringify(&#123;&#125;) &#125;&#125;) 3.1.9 babel使用插件@vitejs/plugin-react 12345678910// vite.config.jsreturn defineConfig(&#123; plugins: [ react(&#123; babel: &#123; plugins: [], &#125;, &#125;), ]&#125;) 3.1.10 未解之谜（后来没有再出现了）https://github.com/vitejs/vite/issues/6241 vite@2.5.10没有出现此问题，但评论说还有，所以也暂时不算是解决了。 3.1.11 全局变量define中对应的值是一个常量，需要使用JSON.stringify()来表示是一个常量。 1234567// vite.config.js const country = env.VITE_COUNTRY;return defineConfig(&#123; define: &#123; COUNTRY: JSON.stringify(country) &#125;&#125;) 3.1.12 Uncaught Error: Dynamic require of “/Users/xinweiwang/Desktop/affiliate/web-affiliate/node_modules/@mkt/common-component/dist/LazyImage/default-image.svg” is not supported方案一： 类似问题及解决方案：https://github.com/vitejs/vite/issues/5308 使用插件@originjs/vite-plugin-commonjs处理了： 1234567// vite.config.js const country = env.VITE_COUNTRY;return defineConfig(&#123; plugins: [ viteCommonjs() ]&#125;) 3.1.13 [vite] Internal server error: Failed to resolve import “‘ + name + ‘“ from “node_modules/.vite/react-app-polyfill_stable.js?v=f714c2ed”. Does the file exist?找到一个类似问题 方案：使用@vitejs/plugin-legacy取代react-app-polyfill，具体配置根据实际情况而定。 1234567891011// vite.config.js import legacy from &apos;@vitejs/plugin-legacy&apos;;return defineConfig(&#123; plugins: [ legacy(&#123; targets: [&apos;ie &gt;= 11&apos;], additionalLegacyPolyfills: [&apos;regenerator-runtime/runtime&apos;] &#125;), ]&#125;) 3.1.14 regeneratorRuntime is not definedimport “regenerator-runtime” 3.1.15 Uncaught TypeError: Unknown theme type: undefined, name: undefined解决方案：https://github.com/ant-design/ant-design/issues/19002#issuecomment-965958565 3.2 打包3.2.1 重名问题打包时不允许有重名现象，即使一个是类型名，一个是变量名，会报 Identifier ‘xxx’ has already been declared. 有两处地方存在此问题： /src/components/Payment/BillingDetail/PaymentDetail/index.tsx：PaymentConfirmation /src/components/Payment/Setting/ZipCodeAddress/index.tsx：ZipCodeAddress 3.2.2 压缩后大于500k的文件与业务相关，需要优化具体模块 3.3 打包后预览3.3.1 Uncaught TypeError: Failed to resolve module specifier “indexof”. Relative references must start with either “/“, “./“, or “../“.解决方案：https://github.com/vitejs/vite/issues/2670#issuecomment-905495115 3.3.2 Uncaught ReferenceError: require is not defined// vite.config.js 1234567return defineConfig(&#123; build: &#123; commonjsOptions: &#123; transformMixedEsModules: true &#125; &#125;, &#125;) 3.3.3 Uncaught ReferenceError: exports is not defined未解决：https://github.com/rollup/plugins/issues/1014 临时解决方案：https://github.com/rollup/plugins/issues/1014#issuecomment-1049512712 3.4 Jenkins部署3.5 业务相关以下是业务相关的补充，由于不影响编译打包等，所以并不保证是包含全部的。 3.5.1 svg使用插件vite-plugin-svg-icons生成svg sprite map 1234567891011121314151617// vite.config.js import &#123; createSvgIconsPlugin &#125; from &apos;vite-plugin-svg-icons&apos;;return defineConfig(&#123; plugins: [ createSvgIconsPlugin(&#123; iconDirs: [ path.resolve(process.cwd(), &apos;src/assets/icons&apos;), path.resolve(process.cwd(), &apos;src/assets/svg&apos;) ], symbolId: &apos;[name]&apos; &#125;) ]&#125;)// src/index.tsximport &apos;virtual:svg-icons-register&apos;; 3.5.2 其余基于webpack的插件vite插件合集 webpack插件 类似的vite插 svg-sprite-loader vite-plugin-svg-icons workbox-webpack-plugin vite-plugin-pwa realtime-translation-webpack-plugin babel-plugin-istanbul-shopee 3.5.3 业务相关报错Uncaught (in promise) ReferenceError: require is not defined：类似的require都需要修改 如 src/components/common/Empty 12345// 原来的写法&lt;img src=&#123;require(&apos;@/assets/images/empty.png&apos;)&#125;/&gt;// 改为&lt;img src=&#123;new URL(&apos;../../../assets/images/empty.png&apos;, import.meta.url).href&#125;/&gt; 如 src/translate/index.ts 12345678// 原来的写法const message = require(&apos;./messages/&apos; + language + &apos;.json&apos;);result[language] = regExpEditLanguage(message);// 改为const messages = import.meta.globEager(&apos;./messages/*.json&apos;);const path = `./messages/$&#123;language&#125;.json`;result[language] = regExpEditLanguage(messages[path]); 4.调研结果4.1 原理官网有给出与传统打包工具的对比 4.2 Webpack vs Vite action webpack vite 首次启动 90s~120s 0.4s ~ 1s 首次首屏 很快 约40s 第二次启动首屏 很快 约9s HMR 8s～10s 0.05s ～ 0.2s 打包构建 2min~3min 2min ~ 3min vite的启动比webpack快很多，但首次启动的首屏展示并不快，该加载的包还是要等加载完才展示。 第二次启动时，vite由于缓存，首屏展示速度变快。 官方表示，Vite HMR 更新反映到浏览器的时间小于 50ms。 两者打包速度差不多。 5.结论 在开发上，特别是启动项目时，速度是有一定提升的。 vite还不算很成熟，有很多隐藏问题，甚至有一些问题无法从根本解决，如3.1.10。 并不是所有webpack插件都有对应的vite插件，自定义的更是需要重写，工作量也许很大。 一个庞大的项目，从webpack迁移vite，工作量很大，业务代码也有需要兼容的，例如各种require]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[whistle：利用whistle操作WebSocket请求]]></title>
    <url>%2F2022%2F04%2F26%2F%E5%89%8D%E7%AB%AF%2Fwhistle%EF%BC%9A%E5%88%A9%E7%94%A8whistle%E6%93%8D%E4%BD%9CWebSocket%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[一、安装123npm install -g whistle.script# Mac、Linux用户可能需要加sudosudo npm install -g whistle.script 安装插件后要重启whistle 二、使用打开script插件的界面，创建一个名字为 test 的脚本: 可以通过 Plugins-&gt;Home-&gt;script打开或右键并选择 在新标签页中打开 或者直接访问 http://local.whistlejs.com/plugin.script 三、操作请求1、操作HTTP或HTTPs请求(操作HTTPs需要开启HTTPs拦截)脚本中输入： 12345678910111213141516171819202122232425262728293031exports.handleRequest = function* (ctx, next) &#123; // ctx.fullUrl 可以获取请求url // ctx.headers 可以获取请求头 // ctx.options 里面包含一些特殊的请求头字段，分别可以获取一些额外信息，如请设置的规则等 // ctx.method 获取和设置请求方法 // const reqBody = yield ctx.getReqBody(); 获取请求body的Buffer数据，如果没有数据返回null // const reqText = yield ctx.getReqText(); 获取请求body的文本，如果没有返回&apos;&apos; // const formData = yield ctx.getReqForm(); 获取表单对象，如果不是表单，返回空对象&#123;&#125; // console.log(ctx.method, ctx.headers, reqBody); // ctx.req.body = String| Buffer | Stream | null，修改请求的内容 // 只有执行next方法后才可以把正常的请求发送出去 // 如果需要自定义请求，可以通过全局的request方法操作 // console.log(request); // next方法可以设置next(&#123; host, port &#125;); const &#123; statusCode, headers &#125; = yield next(); console.log(ctx.fullUrl, statusCode, headers); // const resBody = yield ctx.getResBody(); // const resText = yield ctx.getResText(); // ctx.status = 404; 修改响应状态码 // ctx.set(headers); 批量修改响应头 // ctx.set(&apos;x-test&apos;, &apos;abc&apos;); 修改响应头 // ctx.body = String| Buffer | Stream | null; 修改响应内容&#125;; // 如果Node &gt;= 7.6，可以采用async await的方式exports.handleRequest = async (ctx, next) =&gt; &#123; // do sth // next方法可以设置next(&#123; host, port &#125;); const &#123; statusCode, headers &#125; = await next(); // do sth&#125;; 在whistle的Rules配置界面上输入规则（需要放在最前面）: 123script://test games.*.shopee.**# 如果需要通过配置给脚本传递一些额外参数，可以如下配置script://test(a,b,c) games.*.shopee.** 可以在脚本中通过 process.args 获取: 123exports.handleRequest = (ctx, next) =&gt; &#123; console.log(process.args); // output: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#125;; 2、操作WebSocket请求(需要开启HTTPs拦截)脚本中输入： 1234567891011121314151617// Node &lt; 7.6可以改用genrator和yieldexports.handleWebSocket = async (req, connect) =&gt; &#123; // connect方法可以设置connect(&#123; host, port &#125;); const res = await connect(); res.on(&apos;message&apos;, (data) =&gt; &#123; // 在script的Console打印出服务端发送的数据 console.log(&apos;Received: &apos;, data); // 可以修改后再发送到Server req.send(data); &#125;); req.on(&apos;message&apos;, (data) =&gt; &#123; // 在script的Console打印出客户端发送的数据 console.log(&apos;Sent: &apos;, data); // 可以修改后再发送到Server res.send(data); &#125;);&#125;; whistle规则配置同上 更多关于whistle.script的使用详见官网：https://github.com/whistle-plugins/whistle.script]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器内核、渲染引擎、JS引擎]]></title>
    <url>%2F2022%2F04%2F26%2F%E5%89%8D%E7%AB%AF%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95%E2%80%94%E2%80%94Xcode%2F</url>
    <content type="text"><![CDATA[一、下载安装 App Store可以进行下载 安装 1234$ xcode-select --install$ xcode-select -p// 显示以下信息即是成功安装 /Applications/Xcode.app/Contents/Developer 注意安装时出现错误 12345xcode-select -pxcode-select: error: command line tools are already installed, use &quot;Software Update&quot; to install updates// 解决$ rm -rf /Library/Developer/CommandLineTools$ xcode-select --install// 如果还是报错，加上sudo 二、ios模拟器 列出可用的 iOS 模拟器 1$ xcrun instruments -s 安装更多版本模拟器 Simulator 默认只有最新的 iOS 版本的模拟器，如果你需要在老版本的 iOS 上调试，可以这样安装更多版本。 运行Xcode Window -&gt; Devices and Simulator -&gt; Simulator 点击左下角的 + 可以添加其它型号的机器 OS version -&gt; Download more simulator runtime 可以下载其他版本的iOS系统 启动模拟器 12$ xcrun instruments -w XXX// 如 xcrun instruments -w &quot;iPhone 11 (13.6)&quot; 三、安装shopee app 下载需要安装的app压缩包 解压后直接拖入模拟器即可安装 登录时不要打开proxifier，不然会一直pending 四、安装proxifier，配置代理 下载proxifier 安装whistle，运行w2 start启动 运行proxifier，配置 点击Proxies，添加一条 Action 规则代理到本地8899端口 然后点击Rules，新建一个规则，把以下内容添加到 Applications 1Simulator; &quot;Xcode Server Builder”; &quot;MobileSafari”; “com.apple.WebKit.Networking”;k12;vpn;ShopeeSG; 五、安装并信任证书我们开发的都是https页面，需要在配置好代理后，下载安装证书 iphone模拟器里用safari访问127.0.0.1:8899，然后在https那里下载安装证书 模拟器Settings -&gt; General -&gt; Profile, 点击证书进入下载 模拟器Settings -&gt; General -&gt; About -&gt; Certificate Trust Settings, 打开whistle证书信任按钮进行信任 相应安装包和代理配置可参考：whistle代理xcode iphone模拟器调试]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[E2E测试]]></title>
    <url>%2F2022%2F02%2F15%2F%E5%89%8D%E7%AB%AF%2FE2E%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[E2E (end-to-end) E2E测试就是end to end testing，即端到端测试。 它模仿用户，从某个入口开始，逐步执行操作，直到完成某项工作。 E2E 测试并没有那么强调要覆盖全部使用场景，它关注的是一个完整的操作链是否能够完成。对于 Web 前端来说，还关注 界面布局、内容信息是否符合预期。 不管逻辑使用什么框架什么逻辑写的，只想知道浏览器上我要的交互效果，ui展示效果是不是正确的，功能使用上是不是正确的，那么这就叫E2E测试。 cypresscypress是一款开箱即用,可以跑在Chrome浏览器上的测试工具。可以利用Cypress来模拟用户操作了，一方面可以测试代码是否正确，并且还能看到ui相应变化是否符合预期。 安装1$ npm install cypress --save-dev --registry=https://registry.npm.taobao.org 使用可以只写cypress需要访问的服务地址。123456789101112// cypress.json&#123; &quot;baseUrl&quot;: &quot;http://localhost:8000&quot;, #测试访问的路由地址 &quot;reporter&quot;: &quot;junit&quot;, #报告类型 &quot;reporterOptions&quot;: &#123; &quot;mochaFile&quot;: &quot;results/test-[hash].xml&quot;, #输出的文件 &quot;toConsole&quot;: true #是否输出的命令行 &#125;, &quot;viewportHeight&quot;: 800, # viewPort也就是预览窗的高度 &quot;viewportWidth&quot;: 1600 # viewPort也就是预览窗的宽度&#125; 通过cypress open本地打开测试窗口 1$ cypress open 点击右上角的运行所有集成化测试，或是点击单个测试用例单独测试 目录结构123456789101112├── fixtures # mock数据的存储目录，这里存放了所有mock的json文件│ ├── orders.json│ ├── panicBuyings.json│ └── routers.json├── integration # 测试用例代码目录│ ├── orderManagement.spec.js│ └── panicBuyingManagement.spec.js├── plugins # 插件目录│ └── index.js└── support ├── commands.js └── index.js 代码编写模拟用户操作123456789101112131415161718describe(&apos;测试抢购订单管理&apos;, () =&gt; &#123; beforeEach(() =&gt; &#123; #每个测试用例调用之前的操作 const mock = Cypress.env(&apos;MOCK&apos;) || &apos;false&apos;; # 自定义环境变量，运行时传递的话需要指定CYPRESS_前缀，这里使用是CYPRESS_MOCK=true cypress open cy.server(); # 如果需要mock接口的话，必须要运行server if (mock === true) &#123; cy.intercept(&apos;GET&apos;, &apos;/panic-buying/manager/orders*&apos;, &#123; fixture: &apos;orders.json&apos; &#125;).as( &apos;getOrders&apos;, ); # 拦截/panic-buying/manager/order*路由，并指定返回数据使用orders.json，定义这个接口是getOrders函数，用于后面测试使用。 &#125; else &#123; cy.intercept(&apos;GET&apos;, &apos;/panic-buying/manager/orders*&apos;).as(&apos;getOrders&apos;); &#125; &#125;); it(&apos;测试订单列表搜索&apos;, () =&gt; &#123; cy.visit(&apos;/#/rush-order/list&apos;); #访问页面路径 cy.wait(&apos;@getOrders&apos;).its(&apos;response.statusCode&apos;).should(&apos;be.oneOf&apos;, [200, 304]); # 等待getOrders函数，也就是接口返回并判断返回状态是200或是304中的一个。 cy.wait(1000); # 显示的等待1秒 &#125;);&#125;); API更多api操作参考：Commands 测试套件和用例 describe(): 代表测试套件，里面可以设定，一个测试套件可以不包括任何钩子函数（Hook），但必须包含至少一条测试用例 it() ，能嵌套子测试套件。 context(): 是 describe() 的别名，其行为方式是一致的，可以直接用 context() 代替 describe()。 it(): 代表一条测试用例。 …… 钩子函数 before(): 运行 cypress via cypress open 时，打开项目时将触发该事件。每次 cypress run 执行时都会触发该事件，会在第一个用例之前运行。 after()：会在跑完所有的用例之后运行。 beforeEach()：会在每一个用例前运行。 afterEach()：会在每一个用例结束后运行。 …… dom节点 get(): 用来在 DOM 树中查找 DOM 元素，get方法可以像jquery一样通过selector查找到对应的dom。 children()：获取一组 DOM 元素中每个 DOM 元素的子元素。 parent()：获取一组 DOM 元素的父 DOM 元素。 siblings()：获取兄弟 DOM 元素等。 trigger(): 在 DOM 元素上触发事件。 …… 123456789101112131415161718192021// 触发dom的mouseover事件dom.trigger(&apos;mouseover&apos;)// 语法使用示例// eventName（string）event 在DOM元素上要触发的的名称。.trigger(eventName)// position（string）// 应该触发事件的位置。该center位置是默认位置。// 有效的位置topLeft，top，topRight，left，center，right，bottomLeft，bottom，和bottomRight。.trigger(eventName, position)// options: 传递选项对象以更改的默认行为.trigger(eventName, options)// x（number）: 从元素左侧到触发事件的距离（单位px）。// y（number）: 从元素顶部到触发事件的距离（单位px）。.trigger(eventName, x, y).trigger(eventName, position, options).trigger(eventName, x, y, options) 网络接口 intercept: 在网络层管理 HTTP 请求的行为 1234cy.intercept(url, staticResponse)cy.intercept(method, url, staticResponse)cy.intercept(routeMatcher, staticResponse)cy.intercept(url, routeMatcher, staticResponse) Actions行为事件ui自动化操作页面上的元素，常用的方法输入如文本，点击元素，清空文本，点击按钮。还有一些特殊的checkbox,radio,滚动条等。cypress都可以api操作： type(): 往输入框输入文本元素。 focus(): 聚焦DOM元素。 clear(): 清空DOM元素。 rightclick(): 右击 DOM 元素 click()：点击 DOM 元素 select(): select 选项框 进阶有时候一个项目往往十分庞大，并不是所有组件都需要进行E2E测试，因此可以把需要进行测试的组件单独拿出来，本地部署一下，进行测试。 123456├── cypress # cypress目录│ ├── fixtures│ ├── integration│ ├── ...│ └── plugins├── e2e # 需要进行测试的组件代码 单独设置一个小项目，把需要进行测试的组件引进来，组成一个页面，对此页面进行测试。因此在开始测试前，需要先把这个页面跑起来，再开始测试。 参考 前端E2E测试框架 cypress了解一下 UI自动化测试框架Cypress介绍和使用 Cypress自动化测试入门使用]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：正则表达式]]></title>
    <url>%2F2021%2F11%2F24%2FJS%2FJS%EF%BC%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则的三种属性 g：全局匹配 i：忽略大小写（默认区分大小写） m：多行模式 常用方法12let str = &apos;abc&apos;;let reg = /a/gi; test()在字符串中查找符合正则的内容，若找到返回true，否则false 12// 用法：正则.test(字符串)reg.test(str) search()在字符串中搜索符合正则的内容，返回出现的位置，从0开始。若匹配不止一个字符，则返回第一个字符的位置。搜索失败返回-1。 12// 用法：字符串.test(正则)str.test(reg) match()在字符串中搜索符合正则的内容，返回一个数组，里面包含相匹配的内容，失败返回null 12// 用法：字符串.test(正则)str.test(reg) 常用字符非打印字符 字符 描述 \cx 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \f 匹配一个换页符。等价于 \x0c 和 \cL。 \n 匹配一个换行符。等价于 \x0a 和 \cJ。 \r 匹配一个回车符。等价于 \x0d 和 \cM。 \d 匹配0-9之间的任意一个数字。等价于[0-9] \D 匹配所有非数字。等价于[\^0-9]，[]中的^代表非、除了 \w 匹配数字、字母、下划线。等价于[0-9a-zA-Z_] \W 匹配所有非数字、字母、下划线。等价于[\^0-9a-zA-Z_] \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于 \x09 和 \cI。 \v 匹配一个垂直制表符。等价于 \x0b 和 \cK。 特殊字符 字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 \$。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次到多次。要匹配 字符，请使用 \。 + 匹配前面的子表达式一次到多次。要匹配 + 字符，请使用 +。 . 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 [。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。 \ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “\”，而 ‘(‘ 则匹配 “(“。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。 { 标记限定符表达式的开始。要匹配 {，请使用 {。 \ 指明两项之间的一个选择。要匹配 ，请使用 \ 。 限定符 字符 描述 * 匹配前面的子表达式零次到多次。例如，zo 能匹配 “z” 以及 “zoo”。 等价于{0,}。 + 匹配前面的子表达式一次到多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。匹配n 次到多次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，匹配n次到m次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 定位符 字符 描述 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。 \b 匹配一个单词边界，即字与空格间的位置。 \B 非单词边界匹配。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node：删除文件]]></title>
    <url>%2F2021%2F11%2F22%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%2FNode%2FNode%EF%BC%9A%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[步骤 先删文件，清空文件夹 删除空文件夹 相关命令 fs.stat &amp;&amp; fs.statSync 提供了访问文件的属性信息 fs.readdir &amp;&amp; fs.readdirSync 提供读取文件目录信息 fs.unlink &amp;&amp; unlinkSync 进行删除文件操作，不可以删除文件夹 fs.rmdir &amp;&amp; fs.rmdirSync 进行删除文件夹操作，但文件夹必须为空文件夹 12345678910111213141516171819202122// dirPath为需要删除的文件夹路径function removeDir(dirPath) &#123; return new Promise(async (resolve, reject) =&gt; &#123; const files = fs.readdirSync(dirPath); for (let i = 0; i &lt; files.length; i++) &#123; const filePath = path.join(dirPath, files[i]); if (fs.statSync(filePath).isDirectory()) &#123; removeDebug(filePath); continue; &#125; else &#123; fs.unlinkSync(filePath); &#125; &#125; try &#123; fs.rmdirSync(dirPath); &#125; catch(e) &#123; console.error(e); return reject(e); &#125; return resolve(); &#125;)&#125;]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node：版本管理]]></title>
    <url>%2F2021%2F11%2F05%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%2FNode%2FNode%EF%BC%9A%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[使用homebrew进行管理查看当前版本1$ node -v 查看当前有哪些可以安装的版本1$ brew search node 安装node 101$ brew install node@10 解除高版本的关联关系1$ brew unlink node@12 关联node10版本12$ echo &apos;export PATH=&quot;/usr/local/opt/node@10/bin:$PATH&quot;&apos; &gt;&gt; ~/.zshrc$ brew link node@10 执行强制关联低版本命令1$ brew link --force --overwrite node@10 经典案例1背景使用n模块升级node版本后降级失败 解决方法1234567$ sudo chown -R &apos;XinweiWang&apos;:admin /usr/local/include/node$ sudo chown -R &apos;XinweiWang&apos;:admin /usr/local/bin$ sudo chown -R &apos;XinweiWang&apos;:admin /usr/local/share$ sudo chown -R &apos;XinweiWang&apos;:admin /usr/local/lib/dtrace$ brew link --overwrite node@10// 或者$ brew link --overwrite node 经典案例2在unlink node@10且link node@12后，不停提醒 123Warning: Already linked: /usr/local/Cellar/node@12/12.22.3To relink, run: brew unlink node@12 &amp;&amp; brew link --force node@12 但node版本依然是10 解决：打开/usr/local/Cellar，把node@10删掉即可 参考链接mac 系统node.js降级及修改node.js版本失败解决办法]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：MJS]]></title>
    <url>%2F2021%2F11%2F02%2FJS%2FJS%EF%BC%9AMJS%2F</url>
    <content type="text"><![CDATA[.mjs 是什么文件呢？很明显因为 ESM 和 CJS 的加载方式不同，为了更高的区分这两种不同的加载方式，于是创建了 .mjs(Module JavaScript)。.mjs 就是表示当前文件用 ESM 的方式进行加载，如果是普通的 .js 文件，则采用 CJS 的方式加载。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：setTimeout和setInterval]]></title>
    <url>%2F2021%2F11%2F02%2FJS%2FJS%EF%BC%9AsetTimeout%E5%92%8CsetInterval%2F</url>
    <content type="text"><![CDATA[都是延迟一段时间调用回调函数。 setTimeout setTimeout只调用一次。 setTimeout最短间隔时间为4毫秒。setInterval setInterval会一直循环调用函数，不会自己停止。要用clearInterval(计数器编号)来停止。 setInterval最短间隔时间为10毫秒，小于会被调整为10ms。 拓展 使用setInterval有可能定时器代码可能在代码再次被添加到队列之前还没有完成执行，这样有可能导致代码连续运行。 结论：setIntervel具有累积效应，如果某个操作特别耗时，超过了setInterval的时间间隔，排在后面的操作会被累积起来，然后在很短的时间内连续触发，这可能或造成性能问题。 js引擎解决：队列无定时器代码才添加。这样有可能导致某些间隔被跳过。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocos：Cocos接入react组件]]></title>
    <url>%2F2021%2F09%2F17%2FCocos%2FCocos%EF%BC%9ACocos%E6%8E%A5%E5%85%A5react%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[接入redeem store，react组件，cocos不支持tsx ts把tsx编译成js引入 有引入别的文件使用，ts无法把两个文件打成一个文件 使用rolllup编译成js 引入文件过大，导致ts文件崩溃 把js改为插件脚本 把js导出项改为全局变量，直接引用 分包 需要把依赖一起打包到js进行分包 window不适用，继续使用引入的方式 load成功后引入redeem store process is not defined，打包时替换js里的process 部署时，无法获取process，无法替换，直接插入html，全局使用，production不替换 需求基于cocos的游戏接入基于react的兑换商店，即cocos接入react组件 tsx由于兑换商店暴露的是react组件，所以封装成一个tsx文件，接入cocos，html中增加一个节点，把兑换商店插入该节点 问题：cocos不支持接入tsx ts编译通过typescript把tsx编译成js 使用命令行参数–project（或-p）指定一个包含tsconfig.json文件的目录1$ tsc -p redeemStore/tsconfig.json 12345678910111213// tsconfig.json&#123; &quot;compilerOptions&quot;: &#123; &quot;allowSyntheticDefaultImports&quot;: true, &quot;jsx&quot;: &quot;react&quot;, &quot;module&quot;:&quot;esnext&quot;, &quot;target&quot;: &quot;es5&quot;, &quot;rootDir&quot;: &quot;./redeemStore.tsx&quot;, // 用来指定编译文件的根目录，编译器会在根目录查找入口文件 &quot;outDir&quot;: &quot;../assets&quot;, // 用来指定输出文件夹 &quot;baseUrl&quot;: &quot;../&quot;, // 用于设置解析非相对模块名称的基本目录，相对模块不会受到baseUrl的影响 &#125;&#125; 由于有引入别的文件，希望可以全部编译成一个文件 12// 指定输出文件合并为一个文件，只有设置module的值为amd和system模块时才支持这个配置&quot;outFile&quot;: &quot;./&quot;, 问题：无法多个文件编译成一个文件输出 rollup打包123456789101112131415161718192021222324252627// rollup.config.jsimport typescript from &apos;rollup-plugin-typescript2&apos;;import resolve from &apos;rollup-plugin-node-resolve&apos;;import commonjs from &apos;rollup-plugin-commonjs&apos;;export default &#123; input: &apos;redeemStore/redeemStore.tsx&apos;, // 源文件入口 output: &#123; file: &apos;assets/script/page/ui/redeemStore/redeemStore.js&apos;, format: &apos;cjs&apos;, sourcemap: true, compact: true &#125;, plugins: [ resolve(), commonjs(), replace(&#123; &apos;process.env.NODE_ENV&apos;: JSON.stringify(process.env.NODE_ENV), &apos;process.env.country&apos;: JSON.stringify(process.env.cid || process.env.country), &apos;process.env.environment&apos;: JSON.stringify(process.env.env || process.env.environment), &#125;), typescript(), uglify() ],&#125; plugins是有顺序的 rollup-plugin-typescript2使rollup可作用于typescript rollup-plugin-node-resolve / @rollup/plugin-node-resolve rollup 不会去寻找从npm安装到你的node_modules文件夹中的软件包 该插件可以告诉 Rollup 如何查找外部模块 解析 node_modules 中的模块，将所有依赖编译进同一个文件 rollup-plugin-commonjs / @rollup/plugin-commonjs 将 CommonJS 模块转换为 ES6 npm中的大多数包都是以 CommonJS 模块的形式出现的。 在它们更改之前，我们需要将CommonJS模块转换为 ES2015 供 Rollup 处理 该插件应该用在其他插件转换你的模块之前 - 这是为了防止其他插件的改变破坏CommonJS的检测 rollup-plugin-commonjs 会有以下问题123[!] Error: &apos;createElement&apos; is not exported by node_modules/react/index.js, imported by node_modules/@gameplatform-fe-component/redeem-store/dist/es/index.mjshttps://rollupjs.org/guide/en/#error-name-is-not-exported-by-modulenode_modules/@gameplatform-fe-component/redeem-store/dist/es/index.mjs (1:25) 12345commonjs(&#123; namedExports: &#123; &apos;react&apos;: Object.keys(React), &#125;&#125;) rollup-plugin-replace / @rollup/plugin-replace编译过程中可以进行字符串替换 @rollup/plugin-replace 会含有如下警告，仅仅是警告⚠️，不会影响编译1(!) Plugin replace: @rollup/plugin-replace: &apos;preventAssignment&apos; currently defaults to false. It is recommended to set this option to `true`, as the next major version will default this option to `true`. rollup-plugin-uglify代码压缩，使编译后的包更小 全局变量 打包后直接import会导致脚本崩溃，失效。 把其设置为插件脚本。 用window，redeem store设为全局变量去调用。 以上，在分包后都不是问题，因此，这里只是一个小插曲，分包后依然是直接import 分包Asset Bundle 中的脚本 构建cocos可以把一个文件夹设置为bundle，其下的文件都会在构建时单独打包成一个子包，仅仅构建时生效，开发预览依然是一个整包。 加载12345678910111213141516171819enterRedeemPage() &#123; let bundle = assetManager.getBundle(&apos;redeemStore&apos;); if (!bundle) &#123; assetManager.loadBundle(&apos;redeemStore&apos;, err =&gt; &#123; if (err) &#123; return console.error(err); &#125; this.loadRedeemStore(); &#125;); &#125; else &#123; this.loadRedeemStore(); &#125;&#125;async loadRedeemStore() &#123; const store = await import(&apos;./redeemStore/redeemStore.js&apos;); store.default.openStore(app.data.gameConfig, app.data.player.uid, () =&gt; app.ui.open(UIDef.UILandingPage)); this.close();&#125; development vs productiondevelopment 开发环境，分包策略不生效，依然是整包。 直接通过特定的命令编译redeemStore，编译过程某些参数通过特定的命令注入。 若切换地区需要重新编译 1rollup:test:id&quot;: &quot;cross-env NODE_ENV=development cid=id env=test rollup -c&quot; production 部署的同时，对redeemStore进行编译 由于参数无法注入，因此在部署时，通过脚本把参数设为全局变量，以供redeemStore直接读取 1234567window.process = &#123; env: &#123; NODE_ENV: &apos;production&apos;, country: &apos;$&#123;buildConfig.COUNTRY&#125;&apos;, environment: &apos;$&#123;buildConfig.ENVIRONMENT&#125;&apos; &#125;&#125;;]]></content>
      <categories>
        <category>Cocos</category>
      </categories>
      <tags>
        <tag>Cocos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git：一些常用的命令]]></title>
    <url>%2F2021%2F08%2F02%2FGit%2FGit%EF%BC%9A%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[忽略eslint 1git commit --no-verify -m &quot;&quot; 删除本地分支 1git branch -d &lt;branch&gt; 删除远程分支 1git push origin --delete &lt;branch&gt; 设置大小写敏感 1git config core.ignorecase false]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm：更换源]]></title>
    <url>%2F2021%2F07%2F19%2FGit%2Fnpm%EF%BC%9A%E6%9B%B4%E6%8D%A2%E6%BA%90%2F</url>
    <content type="text"><![CDATA[原始源安装完node之后，默认的原始源是： 1https://registry.npmjs.org/ 使用淘宝镜像临时使用1npm --registry https://registry.npm.taobao.org install express 持久使用1npm config set registry https://registry.npm.taobao.org 通过cnpm1npm install -g cnpm --registry=https://registry.npm.taobao.org 使用官方镜像1npm config set registry https://registry.npmjs.org/ 查看npm源地址1npm config get registry]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：虚拟列表]]></title>
    <url>%2F2021%2F07%2F12%2FJS%2FJS%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[特性 循环列表 重复利用 实现思路item的循环利用 自左往右滚动时，将离开视图右方一定距离的item通过设置坐标调整到左方，更新数据成为新的item。 自右往左滚动时，将离开视图左方一定距离的item通过设置坐标调整到右方，更新数据成为新的item。 持续滚动的循环列表 自右往左滚动时，更新item坐标的同时，并实时增加content的高度。 可以在初始化数据时可计算好content的高度，但实时更新也可以，同时也可以实现按需加载。 滚动时，更新item坐标的同时，更新content的位置，同时，将所有item的坐标相对于content的位置更新。 以上需要在一帧内完成，这样才能不影响用户体验。 具体实现属性配置123456// 可循环使用的item数量reusableCount: number;// 上一次content的位置，用于判断左滑还是右滑lastContentX: number;// 第一个item的位置startX: number; 初始化 根据view的宽度计算可用于循环使用的item数量。尽量有1-2个是在view之外的。 记录当前content的位置，用于判断左滑还是右滑 记录第一个item的位置，防止右滑时渲染过多的数据。 滚动 根据当前 content 的位置与 lastContentX 的对比，来判断方向，以决定新的item往左添加还是往右添加。 左滑时，当 item 离开 view 左侧一定距离时，重新设置 item 的位置，x值增加，并且设置新的数据，content 的宽度也增加。 123const offset = (this.itemWidth + this.gap) * this.items.lengthitem.setPosition(item.position.x + offset, 0);this.scrollView.content.width += this.itemWidth + this.gap; 右滑，只需要把离开 view 右侧一定距离的 item 重新设置位置和数据即可，不需要增加 content 的宽度。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocos Creator踩坑记]]></title>
    <url>%2F2021%2F07%2F07%2FCocos%2FCocos%20Creator%E8%B8%A9%E5%9D%91%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[动画编辑 动画在普通模式下是不允许编辑的，只有在动画编辑模式下才可以编辑动画文件。 但是在动画编辑模式下，无法对节点进行添加/删除/重命名操作，并且没有记录在动画关键帧内的属性修改，在退出动画编辑器后也会被还原]]></content>
      <categories>
        <category>Cocos</category>
      </categories>
      <tags>
        <tag>Cocos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocos：事件机制]]></title>
    <url>%2F2021%2F07%2F05%2FCocos%2FCocos%EF%BC%9A%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[事件监听事件处理大多数是在节点（Node）中完成的。对于组件，可以通过访问节点 this.node 来注册和监听事件。监听事件可以通过 this.node.on() 函数来注册，方法如下： 12345// 该事件监听每次都会触发，需要手动取消注册xxx.on(type, func, target?);// 该事件监听在监听函数响应后就会关闭监听事件。xxx.once(type, func, target?); type 为事件注册字符串 func 为执行事件监听的回调 target 为事件接收对象 如果 target 没有设置，则回调里的 this 指向的就是当前执行回调的对象。 值得一提的是，事件监听函数 on 第三个参数 target，主要是绑定响应函数的调用者。以下两种调用方式，效果上是相同的 123456789// 使用函数绑定this.node.on(Node.EventType.MOUSE_DOWN, function ( event ) &#123; this.enabled = false;&#125;.bind(this));// 使用第三个参数this.node.on(Node.EventType.MOUSE_DOWN, (event) =&gt; &#123; this.enabled = false;&#125;, this); 事件取消当我们不再关心某个事件时，我们可以使用 off 方法关闭对应的监听事件。 off 方法的使用方式有两种： 1234// 取消对象身上所有注册的该类型的事件xxx.off(type);// 取消对象身上该类型指定回调指定目标的事件xxx.off(type, func, target); 需要注意的是，off 方法的参数必须和 on 方法的参数一一对应，才能完成关闭。 我们推荐的书写方法如下： 1234567891011121314151617import &#123; _decorator, Component, Node &#125; from &apos;cc&apos;;const &#123; ccclass &#125; = _decorator;@ccclass(&quot;Example&quot;)export class Example extends Component &#123; onEnable () &#123; this.node.on(&apos;foobar&apos;, this._sayHello, this); &#125; onDisable () &#123; this.node.off(&apos;foobar&apos;, this._sayHello, this); &#125; _sayHello () &#123; console.log(&apos;Hello World&apos;); &#125;&#125; 事件派发触发事件有两种方式： emit dispatchEvent，可以做事件传递 emit12// 事件派发的时候可以指定派发参数，参数最多只支持 5 个事件参数xxx.emit(type, ...args); 在触发事件时，我们可以在 emit 函数的第二个参数开始传递我们的事件参数。同时，在 on 注册的回调里，可以获取到对应的事件参数。 1234567891011121314151617import &#123; _decorator, Component, Node &#125; from &apos;cc&apos;;const &#123; ccclass &#125; = _decorator;@ccclass(&quot;Example&quot;)export class Example extends Component &#123; onLoad () &#123; this.node.on(&apos;foo&apos;, (arg1, arg2, arg3) =&gt; &#123; console.log(arg1, arg2, arg3); // print 1, 2, 3 &#125;); &#125; start () &#123; let arg1 = 1, arg2 = 2, arg3 = 3; // At most 5 args could be emit. this.node.emit(&apos;foo&apos;, arg1, arg2, arg3); &#125;&#125; 需要说明的是，出于底层事件派发的性能考虑，这里最多只支持传递 5 个事件参数。所以在传参时需要注意控制参数的传递个数。 dispatchEvent 通过 dispatchEvent 方法派发的事件，会进入事件派发阶段。 在 Cocos Creator 的事件派发系统中，我们采用冒泡派发的方式。 冒泡派发会将事件从事件发起节点，不断地向上传递给它的父级节点，直到到达根节点或者在某个节点的响应函数中做了中断处理 event.propagationStopped = true。 在 v3.0 中，我们移除了 Event.EventCustom 类，如果要派发自定义事件，需要先实现一个自定义的事件类，该类继承自 Event 类。 12345678910// Event 由 cc 模块导入import &#123; Event &#125; from &apos;cc&apos;;class MyEvent extends Event &#123; constructor(name: string, bubbles?: boolean, detail?: any) &#123; super(name, bubbles); this.detail = detail; &#125; public detail: any = null; // 自定义的属性&#125; 以上图为例，当我们从节点 c 发送事件 “foobar”，倘若节点 a，b 均做了 “foobar” 事件的监听，则事件会经由 c 依次传递给 b，a 节点。如： 12// 节点 c 的组件脚本中this.node.dispatchEvent( new MyEvent(&apos;foobar&apos;, true, &apos;detail info&apos;) ); 如果我们希望在 b 节点截获事件后就不再传递事件，我们可以通过调用 event.propagationStopped = true 函数来完成。具体方法如下： 1234// 节点 b 的组件脚本中this.node.on(&apos;foobar&apos;, (event: MyEvent) =&gt; &#123; event.propagationStopped = true;&#125;); 注意：在发送用户自定义事件的时候，请不要直接创建 cc 内的 Event 对象，因为它是一个抽象类。 系统内置事件123456789// 使用枚举类型来注册，推荐node.on(Node.EventType.MOUSE_DOWN, (event) =&gt; &#123; console.log(&apos;Mouse down&apos;);&#125;, this);// 使用事件名来注册node.on(&apos;mouse-down&apos;, (event) =&gt; &#123; console.log(&apos;Mouse down&apos;);&#125;, this); 触摸事件触摸事件冒泡触摸事件支持节点树的事件冒泡，以下图为例：在图中的场景里，假设 A 节点拥有一个子节点 B，B 拥有一个子节点 C。开发者对 A、B、C 都监听了触摸事件（以下的举例都默认节点监听了触摸事件）。 当鼠标或手指在 C 节点区域内按下时，事件将首先在 C 节点触发，C 节点监听器接收到事件。 接着 C 节点会将事件向其父节点传递这个事件，B 节点的监听器将会接收到事件。 同理 B 节点会将事件传递给 A 父节点。这就是最基本的事件冒泡过程。 需要强调的是，在触摸事件冒泡的过程中不会有触摸检测，这意味着即使触点不在 A B 节点区域内，A B 节点也会通过触摸事件冒泡的机制接收到这个事件。 触摸事件的冒泡过程与普通事件的冒泡过程并没有区别。所以，调用 event.propagationStopped = true; 可以主动停止冒泡过程。 同级节点间的触点归属问题 假设上图中 B、C 为同级节点，C 节点部分覆盖在 B 节点之上。 这时候如果 C 节点接收到触摸事件后，就宣布了触点归属于 C 节点，这意味着同级节点的 B 就不会再接收到触摸事件了， 即使触点同时也在 B 节点内。同级节点间，触点归属于处于顶层的节点。 此时如果 C 节点还存在父节点，则还可以通过事件冒泡的机制传递触摸事件给父节点。 不同 Canvas 的触点归属问题 不同 Canvas 之间的触点拦截是根据优先级决定的。 在下图中的场景里，节点树里的 Canvas 1-5 对应图片显示的 priority 1-5。 可以看出，即使 Canvas 节点 3、4、5 之间是按乱序排的，但是根据 Canvas 上的优先级（priority）关系，触点的响应先后顺序仍然是 Canvas5 -&gt; Canvas4 -&gt; Canvas3 -&gt; Canvas2 -&gt; Canvas1。 只有在优先级相同的情况下， Canvas 之间的排序是按节点树的先后顺序进行。 将触摸或鼠标事件注册在捕获阶段 有时候我们需要父节点的触摸或鼠标事件先于它的任何子节点派发，比如 ScrollView 组件就是这样设计的。 这时候事件冒泡已经不能满足我们的需求了，需要将父节点的事件注册在捕获阶段。 要实现这个需求，可以在给 node 注册触摸或鼠标事件时，传入第四个参数 true，表示 useCapture。 1this.node.on(Node.EventType.TOUCH_START, this.onTouchStartCallback, this, true); 当节点触发 touch-start 事件时，会先将 touch-start 事件派发给所有注册在捕获阶段的父节点监听器，然后派发给节点自身的监听器，最后才到了事件冒泡阶段。 只有触摸或鼠标事件可以注册在捕获阶段，其他事件不能注册在捕获阶段。 事件拦截 正常的事件是会按照以上说明的方式去派发。 但是如果节点身上带有 ==Button==,==Toggle== 或者 ==BlockInputEvents== 这几个组件的话，是会停止事件冒泡。 还是看下图。图中有两个按钮，Canvas0 下的 priority 1 和 Canvas1 下的 priority 2。 如果点击两个按钮的交汇处，也就是图中蓝色区域，会出现按钮 priority 2 成功接收到了触点事件，而按钮 priority 1 则没有。 那是因为按上述的事件接收规则，按钮 priority 2 优先接收到了触点事件，并且对事件进行了拦截（event.propagationStopped = true），防止事件穿透。 如果是非按钮节点，也可以通过添加 BlockInputEvents 组件来对事件进行拦截，防止穿透。 触摸事件举例以下图举例，总结下触摸事件的传递机制。图中有 A、B、C、D 四个节点，其中 A、B 为同级节点。具体层级关系如下： 若触点在 A、B 的重叠区域内，此时 B 接收不到触摸事件，事件的传递顺序是 A -&gt; C -&gt; D 若触点在 B 节点内（可见的绿色区域），则事件的传递顺序是 B -&gt; C -&gt; D 若触点在 C 节点内，则事件的传递顺序是 C -&gt; D 若以第 2 种情况为前提，同时 C D 节点的触摸事件注册在捕获阶段，则事件的传递顺序是 D -&gt; C -&gt; B]]></content>
      <categories>
        <category>Cocos</category>
      </categories>
      <tags>
        <tag>Cocos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocos：生命周期]]></title>
    <url>%2F2021%2F07%2F05%2FCocos%2FCocos%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[Cocos Creator 为组件脚本提供了生命周期的回调函数。开发者只需要定义特定的回调函数，Creator 就会在特定的时期自动执行相关脚本，开发者不需要手工调用它们。 目前提供给开发者的生命周期回调函数主要有（按生命周期触发先后排列）： onLoad onEnable start update lateUpdate onDisable onDestroy onLoad 组件脚本的初始化阶段，我们提供了 onLoad 回调函数。 onLoad 回调会在节点首次激活时触发，比如所在的场景被载入，或者所在节点被激活的情况下。 在 onLoad 阶段，保证了你可以获取到场景中的其他节点，以及节点关联的资源数据。 onLoad 总是会在任何 start 方法调用前执行，这能用于安排脚本的初始化顺序。 通常我们会在 onLoad 阶段去做一些初始化相关的操作。 1234567891011121314151617import &#123; _decorator, Component, Node, SpriteFrame, find &#125; from &apos;cc&apos;;const &#123; ccclass, property &#125; = _decorator;@ccclass(&quot;test&quot;)export class test extends Component &#123; @property(&#123;type:SpriteFrame&#125;) bulletSprite=null; @property(&#123;type:Node&#125;) gun=null; _bulletRect=null; onLoad()&#123; this._bulletRect=this.bulletSprite.getRect(); this.gun = find(&apos;hand/weapon&apos;, this.node); &#125;&#125; onEnable 当组件的 enabled 属性从 false 变为 true 时，或者所在节点的 active 属性从 false 变为 true 时，会激活 onEnable 回调。 倘若节点第一次被创建且 enabled 为 true，则会在 onLoad 之后，start 之前被调用。 start start 回调函数会在组件第一次激活前，也就是第一次执行 update 之前触发。 start 通常用于初始化一些中间状态的数据，这些数据可能在 update 时会发生改变，并且被频繁的 enable 和 disable。 1234567891011121314151617181920import &#123; _decorator, Component, Node &#125; from &apos;cc&apos;;const &#123; ccclass, property &#125; = _decorator;@ccclass(&quot;starttest&quot;)export class starttest extends Component &#123; private _timer: number = 0.0; start () &#123; this._timer = 1.0; &#125; update (deltaTime: number) &#123; this._timer += deltaTime; if(this._timer &gt;= 10.0)&#123; console.log(&apos;I am done!&apos;); this.enabled = false; &#125; &#125;&#125; update游戏开发的一个关键点是在每一帧渲染前更新物体的行为，状态和方位。这些更新操作通常都放在 update 回调中。 12345678910import &#123; _decorator, Component, Node &#125; from &apos;cc&apos;;const &#123; ccclass, property &#125; = _decorator;@ccclass(&quot;updatetest&quot;)export class updatetest extends Component &#123; update (deltaTime: number) &#123; this.node.setPosition(0.0,40.0*deltaTime,0.0); &#125;&#125; lateUpdateupdate 会在所有动画更新前执行，但如果我们要在动效（如动画、粒子、物理等）更新之后才进行一些额外操作，或者希望在所有组件的 update 都执行完之后才进行其它操作，那就需要用到 lateUpdate 回调。 12345678910import &#123; _decorator, Component, Node &#125; from &apos;cc&apos;;const &#123; ccclass, property &#125; = _decorator;@ccclass(&quot;lateupdatetest&quot;)export class lateupdatetest extends Component &#123; lateUpdate (deltaTime: number) &#123; this.node.setPosition(0.0,50,0.0); &#125;&#125; onDisable当组件的 enabled 属性从 true 变为 false 时，或者所在节点的 active 属性从 true 变为 false 时，会激活 onDisable 回调。 onDestroy当组件或者所在节点调用了 destroy()，则会调用 onDestroy 回调，并在当帧结束时统一回收组件。]]></content>
      <categories>
        <category>Cocos</category>
      </categories>
      <tags>
        <tag>Cocos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocos：计时器]]></title>
    <url>%2F2021%2F07%2F05%2FCocos%2FCocos%EF%BC%9A%E8%AE%A1%E6%97%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[下面是 Component 中所有关于计时器的函数： schedule：开始一个计时器 scheduleOnce：开始一个只执行一次的计时器 unschedule：取消一个计时器 unscheduleAllCallbacks：取消这个组件的所有计时器 schedule开始一个计时器 1234this.schedule(function() &#123; // 这里的 this 指向 component this.doSomething(); &#125;, 5); 上面这个计时器将每隔 5s 执行一次。 更灵活的计时器 12345678910// 以秒为单位的时间间隔 let interval = 5; // 重复次数 let repeat = 3; // 开始延时 let delay = 10; this.schedule(function() &#123; // 这里的 this 指向 component this.doSomething(); &#125;, interval, repeat, delay); 上面的计时器将在 10 秒后开始计时，每 5 秒执行一次回调，重复 3 次。 scheduleOnce只执行一次的计时器（快捷方式） 1234this.scheduleOnce(function() &#123; // 这里的 this 指向 component this.doSomething(); &#125;, 2); 上面的计时器将在两秒后执行一次回调函数，之后就停止计时。 unschedule取消计时器 开发者可以使用回调函数本身来取消计时器： 12345678910this.count = 0; this.callback = function () &#123; if (this.count == 5) &#123; // 在第六次执行回调时取消这个计时器 this.unschedule(this.callback); &#125; this.doSomething(); this.count++; &#125; this.schedule(this.callback, 1); 注意：组件的计时器调用回调时，会将回调的 this 指定为组件本身，因此回调中可以直接使用 this。]]></content>
      <categories>
        <category>Cocos</category>
      </categories>
      <tags>
        <tag>Cocos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React：useCallback、useMemo、memo]]></title>
    <url>%2F2021%2F05%2F11%2FReact%2FReact%EF%BC%9AuseCallback%E3%80%81useMemo%E3%80%81memo%2F</url>
    <content type="text"><![CDATA[useMome、useCallback用法都差不多，都会在第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行，并且这两个hooks都返回缓存的值，useMemo返回缓存的变量，useCallback返回缓存的函数。 123const value = useMemo(fnM, [a]);const fnA = useCallback(fnB, [a]); memoReact.memo 为高阶组件。它与React.PureComponent非常相似，但它适用于函数组件，但不适用于 class 组件。 默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。这与shouldComponentUpdate 方法的返回值相反。 1234567891011function MyComponent(props) &#123; /* 使用 props 渲染 */&#125;function areEqual(prevProps, nextProps) &#123; /* 如果把 nextProps 传入 render 方法的返回结果与 将 prevProps 传入 render 方法的返回结果一致则返回 true， 否则返回 false */&#125;export default React.memo(MyComponent, areEqual); 当父组件引入子组件的情况下，往往会造成组件之间的一些不必要的浪费 每次父组件更新count，子组件都会更新。使用memo，count变化子组件没有更新。12345678910111213141516const Child = memo((props) =&gt; &#123; console.log(&apos;子组件?&apos;) return( &lt;div&gt;我是一个子组件&lt;/div&gt; );&#125;)const Page = (props) =&gt; &#123; const [count, setCount] = useState(0); return ( &lt;&gt; &lt;button onClick=&#123;(e) =&gt; &#123; setCount(count+1) &#125;&#125;&gt;加1&lt;/button&gt; &lt;p&gt;count:&#123;count&#125;&lt;/p&gt; &lt;Child /&gt; &lt;/&gt; )&#125; useCallback当父组件传递状态给子组件的时候，memo好像没什么效果，子组件还是执行了，这时候我们就要引入hooks的useCallback、useMemo这两个钩子了。 在上面代码基础上，父级调用子级时，在onClick参数上加上useCallback，参数为[]，则第一次初始化结束后，不再改变。 1234567891011121314151617181920212223242526272829//子组件没有必要渲染的例子interface ChildProps &#123; name: string; onClick: Function;&#125;const Child = memo((&#123; name, onClick&#125;: ChildProps): JSX.Element =&gt; &#123; console.log(&apos;子组件?&apos;) return( &lt;&gt; &lt;div&gt;我是一个子组件，父级传过来的数据：&#123;name&#125;&lt;/div&gt; &lt;button onClick=&#123;onClick.bind(null, &apos;新的子组件name&apos;)&#125;&gt;改变name&lt;/button&gt; &lt;/&gt; );&#125;)const Page = (props) =&gt; &#123; const [count, setCount] = useState(0); const [name, setName] = useState(&apos;Child组件&apos;); return ( &lt;&gt; &lt;button onClick=&#123;(e) =&gt; &#123; setCount(count+1) &#125;&#125;&gt;加1&lt;/button&gt; &lt;p&gt;count:&#123;count&#125;&lt;/p&gt; &lt;ChildMemo name=&#123;name&#125; onClick=&#123; useCallback((newName: string) =&gt; setName(newName), []) &#125;/&gt; &#123;/* useCallback((newName: string) =&gt; setName(newName),[]) */&#125; &#123;/* 这里使用了useCallback优化了传递给子组件的函数，只初始化一次这个函数，下次不产生新的函数 &lt;/&gt; )&#125; useCallback性能问题一般会觉得使用useCallback的性能会比普通重新定义函数的性能好。 123456789function App() &#123; const [val, setVal] = useState(&quot;&quot;); const onChange = useCallback(evt =&gt; &#123; setVal(evt.target.value); &#125;, []); return &lt;input val=&#123;val&#125; onChange=&#123;onChange&#125; /&gt;;&#125; 实际性能会更差，上面的写法几乎等同于下面： 12345const temp = evt =&gt; &#123; setVal(evt.target.value);&#125;;const onChange = useCallback(temp, []); 可以看到onChange的定义是省不了的，而且额外还要加上调用useCallback产生的开销，性能怎么可能会更好？ 真正有助于性能改善的，有 2 种场景： 函数定义时需要进行大量运算， 这种场景极少 需要比较引用的场景，如上文提到的useEffect，又或者是配合React.Memo使用 useMemo更新属性name为对象类型，这时子组件还是一样的执行了，在父组件更新其它状态的情况下，子组件的name对象属性会一直发生重新渲染改变，从而导致一直执行,这也是不必要的性能浪费。 解决这个问题，使用name参数使用useMemo，依赖于State.name数据的变化进行更新。 12345678910111213141516171819202122232425262728293031323334353637interface ChildProps &#123; name: &#123; name: string; color: string &#125;; onClick: Function;&#125;const Child = memo((&#123; name, onClick&#125;: ChildProps): JSX.Element =&gt; &#123; console.log(&apos;子组件?&apos;) return( &lt;&gt; &lt;div style=&#123;&#123; color: name.color &#125;&#125;&gt;我是一个子组件，父级传过来的数据：&#123;name.name&#125;&lt;/div&gt; &lt;button onClick=&#123;onClick.bind(null, &apos;新的子组件name&apos;)&#125;&gt;改变name&lt;/button&gt; &lt;/&gt; );&#125;)const Page = (props) =&gt; &#123; const [count, setCount] = useState(0); const [name, setName] = useState(&apos;Child组件&apos;); return ( &lt;&gt; &lt;button onClick=&#123;(e) =&gt; &#123; setCount(count+1) &#125;&#125;&gt;加1&lt;/button&gt; &lt;p&gt;count:&#123;count&#125;&lt;/p&gt; &lt;ChildMemo //使用useMemo，返回一个和原本一样的对象，第二个参数是依赖性，当name发生改变的时候，才产生一个新的对象 name=&#123; useMemo(()=&gt;(&#123; name, color: name.indexOf(&apos;name&apos;) !== -1 ? &apos;red&apos; : &apos;green&apos; &#125;), [name]) &#125; onClick=&#123; useCallback((newName: string) =&gt; setName(newName), []) &#125; &#123;/* useCallback((newName: string) =&gt; setName(newName),[]) */&#125; &#123;/* 这里使用了useCallback优化了传递给子组件的函数，只初始化一次这个函数，下次不产生新的函数 /&gt; &lt;/&gt; )&#125; 总结 在子组件不需要父组件的值和函数的情况下，只需要使用memo函数包裹子组件即可。 在使用函数的情况，需要考虑有没有函数传递给子组件使用useCallback。 在值有所依赖的项，并且是对象和数组等值的时候而使用useMemo（当返回的是原始数据类型如字符串、数字、布尔值，就不要使用useMemo了）。不要盲目使用这些hooks。 参考react Hook之useMemo、useCallback及memo你不知道的 useCallback]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React：useLayoutEffect和useEffect的区别]]></title>
    <url>%2F2021%2F05%2F11%2FReact%2FReact%EF%BC%9AuseLayoutEffect%E5%92%8CuseEffect%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[渲染流程 react 在 diff 后，会进入到 commit 阶段，准备把虚拟 DOM 发生的变化映射到真实 DOM 上。 在 commit 阶段的前期，会调用一些生命周期方法，对于类组件来说，需要触发组件的 getSnapshotBeforeUpdate 生命周期，对于函数组件，此时会调度 useEffect 的 create destroy 函数（注意是调度，不是执行）。 在这个阶段，会把使用了 useEffect 组件产生的生命周期函数入列到 React 自己维护的调度队列中，给予一个普通的优先级，让这些生命周期函数异步执行。 随后，就到了 React 把虚拟 DOM 设置到真实 DOM 上的阶段，这个阶段主要调用的函数是 commitWork，commitWork 函数会针对不同的 fiber 节点调用不同的 DOM 的修改方法，比如文本节点和元素节点的修改方法是不一样的。 commitWork 如果遇到了类组件的 fiber 节点，不会做任何操作，会直接 return，进行收尾工作，然后去处理下一个节点，这点很容易理解，类组件的 fiber 节点没有对应的真实 DOM 结构，所以就没有相关操作。 但在有了 hooks 以后，函数组件在这个阶段，会同步调用上一次渲染时 useLayoutEffect(create, deps) create 函数返回的 destroy 函数。 注意一个节点在 commitWokr 后，这个时候，我们已经把发生的变化映射到真实 DOM 上了。 但由于 JS 线程和浏览器渲染线程是互斥的，因为 JS 虚拟机还在运行，即使内存中的真实 DOM 已经变化，浏览器也没有立刻渲染到屏幕上。 此时会进行收尾工作，同步执行对应的生命周期方法，我们说的componentDidMount，componentDidUpdate 以及 useLayoutEffect(create, deps) 的 create 函数都是在这个阶段被同步执行。 对于 react 来说，commit 阶段是不可打断的，会一次性把所有需要 commit 的节点全部 commit 完，至此 react 更新完毕，JS 停止执行。 浏览器把发生变化的 DOM 渲染到屏幕上，到此为止 react 仅用一次回流、重绘的代价，就把所有需要更新的 DOM 节点全部更新完成。 浏览器渲染完成后，浏览器通知 react 自己处于空闲阶段，react 开始执行自己调度队列中的任务，此时才开始执行 useEffect(create, deps) 的产生的函数。 介绍useEffect 该 Hook 接收一个包含命令式、且可能有副作用代码的函数。在函数组件主体内（这里指在 React 渲染阶段）改变 DOM、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性。使用 useEffect 完成副作用操作。赋值给 useEffect 的函数会在组件渲染到屏幕之后执行。你可以把 effect 看作从 React 的纯函数式世界通往命令式世界的逃生通道。 useEffect 是异步执行的 执行时机是浏览器将所有变化渲染到屏幕后 useLayoutEffect其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。 useLayoutEffect 是同步执行的 执行时机是浏览器把内容真正渲染到界面之前 useLayoutEffect的 create 函数的调用位置、时机都和 componentDidMount，componentDidUpdate 一致，且都是被 React 同步调用，都会阻塞浏览器渲染。 useLayoutEffect 的 detroy 函数的调用位置、时机与 componentWillUnmount 一致，且都是同步调用。 使用方式这两个函数的使用方式其实非常简单，他们都接受一个函数一个数组，只有在数组里面的值改变的情况下才会再次执行 effect。 12useEffect(() =&gt; &#123;&#125;, []);useLayoutEffect(() =&gt; &#123;&#125;, []); 实际应用 DOM操作在useLayoutEffect进行 其余一般在useEffect进行，如数据初始化 当需要进行DOM操作,并且会改变页面的样式时,就需要用useLayoutEffect,否则可能会出现出现闪屏问题。useLayoutEffect里面的callback函数会在DOM更新完成后立即执行,但是会在浏览器进行任何绘制之前运行完成,阻塞了浏览器的绘制。 可以看到在流程9/10期间，DOM 已经被修改，但但浏览器渲染线程依旧处于被阻塞阶段，所以还没有发生回流、重绘过程。由于内存中的 DOM 已经被修改，通过 useLayoutEffect 可以拿到最新的 DOM 节点，并且在此时对 DOM 进行样式上的修改，假设修改了元素的 height，这些修改会在步骤 11 和 react 做出的更改一起被一次性渲染到屏幕上，依旧只有一次回流、重绘的代价。 如果放在 useEffect 里，useEffect 的函数会在组件渲染到屏幕之后执行，此时对 DOM 进行修改，会触发浏览器再次进行回流、重绘，增加了性能上的损耗。 参考深入理解 React useLayoutEffect 和 useEffect 的执行时机]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React：useRef]]></title>
    <url>%2F2021%2F05%2F11%2FReact%2FReact%EF%BC%9AuseRef%2F</url>
    <content type="text"><![CDATA[介绍类组件、React 元素用 React.createRef，函数组件使用 useRef useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。 使用绑定DOM类组件123456789class App extends React.Component &#123; refInput = React.createRef(); componentDidMount() &#123; this.refInput.current &amp;&amp; this.refInput.current.focus(); &#125; render() &#123; return &lt;input ref=&#123;this.refInput&#125; /&gt;; &#125;&#125; 函数组件12345678function App() &#123; const refInput = React.useRef(null); React.useEffect(() =&gt; &#123; refInput.current &amp;&amp; refInput.current.focus(); &#125;, []); return &lt;input ref=&#123;refInput&#125; /&gt;;&#125; 父组件调用子组件方法一些应用场景,需要在父组件中调用子组件定义的方法.这就需要将组件抛出给父组件。 类组件父组件 1234567891011121314151617class ParentComponent extends Component &#123; refChild = React.createRef(); setChildText = () =&gt; &#123; if (this.refChild.current) &#123; this.refChild.current.setText(&quot;text updated by parent component&quot;); &#125; &#125;; render() &#123; return ( &lt;&gt; &#123;/* 父组件引用时,直接使用 ref 即可绑定子组件实例 */&#125; &lt;ChildComponent ref=&#123;this.refChild&#125; /&gt; &lt;button onClick=&#123;this.setChildText&#125;&gt;set text by parent&lt;/button&gt; &lt;/&gt; ); &#125;&#125; 子组件 123456789class ChildComponent extends Component &#123; state = &#123; text: &quot;&quot; &#125;; setText(text = &quot;&quot;) &#123; this.setState(&#123; text &#125;); &#125; render() &#123; return &lt;p&gt;text: &#123;this.state.text&#125;&lt;/p&gt;; &#125;&#125; 函数组件需要配合useImperativeHandle使用 父组件 useRef是一个方法，且useRef返回一个可变的ref对象，initialValue被赋值给其返回值的.current对象。 useRef会在每次渲染时返回同一个ref对象，即返回的ref对象在组件的整个生命周期内保持不变。 ref对象的值发生改变之后，不会触发组件重新渲染。有一个窍门，把它的改变动作放到useState()之前。 1234567891011121314151617function Parent() &#123; const ref = useRef(null); // &#123; current: null &#125; return ( &lt;&gt; &lt;ForwardChild ref=&#123;ref&#125; /&gt; &lt;button onClick=&#123;() =&gt; &#123; ref.current &amp;&amp; ref.current.setTextByParent(&quot;text updated by parent component&quot;); &#125;&#125; &gt; set text by parent &lt;/button&gt; &lt;/&gt; );&#125; 子组件 useImperativeHandle(ref,createHandle,[deps])可以自定义暴露给父组件的实例值。如果不使用，父组件的ref访问不到任何值（ref.current==null） useImperativeHandle应该与forwradRef搭配使用 React.forwardRef会创建一个React组件，这个组件能够将其接受的ref属性转发到其组件树下的另一个组件中。 React.forward接受渲染函数作为参数，React将使用prop和ref作为参数来调用此函数。 1234567891011121314// 函数组件需要使用 forwardRef 包裹forwardRef(function Child(props, ref) &#123; const [text, setText] = useState(&quot;&quot;); // 该 hook 需要定义抛出给父组件的可以使用的 api 方法 // 相当于代理了子组件的方法 useImperativeHandle(ref, () =&gt; (&#123; setTextByParent(text = &quot;&quot;) &#123; setText(text); &#125;, &#125;)); return &lt;p&gt;text: &#123;text&#125;&lt;/p&gt;;&#125;) 参考 useRef使用总结 关于 useRef 的使用]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ant-Design：Form.list使用]]></title>
    <url>%2F2021%2F05%2F11%2FReact%2Fant-design%EF%BC%9AForm.list%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用1234567891011121314&lt;Form&gt; &lt;Form.List name=&apos;data&apos;&gt; &#123;(fields) =&gt; ( fields.map(field =&gt; ( &lt;Form.Item name=&#123;[field.name, &apos;name&apos;]&#125;&gt; &lt;Input style=&#123;&#123; width: 80 &#125;&#125; /&gt; &lt;/Form.Item&gt; &lt;Form.Item name=&#123;[field.name, &apos;age&apos;]&#125;&gt; &lt;InputNumber style=&#123;&#123; width: 80 &#125;&#125; /&gt; &lt;/Form.Item&gt; )) )&#125; &lt;/Form.Lsit&gt;&lt;/Form&gt; 数据结构123456789101112&#123; data: [ &#123; name: &apos;aaa&apos;, age: 11 &#125;, &#123; name: &apos;aaa&apos;, age: 111 &#125; ]&#125; 实际应用 结构和数据一定要对应1234567891011121314151617181920212223242526// 数据结构const listFields = &#123; 1: [&#123;name:a&#125;, &#123;name:b&#125;], 2: [&#123;name:aa&#125;, &#123;name:bb&#125;],&#125;const data = &#123; 1: [&#123;a:11&#125;, &#123;b:10&#125;], 2: [&#123;aa:11&#125;, &#123;bb:10&#125;],&#125;// 使用&lt;Form&gt; &#123; Object.keys(listFields).map(name =&gt; ( &lt;Form.List name=&#123;name&#125;&gt; &#123;(fields) =&gt; ( listFields[name].map((item, index) =&gt; ( &lt;Form.Item name=&#123;[fields[index]?.name, item.name]&#125;&gt; &lt;Input style=&#123;&#123; width: 80 &#125;&#125; /&gt; &lt;/Form.Item&gt; )) )&#125; &lt;/Form.Lsit&gt; )) &#125;&lt;/Form&gt;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React：踩坑记]]></title>
    <url>%2F2021%2F05%2F08%2FReact%2FReact%EF%BC%9A%E8%B8%A9%E5%9D%91%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[使用useState时没有触发渲染，可能是因为将已有的对象传递过去，它认为没有改变，可以这样处理 1setNumbers([..old]); 多个表单不要放同一页面，拆分成多个组件 Redirect一般都放Switch里面，必须放在Switch最后一行（含义：如果上面的路由都匹配不到时，跳转到redirect配置的页面） 里不能使用div，否则会报错]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React：重定向Redirect]]></title>
    <url>%2F2021%2F04%2F28%2FReact%2FReact%EF%BC%9A%E9%87%8D%E5%AE%9A%E5%90%91Redirect%2F</url>
    <content type="text"><![CDATA[React-Router实战：重定向Redirect]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React：rematch]]></title>
    <url>%2F2021%2F04%2F19%2FReact%2FReact%EF%BC%9Arematch%2F</url>
    <content type="text"><![CDATA[rematch是对redux的二次封装，简化了redux是使用，极大的提高了开发体验。rematch仅仅是对redux的封装，没有依赖redux-saga，也没有关联react，因此其可以用在其他的视图库中，如vue等。 Redux vs Rematch item Redux Rematch simple setup ✅ less boilerplate ✅ readability ✅ configurable ✅ ✅ redux devtools ✅ ✅ generated action creators ✅ async thunks async/await 使用项目结构12345678├── index.html├── index.js # 项目的入口├── ....└── store ├── index.js # 引入modules的各个模块，初始化store的地方 └── modules ├── count.js # count模块 └── info.js # info模块 初始化rematch提供 init（）方法，返回一个store的实例。初始化store的时候rematch支持传入多个模块，在中、大型项目中可以根据业务的需要，拆分成多个模块，这样项目的结果就会变得清晰明了。123456789101112import &#123; init &#125; from &apos;@rematch/core&apos;;import count from &apos;./modules/count&apos;;import info from &apos;./modules/info&apos;;const store = init(&#123; models: &#123; count, info, &#125;&#125;)export default store; 业务代码123456789101112131415161718192021222324252627282930// count.jsexport const count = &#123; state: &#123; num: 0 &#125;, reducers: &#123; // 从第二个变量开始为调用 add 时传递进来的参数，后面依次类推，例如：dispatch.count.add(10, 20)时， num1 = 10 , num2 = 20. add(state, num1, num2) &#123; //... return &#123; ...state, num: num1 + num2 &#125; &#125;, remove() &#123; //... return &#123; ...state, num: 0 &#125; &#125; &#125;, effects: &#123; // 第二个变量为当前model的state的值，num1为调用 addAsync 时传递进来的第一个参数，num2为调用时传递的第二个参数，后面依次类推。例如：dispatch.count.ddAsync(10, 20)时，num1 = 10, num2 = 20 async addAsync (num1, rootState, num2) &#123; //... this.add(num1, num2); &#125; &#125;&#125; 事实上每一个模块就是一个对象，该对象包含三个属性：state、reducers、effects。 state：存放模块状态的地方。 educers：改变store状态的地方。 每个reducers函数都会返回一个对象作为模块最新的state。 reducers中的函数必须为同步函数，如果要异步处理数据需要在effects中处理。 注意：只能通过在reducers的函数中通过返回一个新的对象来改变模块中state的值，直接通过修改state的方式是是不能改变模块的state的值。 effects：处理异步数据的地方。比如：异步从服务端获取数据。 注意：在effects中是不能修改模块的state，需要在异步处理完数据后调用reducers中的函数修改模块的state。 获取和修改state有2种方法可以获取state和修改state： 使用redux的高阶组件connect将state、reducers、effects绑定到组件的props上。 使用rematch提供的dispatch和getState。 使用redux的高阶组件connect12345678910const mapStateToProps = (state) =&gt; (&#123; num: state.count.num&#125;)const mapDispatchToProps = (dispatch) =&gt; (&#123; add: (num1, num2) =&gt; &#123; dispatch.count.add(num1, num2); &#125;, remove: dispatch.count.remove&#125;)export default connect(mapStateToProps, mapDispatchToProps)(App); dispatch 和 getState getState：rematch提供的getState方法返回整个store的state对象 如果要单独访问count模块的state，只需要 getState( ).count即可。 dispatch：rematch提供的dispatch可以直接调用整个store中定义的reducers和effects。 例：dispatch.count.add(10, 20) ，其中count为store中的一个model， add 方法为count模块中提供的一个reducers。 调用effects的方法和调用reducers的方法一样。 123456789import React, &#123;Component&#125; from &apos;react&apos;;import &#123; dispatch, getState &#125; from &apos;@rematch/core&apos;;class App extends Component &#123; handleClick = () =&gt; &#123; console.log(getState().count); // &#123;num: 0&#125; dispatch.count.add(10, 20) &#125;;&#125; 参考 Rematchjs rematch：当你受不了redux繁琐写法的时候，是时候了解一波rematch了 Rematch 一个更好用的 Redux]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Egg：入门]]></title>
    <url>%2F2021%2F04%2F15%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%2FEgg%2FEgg%EF%BC%9A%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[完整目录结构12345678910111213141516171819202122232425262728293031323334353637egg-project├── package.json├── app.js (可选)├── agent.js (可选)├── app| ├── router.js│ ├── controller│ | └── home.js│ ├── service (可选)│ | └── user.js│ ├── middleware (可选)│ | └── response_time.js│ ├── schedule (可选)│ | └── my_task.js│ ├── public (可选)│ | └── reset.css│ ├── view (可选)│ | └── home.tpl│ └── extend (可选)│ ├── helper.js (可选)│ ├── request.js (可选)│ ├── response.js (可选)│ ├── context.js (可选)│ ├── application.js (可选)│ └── agent.js (可选)├── config| ├── plugin.js| ├── config.default.js│ ├── config.prod.js| ├── config.test.js (可选)| ├── config.local.js (可选)| └── config.unittest.js (可选)└── test ├── middleware | └── response_time.test.js └── controller └── home.test.js 初始化可以使用脚手架快速生成项目（npm &gt;=6.1.0） 123$ mkdir egg-example &amp;&amp; cd egg-example$ npm init egg[ --type=simple]$ npm i 此时目录结构为 12345678egg-example├── app│ ├── controller│ │ └── home.js│ └── router.js├── config│ └── config.default.js└── package.json 启动项目: 12$ npm run dev$ open http://localhost:7001 项目各模块Router主要用来描述请求 URL 和具体承担执行动作的 Controller 的对应关系 12345// app/router.jsmodule.exports = app =&gt; &#123; const &#123; router, controller &#125; = app; router.get(&apos;/user/:id&apos;, controller.user.info);&#125;; 框架约定了app/router.js文件用于统一所有路由规则。 我们通过 Router 将用户的请求基于 method 和 URL 分发到了对应的 Controller 上 Controller负责解析用户的输入，处理后返回相应的结果 框架推荐 Controller 层主要对用户的请求参数进行处理（校验、转换），然后调用对应的service方法处理业务，得到业务结果后封装并返回： 获取用户通过 HTTP 传递过来的请求参数。 校验、组装参数。 调用 Service 进行业务处理，必要时处理转换 Service 的返回结果，让它适应用户的需求。 通过 HTTP 将结果响应给用户。 Modelapp/model/**用于放置领域模型，可选，由领域类相关插件约定，如egg-sequelize。 我们使用egg-sequelize来操作数据库，通过映射数据库条目到对象，或者对象到数据库条目，这样，我们读写的都是JavaScript对象，并且还会辅助我们将定义好的 Model 对象加载到 app 和 ctx 上，对前端更加友好。 Sequelize我们选择Node的ORM框架Sequelize来操作数据库。这样，我们读写的都是JavaScript对象，Sequelize帮我们把对象变成数据库中的行。 ORM 对象关系映射（Object Relational Mapping，简称ORM）模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。 简单来说，将程序中的对象自动持久化到关系数据库中。 ORM提供了实现持久化层的另一种模式，它采用映射元数据来描述对象关系的映射，使得ORM中间件能在任何一个应用的业务逻辑层和数据库层之间充当桥梁。 简单来说，ORM框架把关系数据库的表结构映射到对象上。 实际使用 Model（可选）：操作数据库，可以通过一些插件简化对数据库的读写操作，如egg-sequelize。 Service：业务逻辑层，在此对数据库进行读写操作。若在 Model 中通过框架操作数据库，则调用Model中的方法。 Controller：接收并处理请求参数，调用 Service 进行业务处理，对返回的参数进行处理并返回给用户。]]></content>
      <categories>
        <category>Egg</category>
      </categories>
      <tags>
        <tag>Egg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：内存泄漏]]></title>
    <url>%2F2021%2F03%2F23%2FJS%2FJS%EF%BC%9A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[内存泄露什么是内存泄露？应用程序不再需要占用内存的时候，由于某些原因，内存没有被操作系统或可用内存池回收。 编程语言管理内存的方式各不相同。只有开发者最清楚哪些内存不需要了，操作系统可以回收。一些编程语言提供了语言特性，可以帮助开发者做此类事情。另一些则寄希望于开发者对内存是否需要清晰明了。 JavaScript 内存管理JavaScript 是一种垃圾回收语言。垃圾回收语言通过周期性地检查先前分配的内存是否可达，帮助开发者管理内存。换言之，垃圾回收语言减轻了“内存仍可用”及“内存仍可达”的问题。两者的区别是微妙而重要的：仅有开发者了解哪些内存在将来仍会使用，而不可达内存通过算法确定和标记，适时被操作系统回收。 JavaScript 内存泄露垃圾回收语言的内存泄露主因是不需要的引用。理解它之前，还需了解垃圾回收语言如何辨别内存的可达与不可达。 内存泄漏排查工具主要借助 Chrome 浏览器进行排查 Performance 在录制前先选中Screenshots、Memory。 点击 record 。 对页面进行操作。 操作结束后，停止录制。 通过JS Heap查看内存泄漏情况。 如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。反之，则有内存泄漏。 MemoryHeap snapshot当生成了第一个快照的时候，开发者工具窗口已经显示了很详细的内存占用情况。字段解释： Constructor — 占用内存的资源类型 Distance — 当前对象到根的引用层级距离 Shallow Size — 对象所占内存（不包含内部引用的其它对象所占的内存）(单位：字节) Retained Size — 对象所占总内存（包含内部引用的其它对象所占的内存）(单位：字节) 将每项展开可以查看更详细的数据信息。 生成第一个快照，通过Summary可以查看内存占用情况。 切回网页进行操作。 再次生成一个快照，可以通过Comparison与第一个快照进行对比。 需要特别注意这个 #Delta ，如果是正值，就代表新生成的内存多，释放的内存少。其中的闭包项 closure ，如果是正值，就说明存在内存泄漏。 Allocation instrumentation on timeline Start recording heap profile 对页面进行操作 操作结束后停止录制 最后会生成柱状图。 高度表示内存大小，蓝色柱是在timeline最后还存在的内存，灰色柱是在timeline结束前已经被回收的内存。 可以通过 Constructor 查看哪些依然被持有 参考链接 JavaScript 内存泄漏教程 记录一次前端内存泄漏排查经历]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TS：修饰符]]></title>
    <url>%2F2021%2F03%2F09%2FTS%2FTS%EF%BC%9A%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[TypeScript 修饰符TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 public、private 和 protected。 修饰符 在类内可访问 在子类中可访问 可通过类实例从外部访问 public (default) Yes Yes Yes protected Yes Yes No private Yes No No public public 修饰的属性或方法是公有的。 所有定义成public的属性和方法都可以在任何地方进行访问。 默认所有的属性和方法都是 public 的。 private private 修饰的属性或方法是私有的。 所有定义成private的属性和方法都只能在类定义内部进行访问。 protected protected 修饰的属性或方法是受保护的。 所有定义成protected的属性和方法可以从类定义内部访问，也可以从子类中访问。]]></content>
      <categories>
        <category>TS</category>
      </categories>
      <tags>
        <tag>TS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Egret：EXML]]></title>
    <url>%2F2021%2F02%2F20%2FEgret%2FEgret%EF%BC%9AEXML%2F</url>
    <content type="text"><![CDATA[在EUI中，EXML是可以运行时加载解析的。可以把它当做标准的文本文件加载后解析，或者直接将exml文本内容嵌入代码中解析。 使用EXML下面的示例描述一个按钮的皮肤12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; &lt;e:Skin class=&quot;skins.ButtonSkin&quot; states=&quot;up,down,disabled&quot; minHeight=&quot;50&quot; minWidth=&quot;100&quot; xmlns:e=&quot;http://ns.egret.com/eui&quot;&gt; &lt;e:Image width=&quot;100%&quot; height=&quot;100%&quot; scale9Grid=&quot;1,3,8,8&quot; alpha.disabled=&quot;0.5&quot; source=&quot;button_up_png&quot; source.down=&quot;button_down_png&quot;/&gt; &lt;e:Label id=&quot;labelDisplay&quot; top=&quot;8&quot; bottom=&quot;8&quot; left=&quot;8&quot; right=&quot;8&quot; size=&quot;20&quot; fontFamily=&quot;Tahoma &apos;Microsoft Yahei&apos;&quot; verticalAlign=&quot;middle&quot; textAlign=&quot;center&quot; text=&quot;按钮&quot; andtextColor=&quot;0x000000&quot;/&gt; &lt;e:Image id=&quot;iconDisplay&quot; horizontalCenter=&quot;0&quot; verticalCenter=&quot;0&quot;/&gt; &lt;/e:Skin&gt; 皮肤文件推荐放在resource目录下 直接引用EXML文件123var button = new eui.Button();button.skinName = &quot;resource/skins/ButtonSkin.exml&quot;;this.addChild(button); 动态加载EXML文件若描述的对象不是皮肤，那么我们就得采用更加通用的一种加载解析方式。可以直接使用EXML.load()方法来加载并解析外部的EXML文件，加载完成后，回调函数的参数会传入解析后的类定义，可以把类定义new出来实例化它，或直接赋值给组件的skinName属性（如果EXML根节点是Skin）。 12345678private init():void&#123; EXML.load(&quot;skins/ButtonSkin.exml&quot;,this.onLoaded,this);&#125;private onLoaded(clazz:any,url:string):void&#123; var button = new eui.Button(); button.skinName = clazz; this.addChild(button);&#125; 嵌入EXML到代码EXML同样也提供了文本的解析方式，这个过程可以直接类比对JSON文件的处理，因为几乎是一样的。可以使用HttpRequest去加载EXML文件的文本内容，然后运行时调用EXML.parse(exmlText)方法去解析即可，会立即返回解析后的类定义。当然，也可以跳过异步加载，直接在代码中嵌入EXML文本内容： 12345678910111213var exmlText = `&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; &lt;e:Skin class=&quot;skins.ButtonSkin&quot; states=&quot;up,down,disabled&quot; minHeight=&quot;50&quot; minWidth=&quot;100&quot; xmlns:e=&quot;http://ns.egret.com/eui&quot;&gt; &lt;e:Image width=&quot;100%&quot; height=&quot;100%&quot; scale9Grid=&quot;1,3,8,8&quot; alpha.disabled=&quot;0.5&quot; source=&quot;button_up_png&quot; source.down=&quot;button_down_png&quot;/&gt; &lt;e:Label id=&quot;labelDisplay&quot; top=&quot;8&quot; bottom=&quot;8&quot; left=&quot;8&quot; right=&quot;8&quot; size=&quot;20&quot; fontFamily=&quot;Tahoma &apos;Microsoft Yahei&apos;&quot; verticalAlign=&quot;middle&quot; textAlign=&quot;center&quot; text=&quot;按钮&quot; textColor=&quot;0x000000&quot;/&gt; &lt;e:Image id=&quot;iconDisplay&quot; horizontalCenter=&quot;0&quot; verticalCenter=&quot;0&quot;/&gt; &lt;/e:Skin&gt;`;var button = new eui.Button();button.skinName = exmlText;this.addChild(button); 可以使用模板字面量（template literals）进行多行字符串的嵌入，从而避免了用 “n”+ 符号来进行字符串连接。即直接使用头尾一对 ` 符号（波浪线那个按键）来包裹多行文本 包含在模板字面量中的文本内容，还可以使用 ${key} 等嵌入的表达式来引用代码中的变量，进行简洁的字符串拼接 123var className = &quot;skins.ButtonSkin&quot;;var exmlText = `&lt;e:Skin class=&quot;$&#123;className&#125;&quot; states=&quot;up,over,down,disabled&quot; xmlns:s=&quot;http://ns.egret.com/eui&quot;&gt; ... &lt;/e:Skin&gt;`; EXML基本语法根节点12&lt;e:Group class=&quot;app.MyGroup&quot; xmlns:e=&quot;http://ns.egret.com/eui&quot;&gt; &lt;/e:Group&gt; EXML跟XML一样，是由标签组成的。 每个标签都有个命名空间前缀，例如&lt;e:Group&gt;中的e,它的对应命名空间声明也在根节点上：xmlns:e=”http://ns.egret.com/eui&quot;。 以e这个命名空间开头的节点，表示在EUI这个UI库中的组件。而&lt;e:Group&gt;中的Group就是对应代码中eui.Group这个类。 这个例子中只有一个根节点，根节点上的class属性表示它在运行时解析后要注册为的全局类名。以上的EXML文件，在运行时解析后完全等价于如下代码： 1234567module app &#123; export class MyGroup extends eui.Group &#123; public constructor()&#123; super(); &#125; &#125;&#125; 从这个例子可以看出EXML文件与代码的对应关系。EXML解析后会变成一个自定义类，继承的父类就是EXML的根节点，模块名和类名定义在跟节点上的class属性内。 注意:一定要加class这个属性，否则编译会报错 添加子项上面的例子只有一个根节点，将它扩展，添加一个Image子项： 12&lt;e:Group class=&quot;app.MyGroup&quot; xmlns:e=&quot;http://ns.egret.com/eui&quot;&gt; &lt;e:Image /&gt; &lt;/e:Group&gt; 以上内容等价于如下代码： 123456789module app &#123; export class MyGroup extends eui.Group &#123; public constructor()&#123; super(); var image = new eui.Image(); this.addChild(image); &#125; &#125;&#125; 设置属性刚刚的例子只添加了一个空图片，什么都显示不出来，接下来给它设置一些属性： 123&lt;e:Group class=&quot;app.MyGroup&quot; xmlns:e=&quot;http://ns.egret.com/eui&quot;&gt; &lt;e:Image source=&quot;image/button_up.png&quot; x=&quot;10&quot;/&gt; &lt;/e:Group&gt; ID属性我们可以在节点上声明一个id属性，注意这个id属性与HTML中的id并不是一回事，它的结果相当于给解析后的类声明了一个公开变量。例如： 123&lt;e:Group class=&quot;app.MyGroup&quot; xmlns:e=&quot;http://ns.egret.com/eui&quot;&gt; &lt;e:Image id=&quot;iconDisplay&quot; /&gt; &lt;/e:Group&gt; 数据绑定EXMl支持数据绑定功能，数据绑定相当于是给静态的EXML文件添加动态脚本的功能，能够极大简化视图刷新的代码量。得益于JavaScript的动态语言特性，所有的Object对象都可以实现动态数据绑定，并不限定于Egret框架内的对象。在EXML中实现数据绑定只需要一对{}括号： 123&lt;e:ItemRenderer class=&quot;skins.ItemRendererSkin&quot; xmlns:e=&quot;http://ns.egret.com/eui&quot;&gt; &lt;e:Label id=&quot;labelDisplay&quot; text=&quot;&#123;data.label&#125;&quot;/&gt; &lt;/e:ItemRenderer&gt; 例如上面的例子，在Label节点的text属性上声明了一个数据绑定：{data.label}，它表示text属性的值始终与根节点ItemRender的data属性上的label值相同。当ItemRender的data属性发生改变，或data上的label属性发生改变时，数据绑定都会自动通知Label重新对text属性赋值，从而刷新视图。 注意目前数据绑定只支持属性链访问，即a.b.c.d.x这种形式,还不支持直接声明复杂表达式的绑定。若遇到复杂表达式的情况，需要自行在外部完成转换，将最终计算结果赋值到数据对象上。 内部类在很多情况下，都需要引用一些只使用一次的EXML文件，对于这种情况，现在更好的做法是直接内嵌它，而不再需要额外创建一个文件再引用它。例如一个Button，需要引用一个皮肤，通常的做法是分成两个文件，创建一个ButtonSkin.exml文件用于描述按钮皮肤，在另一个EXML文件中使用skinName属性引用它的类名： ButtonSkin.exml 123&lt;e:Skin class=&quot;skins.ButtonSkin&quot; states=&quot;up,over,down,disabled&quot; xmlns:e=&quot;http://ns.egret.com/eui&quot;&gt; &lt;e:Label id=&quot;labelDisplay&quot; left=&quot;20&quot; right=&quot;20&quot; top=&quot;10&quot; bottom=&quot;10&quot;/&gt; &lt;/e:Skin&gt; MyGroup.exml 1234&lt;e:Group class=&quot;skins.MyGroup&quot; xmlns:e=&quot;http://ns.egret.com/eui&quot;&gt; &lt;e:Button label=&quot;按钮&quot; skinName=&quot;skins.ButtonSkin&quot;&gt; &lt;/e:Button&gt;&lt;/e:Group&gt; 上面的例子，可以直接写在同一个文件内,等价于以下内容： MyGroup.exml 1234567&lt;e:Group class=&quot;skins.MyGroup&quot; xmlns:e=&quot;http://ns.egret.com/eui&quot;&gt; &lt;e:Button label=&quot;按钮&quot;&gt; &lt;e:Skin states=&quot;up,over,down,disabled&quot;&gt; &lt;e:Label id=&quot;labelDisplay&quot; left=&quot;20&quot; right=&quot;20&quot; top=&quot;10&quot; bottom=&quot;10&quot;/&gt; &lt;/e:Skin&gt; &lt;/e:Button&gt; &lt;/e:Group&gt; 这种写法能够有效减少EXML的文件数量，仅当皮肤需要复用时，再创建独立的EXML文件。 参考链接EXML]]></content>
      <categories>
        <category>Egret</category>
      </categories>
      <tags>
        <tag>Egret</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Egret：eui.list]]></title>
    <url>%2F2021%2F02%2F20%2FEgret%2FEgret%EF%BC%9Aeui.list%2F</url>
    <content type="text"><![CDATA[起因简易版的引导轮播图 优化前 不利于添加新的引导 中途退出需要从头开始 优化后 添加新引导，修改guide数组即可 中途退出从下一张开始展示 若没有浏览到最后一张，且更换设备，需要从头开始 列表渲染vuev-for，数据绑定 egreteui.List dataProvider：列表数据源 allowMultipleSelection：是否允许多选 selectedIndex：选中项目的基于 0 的索引 selectedIndices：当前选中的一个或多个项目的索引列表 selectedItems：表示当前选定数据项的列表 eui.ItemRenderer属性 data：要呈示或编辑的数据 itemIndex：项呈示器的数据提供程序中的项目索引 selected：如果项呈示器可以将其自身显示为已选中，则为 true 方法 dataChanged() touchCaptured() onTouchCancle() onTouchBegin() onStageTouchEnd() getCurrentState() eui.ArrayCollection addItem()：向列表末尾添加指定项目。 addItemAt()：在指定的索引处添加项目。 getItemAt()：获取指定索引处的项目。 getItemIndex()：如果项目位于列表中，返回该项目的索引。 itemUpdated()：通知视图，某个项目的属性已更新。 refresh()：在对数据源进行排序或过滤操作后可以手动调用此方法刷新所有数据，以更新视图。 removeAll()：删除列表中的所有项目。 removeItemAt()：删除指定索引处的项目并返回该项目。 replaceAll()：用新数据源替换原始数据源，此方法与直接设置source不同，它不会导致目标视图重置滚动位置。 replaceItemAt()：替换在指定索引处的项目，并返回该项目。 eui.CheckBox selected：按钮处于按下状态时为 true，而按钮处于弹起状态时为 false eui.skin states：为此组件定义的视图状态。1234// 使用：属性.状态 &lt;e:Skin states=&quot;up,down&quot;&gt; &lt;e:Image source.up=&quot;guide_json.image_turning1&quot; source.down=&quot;guide_json.image_turning2&quot;/&gt;&lt;/e:Skin&gt; 参考链接Egret List + ItemRenderer使用]]></content>
      <categories>
        <category>Egret</category>
      </categories>
      <tags>
        <tag>Egret</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Egret：锚点（anchorOffset）]]></title>
    <url>%2F2021%2F02%2F20%2FEgret%2FEgret%EF%BC%9A%E9%94%9A%E7%82%B9%EF%BC%88anchorOffset%EF%BC%89%2F</url>
    <content type="text"><![CDATA[锚点egret中对锚点(anchorOffsetX,anchorOffsetY)的使用目的，基本是和CSS3属性中的transform-origin是一致的，大多是基于元素中心的旋转和放大。但使用方法上是有区别的， egret的默认锚点在左上角 transform-origin默认在元素中心 此外，egret这类工具（还有createjs，pixi等）本身是基于canvas/webgl的画布上进行绘制 设置锚点123a.x = 100a.y = 100a.anchorOffsetX = 50 元素旋转、缩放都是基于锚点 元素默认锚点在左上角，此时左上角的坐标点为(100, 100)，锚点坐标为(0, 0) 锚点对元素位置的影响设置锚点后，锚点坐标变为(50, 0)，此时，元素会左移50，左上角的坐标点即xy值会变为(50, 100) 12a.x = a.x - a.anchorOffsetXa.y = a.y - a.anchorOffsetY 恢复元素位置如果希望设置锚点，但又不希望改变元素位置，可以设置锚点后，再加回来 12345a.x = 100a.y = 100a.anchorOffsetX = 50a.x = a.x + a.anchorOffsetXa.y = a.y + a.anchorOffsetY 注意 设置锚点后，xy值会修改，元素位置会改变，元素的xy坐标依然是元素左上角的坐标 缩放、旋转，xy值不会修改，元素位置会改变，因此元素的xy坐标有可能不再是原来a点的坐标，也不再是元素左上角的坐标，因此元素的xy点会根据元素位置的改变而指向不同的点，值却不会变 因此缩放、旋转后，想要移动元素位置，可以根据元素的xy坐标点的位置与此时元素的哪一个部分位于那个位置，来进行修改移动 参考链接白鹭引擎(egret)中锚点(anchoroffset)的位置体会]]></content>
      <categories>
        <category>Egret</category>
      </categories>
      <tags>
        <tag>Egret</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Egret：矢量绘图]]></title>
    <url>%2F2021%2F02%2F20%2FEgret%2FEgret%EF%BC%9A%E7%9F%A2%E9%87%8F%E7%BB%98%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[公共方法beginFill(color, alpha)设置矩形的填充颜色。 color：填充矩形的颜色值 alpha：1表示完全不透明，0表示透明 lineStyle(lineWidth, color)添加描边，设置线条的样式 lineWidth：线条宽度 color：线条颜色值 endFill()结束当前绘制操作。 clear()清空绘图 绘制矩形drawRect(x, y, width, height) x、y：矩形左上角的X、Y轴坐标 width、height：矩形的宽和高 1234567var shp:egret.Shape = new egret.Shape();shp.x = 20;shp.y = 20;shp.graphics.lineStyle(10, 0x00ff00);shp.graphics.beginFill(0xff0000, 1);shp.graphics.drawRect(0, 0, 100, 200);shp.graphics.endFill(); 注意若设置了新建的shape的x、y值，则矩形的x、y坐标是以shape为基准，否则以容器为基准 绘制圆角矩形drawRoundRect(x, y ,width ,height ,ellipseWidth ,ellipseHeight) x、y：圆角矩形左上角的X、Y轴坐标 width、height：圆角矩形的宽和高 ellipseWidth：用于绘制圆角的椭圆的宽度 ellipseHeight：用于绘制圆角的椭圆的高度 123456var shp:egret.Shape = new egret.Shape();shp.x = 20;shp.y = 20;shp.graphics.beginFill(0xff0000, 1);shp.graphics.drawRoundRect(0, 0, 100, 200, 24, 24);shp.graphics.endFill(); 绘制圆形drawCircle(x, y, radius) x、y：圆心的X、Y轴坐标 radius：半径 1234567var shp:egret.Shape = new egret.Shape();shp.x = 100;shp.y = 100;shp.graphics.lineStyle(10, 0x00ff00);shp.graphics.beginFill(0xff0000, 1);shp.graphics.drawCircle(0, 0, 50);shp.graphics.endFill(); 绘制直线moveTo(x, y)绘制直线的起始点 lineTo(x, y)绘制直线的终点 注意 绘制折线时，无需多次使用 moveTo() 方法，连续使用 lineTo() 方法即可 若使用beginFill()，可以为绘制的闭合图像填充颜色。若终点没有回到起点进行闭合，会连接两个点进行闭合 123456var shp:egret.Shape = new egret.Shape();shp.graphics.lineStyle( 2, 0x00ff00 );shp.graphics.moveTo( 68, 84 );shp.graphics.lineTo( 167, 76 );shp.graphics.lineTo( 221, 118 );shp.graphics.endFill(); 绘制曲线curveTo(x1, y1, x2, y2)绘制是“二次贝塞尔曲线” P0是起始点，P1是控制点，P2是终点 x1、y1：控制点(P1)的X、Y轴坐标 x2、y2：终点(P2)的X、Y轴坐标 12345var shp:egret.Shape = new egret.Shape();shp.graphics.lineStyle(2, 0x00ff00 );shp.graphics.moveTo(50, 50);shp.graphics.curveTo(100,100, 200,50);shp.graphics.endFill(); 注意执行绘图时，先使用 moveTo() 方法指定曲线的起始点，然后使用 curveTo() 指定曲线的控制点和终点。 绘制圆弧drawArc(x, y, radius, startAngle, endAngle, anticlockwise) x、y：圆弧路径的圆心的X、Y轴坐标 radius：圆弧半径 startAngle、endAngle：圆弧起点终点的角度，从x轴正方向开始计算，以弧度为单位 anticlockwise：绘制方向，true为逆时针绘制圆弧，反之顺时针，默认为false 12345var shp:egret.Shape = new egret.Shape();shp.graphics.beginFill( 0x1122cc );// Math.PI 表示弧度 πshp.graphics.drawArc(200,200,100,0,Math.PI,true);shp.graphics.endFill(); 参考链接使用矢量绘图]]></content>
      <categories>
        <category>Egret</category>
      </categories>
      <tags>
        <tag>Egret</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React：React Hooks]]></title>
    <url>%2F2021%2F02%2F20%2FReact%2FReact%EF%BC%9AReact%20Hooks%2F</url>
    <content type="text"><![CDATA[组件类的缺点React 的核心是组件。v16.8 版本之前，组件的标准写法是类（class） 12345678910111213141516171819import React, &#123; Component &#125; from &quot;react&quot;;export default class Button extends Component &#123; constructor() &#123; super(); this.state = &#123; buttonText: &quot;Click me, please&quot; &#125;; &#125; handleClick = () =&gt; &#123; this.setState(&#123; buttonText: &quot;Thanks, been clicked!&quot; ; &#125;); &#125; render() &#123; const &#123; buttonText &#125; = this.state; return &lt;button onClick=&#123;this.handleClick&#125;&gt;&#123;buttonText&#125;&lt;/button&gt;; &#125;&#125; 这个组件类仅仅是一个按钮，但可以看到，它的代码已经很”重”了。真实的 React App 由多个类按照层级，一层层构成，复杂度成倍增长。再加入 Redux，就变得更复杂。 Redux 的作者 Dan Abramov 总结了组件类的几个缺点: 大型组件很难拆分和重构，也很难测试。 业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑。 组件类引入了复杂的编程模式，比如 render props 和高阶组件。 函数组件React 团队希望，组件不要变成复杂的容器，最好只是数据流的管道。开发者根据需要，组合管道即可。 组件的最佳写法应该是函数，而不是类。 React 早就支持函数组件，下面就是一个例子。 123function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; 但是，这种写法有重大限制，必须是纯函数，不能包含状态，也不支持生命周期方法，因此无法取代类。 React Hooks 的设计目的，就是加强版函数组件，完全不使用”类”，就能写出一个全功能的组件 React HooksHook 这个单词的意思是”钩子”。 React Hooks 的意思是，组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来。 React Hooks 就是那些钩子。 你需要什么功能，就使用什么钩子。React 默认提供了一些常用钩子，你也可以封装自己的钩子。 所有的钩子都是为函数引入外部功能，所以 React 约定，钩子一律使用use前缀命名，便于识别。你要使用 xxx 功能，钩子就命名为 usexxx。 下面介绍 React 默认提供的四个最常用的钩子。 useState() useContext() useReducer() useEffect() useState()：状态钩子useState()用于为函数组件引入状态（state）。纯函数不能有状态，所以把状态放在钩子里面。 本文前面那个组件类，用户点击按钮，会导致按钮的文字改变，文字取决于用户是否点击，这就是状态。使用useState()重写如下。 1234567891011import React, &#123; useState &#125; from &quot;react&quot;;export default function Button() &#123; const [buttonText, setButtonText] = useState(&quot;Click me, please&quot;); function handleClick() &#123; return setButtonText(&quot;Thanks, been clicked!&quot;); &#125; return &lt;button onClick=&#123;handleClick&#125;&gt;&#123;buttonText&#125;&lt;/button&gt;;&#125; Button 组件是一个函数，内部使用useState()钩子引入状态。 useState()这个函数接受状态的初始值，作为参数，上例的初始值为按钮的文字。 该函数返回一个数组，数组的第一个成员是一个变量（上例是buttonText），指向状态的当前值。第二个成员是一个函数，用来更新状态，约定是set前缀加上状态的变量名（上例是setButtonText）。 useContext()：共享状态钩子如果需要在组件之间共享状态，可以使用useContext()。 123456789101112131415161718192021222324252627import React, &#123; useState, useContext &#125; from &quot;react&quot;;const AppContext = React.createContext(&#123; title: &apos;&apos; &#125;);export default function Button () &#123; const First = () =&gt; &#123; const &#123; title &#125; = useContext(AppContext); return &lt;button&gt;&#123; title + 1 &#125;&lt;/button&gt;; &#125; const Second = () =&gt; &#123; const &#123; title &#125; = useContext(AppContext); return &lt;button&gt;&#123; title + 2 &#125; &lt;/button&gt; &#125; return ( &lt;AppContext.Provider value=&#123;&#123; title: &apos;test&apos; &#125;&#125;&gt; &lt;First&gt;&lt;/First&gt; &lt;Second&gt;&lt;/Second&gt; &lt;/AppContext.Provider&gt; )&#125; 第一步就是使用 React Context API，在组件外部建立一个 Context。需要保证父子组件使用的都是同一个AppContext。 AppContext.Provider提供了一个 Context 对象，这个对象可以被子组件共享。 useContext()钩子函数用来引入 Context 对象，从中获取title属性。 useReducer()：action 钩子React 本身不提供状态管理功能，通常需要使用外部库。这方面最常用的库是 Redux。 Redux 的核心概念是，组件发出 action 与状态管理器通信。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态，Reducer 函数的形式是(state, action) =&gt; newState。 useReducers()钩子用来引入 Reducer 功能。 1const [state, dispatch] = useReducer(reducer, initialState); 上面是useReducer()的基本用法，它接受 Reducer 函数和状态的初始值作为参数，返回一个数组。数组的第一个成员是状态的当前值，第二个成员是发送 action 的dispatch函数。 1234567891011export const testReducer = (state, action) =&gt; &#123; switch(action.type) &#123; case(&apos;change&apos;): return &#123; ...state, title: &apos;test dispatch&apos; &#125; default: return state; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334import React, &#123; useState, useContext, useReducer &#125; from &quot;react&quot;;import &#123; testReducer &#125; from &apos;../store/reducer&apos;;const AppContext = React.createContext(&#123; title: &apos;&apos; &#125;);export default function Button () &#123; const [buttonText, setButtonText] = useState(&apos;test&apos;); const [state, dispatch] = useReducer(testReducer, &#123; title: &apos;test reducer&apos; &#125;); const First = () =&gt; &#123; return &lt;button onClick=&#123; handleClickFirst &#125;&gt;&#123; buttonText &#125;&lt;/button&gt;; &#125; const Second = () =&gt; &#123; return &lt;button onClick=&#123; () =&gt; dispatch(&#123; type: &apos;change&apos; &#125;) &#125;&gt;change&lt;/button&gt; &#125; function handleClickFirst () &#123; return setButtonText(state.title); &#125; return ( &lt;AppContext.Provider value=&#123;&#123; title: &apos;test&apos; &#125;&#125;&gt; &lt;First&gt;&lt;/First&gt; &lt;Second&gt;&lt;/Second&gt; &lt;/AppContext.Provider&gt; )&#125; 由于 Hooks 可以提供共享状态和 Reducer 函数，所以它在这些方面可以取代 Redux。但是，它没法提供中间件（middleware）和时间旅行（time travel），如果你需要这两个功能，还是要用 Redux。 useEffect()：副作用钩子useEffect()用来引入具有副作用的操作，最常见的就是向服务器请求数据。以前，放在componentDidMount里面的代码，现在可以放在useEffect()。 123456useEffect(() =&gt; &#123; // do some side effects return () =&gt; &#123; // optional, clean up &#125;&#125;/* , [dependencies] */) 上面用法中，useEffect()接受两个参数。 第一个参数是一个函数，异步操作的代码放在里面。 第二个参数是一个数组，用于给出 Effect 的依赖项，只要这个数组发生变化，useEffect()就会执行。 第二个参数可以省略，这时每次组件渲染时，就会执行useEffect()。 123456789101112131415161718192021222324const Person = (&#123; personId &#125;) =&gt; &#123; const [loading, setLoading] = useState(true); const [person, setPerson] = useState(&#123;&#125;); useEffect(() =&gt; &#123; setLoading(true); fetch(`https://swapi.co/api/people/$&#123;personId&#125;/`) .then(response =&gt; response.json()) .then(data =&gt; &#123; setPerson(data); setLoading(false); &#125;); &#125;, [personId]) if (loading === true) &#123; return &lt;p&gt;Loading ...&lt;/p&gt; &#125; return &lt;div&gt; &lt;p&gt;You&apos;re viewing: &#123;person.name&#125;&lt;/p&gt; &lt;p&gt;Height: &#123;person.height&#125;&lt;/p&gt; &lt;p&gt;Mass: &#123;person.mass&#125;&lt;/p&gt; &lt;/div&gt;&#125; 上面代码中，每当组件参数personId发生变化，useEffect()就会执行。组件第一次渲染时，useEffect()也会执行。 自定义 Hooks上例的 Hooks 代码还可以封装起来，变成一个自定义的 Hook，便于共享。 1234567891011121314export default const usePerson = (personId) =&gt; &#123; const [loading, setLoading] = useState(true); const [person, setPerson] = useState(&#123;&#125;); useEffect(() =&gt; &#123; setLoading(true); fetch(`https://swapi.co/api/people/$&#123;personId&#125;/`) .then(response =&gt; response.json()) .then(data =&gt; &#123; setPerson(data); setLoading(false); &#125;); &#125;, [personId]); return [loading, person];&#125;; usePerson()就是一个自定义的 Hook。 Person 组件就改用这个新的钩子，引入封装的逻辑。 1234567891011121314151617import &#123; usePerson &#125; from &quot;./usePerson.ts&quot;;const Person = (&#123; personId &#125;) =&gt; &#123; const [loading, person] = usePerson(personId); if (loading === true) &#123; return &lt;p&gt;Loading ...&lt;/p&gt;; &#125; return ( &lt;div&gt; &lt;p&gt;You&apos;re viewing: &#123;person.name&#125;&lt;/p&gt; &lt;p&gt;Height: &#123;person.height&#125;&lt;/p&gt; &lt;p&gt;Mass: &#123;person.mass&#125;&lt;/p&gt; &lt;/div&gt; );&#125;; 参考链接React Hooks 入门教程]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React：生命周期]]></title>
    <url>%2F2021%2F02%2F20%2FReact%2FReact%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[React的生命周期从广义上分为三个阶段：挂载、渲染、卸载 因此可以把React的生命周期分为两类：挂载卸载过程和更新过程。 之前的生命周期挂载卸载过程 constructor componentWillMount render componentDidMount constructor()constructor()中完成了React数据的初始化，它接受两个参数：props和context，当想在函数内部使用这两个参数时，需使用super()传入这两个参数。注意：只要使用了constructor()就必须写super(),否则会导致this指向错误。 componentWillMount()componentWillMount()一般用的比较少，它更多的是在服务端渲染时使用。它代表的过程是组件已经经历了constructor()初始化数据后，但是还未渲染DOM时。 componentDidMount()组件第一次渲染完成，此时dom节点已经生成，可以在这里调用ajax请求，返回数据setState后组件会重新渲染 componentWillUnmount ()在此处完成组件的卸载和数据的销毁。 clear你在组建中所有的setTimeout,setInterval 移除所有组建中的监听 removeEventListener 有时候我们会碰到一个warning。 1234567891011121314原因：因为你在组件中的ajax请求返回setState,而你组件销毁的时候，请求还未完成，因此会报warning解决方法：componentDidMount() &#123; this.isMount === true axios.post().then((res) =&gt; &#123; this.isMount &amp;&amp; this.setState(&#123; // 增加条件ismount为true时 aaa:res &#125;)&#125;)&#125;componentWillUnmount() &#123; this.isMount === false&#125; 更新过程 componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate componentWillReceiveProps (nextProps) 在接受父组件改变后的props需要重新渲染组件时用到的比较多 接受一个参数nextProps 通过对比nextProps和this.props，将nextProps的state为当前组件的state，从而重新渲染组件 12345678componentWillReceiveProps (nextProps) &#123; nextProps.openNotice !== this.props.openNotice&amp;&amp;this.setState(&#123; openNotice:nextProps.openNotice &#125;，() =&gt; &#123; console.log(this.state.openNotice:nextProps) //将state更新为nextProps,在setState的第二个参数（回调）可以打 印出新的state &#125;)&#125; shouldComponentUpdate(nextProps,nextState) 主要用于性能优化(部分更新) 唯一用于控制组件重新渲染的生命周期，由于在react中，setState以后，state发生变化，组件会进入重新渲染的流程，在这里return false可以阻止组件的更新 因为react父组件的重新渲染会导致其所有子组件的重新渲染，这个时候其实我们是不需要所有子组件都跟着重新渲染的，因此需要在子组件的该生命周期中做判断 componentWillUpdate (nextProps,nextState)shouldComponentUpdate返回true以后，组件进入重新渲染的流程，进入componentWillUpdate,这里同样可以拿到nextProps和nextState。 componentDidUpdate(prevProps,prevState)组件更新完毕后，react只会在第一次初始化成功会进入componentDidmount,之后每次重新渲染后都会进入这个生命周期，这里可以拿到prevProps和prevState，即更新前的props和state。 render()render函数会插入jsx生成的dom结构，react会生成一份虚拟dom树，在每一次组件更新时，在此react会通过其diff算法比较更新前后的新旧DOM树，比较以后，找到最小的有差异的DOM节点，并重新渲染。 React v16.4+ 的生命周期变更 React16废弃的三个生命周期函数 componentWillMount componentWillReceiveProps componentWillUpdate 目前在16版本中componentWillMount，componentWillReceiveProps，componentWillUpdate并未完全删除这三个生命周期函数，而且新增了UNSAFE_componentWillMount，UNSAFE_componentWillReceiveProps，UNSAFE_componentWillUpdate三个函数，官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们 取而代之的是两个新的生命周期函数 static getDerivedStateFromProps getSnapshotBeforeUpdate 挂载卸载过程 constructor getDerivedStateFromProps componentWillMount/UNSAVE_componentWillMount render componentDidMount getDerivedStateFromProps1static getDerivedStateFromProps(nextProps, prevState) 一个静态方法，所以不能在这个函数里面使用this，这个函数有两个参数props和state，分别指接收到的新参数和当前的state对象 这个函数会返回一个对象用来更新当前的state对象，如果不需要更新可以返回null 该函数会在挂载时，接收到新的props，调用了setState和forceUpdate时被调用 这个方法就是为了取代之前的componentWillMount、componentWillReceiveProps和componentWillUpdate 当我们接收到新的属性想去修改我们state，可以使用getDerivedStateFromProps 更新过程 componentWillReceiveProps/UNSAFE_componentWillReceiveProps getDerivedStateFromProps shouldComponentUpdate componentWillUpdate/UNSAFE_componentWillUpdate render getSnapshotBeforeUpdate componentDidUpdate getSnapshotBeforeUpdate1getSnapshotBeforeUpdate(prevProps, prevState) 这个方法在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表示之前的属性和之前的state 这个函数有一个返回值，会作为第三个参数传给componentDidUpdate，如果你不想要返回值，请返回null，不写的话控制台会有警告 这个方法一定要和componentDidUpdate一起使用，否则控制台也会有警告 这个方法时用来代替componentWillUpdate 参考链接 React的生命周期 我对 React v16.4 生命周期的理解]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[whistle插件：whistle.script]]></title>
    <url>%2F2021%2F02%2F20%2F%E5%89%8D%E7%AB%AF%2Fwhistle%E6%8F%92%E4%BB%B6%EF%BC%9Awhistle.script%2F</url>
    <content type="text"><![CDATA[whistle.scriptwhistle.script为whistle的一个扩展脚本插件，可以直接在界面上引用全局安装的Node模块及Node的内容模块编写脚本操作请求及其响应，所有正常Node程序可以实现的功能，都可以通过该插件实现，包括： HTTP[s]: 动态设置whistle规则 拦截请求响应 控制请求响应速度 修改请求url、请求方法、请求头、请求内容 修改响应状态码、响应头、响应内容 在插件界面的Console上显示脚本程序 console.xxx 的内容，如果可以打印响应的内容或调试信息等 WebSocket: 动态设置whistle规则 拦截请求响应 修改发送或收到的数据 直接向WebSocket客户端或服务端发送数据 在插件界面的Console上显示脚本程序 console.xxx 的内容，如果可以打印发送和接收到的数据或调试信息等，从而通过该插件可以直接查看WebSocket的数据 Tunnel: 基本功能同WebSocket，可以用来直接操作Socket请求，如Protobuf协议的请求等 安装123npm install -g whistle.script# Mac、Linux用户可能需要加sudosudo npm install -g whistle.script 安装插件后要重启whistle才可以打开插件，否则unknown 使用打开script插件的界面，创建一个名字为 test 的脚本: 可以通过 Plugins-&gt;Home-&gt;script打开或右键并选择 在新标签页中打开 或者直接访问 http://local.whistlejs.com/plugin.script 设置规则 设置HTTP或HTTPs请求的whistle规则(操作HTTPs需要开启HTTPs拦截) 在界面中的test 脚本输入 1234567exports.handleRequestRules = (ctx) =&gt; &#123; // ctx.fullUrl 可以获取请求url // ctx.headers 可以获取请求头 // ctx.options 里面包含一些特殊的请求头字段，分别可以获取一些额外信息，如请求方法、设置的规则等 ctx.rules = [&apos;www.qq.com file://&#123;test.html&#125;&apos;]; ctx.values = &#123; &apos;test.html&apos;: &apos;Hello world.&apos; &#125;;&#125;; 如果里面包含一些异步方法可以采用generator函数或async函数，即：exports.handleRequestRules = function* (ctx) {} 或 exports.handleRequestRules = async () =&gt; {} 在whistle的Rules配置界面上输入规则: 1whistle.script://test www.ifeng.com www.qq.com www.baidu.com echo.websocket.org 如果需要通过配置给脚本传递一些额外参数，可以如下配置(注意中间不能有空格): 1whistle.script://test(a,b,c) www.ifeng.com www.qq.com www.baidu.com echo.websocket.org 可以在脚本中通过 process.args 获取: 12345exports.handleRequestRules = (ctx) =&gt; &#123; console.log(process.args); // output: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] ctx.rules = [&apos;www.qq.com file://&#123;test.html&#125;&apos;]; ctx.values = &#123; &apos;test.html&apos;: &apos;Hello world.&apos; &#125;; &#125;; 设置WebSocket请求的规则(需要开启HTTPs拦截): 123456exports.handleWebSocketRules = (ctx) =&gt; &#123; // ctx.fullUrl 可以获取请求url // ctx.headers 可以获取请求头 // ctx.options 里面包含一些特殊的请求头字段，分别可以获取一些额外信息，如请求方法、设置的规则等 this.rules = &apos;127.0.0.1 echo.websocket.org&apos;; &#125;; 接下来的操作同上。 设置Tunnel请求的规则(要测试可以暂时关闭HTTPs拦截): 123456exports.handleTunnel = (ctx) =&gt; &#123; // ctx.fullUrl 可以获取请求url // ctx.headers 可以获取请求头 // ctx.options 里面包含一些特殊的请求头字段，分别可以获取一些额外信息，如请求方法、设置的规则等 this.rules = &apos;127.0.0.1 www.baidu.com&apos;; &#125;; 接下来的操作同上。 操作请求 操作HTTP或HTTPs请求(操作HTTPs需要开启HTTPs拦截) 12345678910111213141516171819202122232425262728293031exports.handleRequest = function* (ctx, next) &#123; // ctx.fullUrl 可以获取请求url // ctx.headers 可以获取请求头 // ctx.options 里面包含一些特殊的请求头字段，分别可以获取一些额外信息，如请设置的规则等 // ctx.method 获取和设置请求方法 // const reqBody = yield ctx.getReqBody(); 获取请求body的Buffer数据，如果没有数据返回null // const reqText = yield ctx.getReqText(); 获取请求body的文本，如果没有返回&apos;&apos; // const formData = yield ctx.getReqForm(); 获取表单对象，如果不是表单，返回空对象&#123;&#125; // console.log(ctx.method, ctx.headers, reqBody); // ctx.req.body = String| Buffer | Stream | null，修改请求的内容 // 只有执行next方法后才可以把正常的请求发送出去 // 如果需要自定义请求，可以通过全局的request方法操作 // console.log(request); // next方法可以设置next(&#123; host, port &#125;); const &#123; statusCode, headers &#125; = yield next(); console.log(ctx.fullUrl, statusCode, headers); // const resBody = yield ctx.getResBody(); // const resText = yield ctx.getResText(); // ctx.status = 404; 修改响应状态码 // ctx.set(headers); 批量修改响应头 // ctx.set(&apos;x-test&apos;, &apos;abc&apos;); 修改响应头 // ctx.body = String| Buffer | Stream | null; 修改响应内容 &#125;; // 如果Node &gt;= 7.6，可以采用async await的方式 exports.handleRequest = async (ctx, next) =&gt; &#123; // do sth // next方法可以设置next(&#123; host, port &#125;); const &#123; statusCode, headers &#125; = await next(); // do sth &#125;; 在whistle的Rules配置界面上输入规则: 12345# 这里不能用whistle.script，否则请求不会转发到handleRequest# whistle.script只会执行handleXxxRules# 你也可以通过在handleXxxRules里面设置 script://test(a,b,c)，实现转发script://test www.ifeng.com www.qq.com www.baidu.com echo.websocket.org 需要在配置中带上参数，可以参考上面的规则设置 操作WebSocket请求(需要开启HTTPs拦截) 12345678910111213// Node &lt; 7.6可以改用genrator和yield exports.handleWebSocket = async (req, connect) =&gt; &#123; // connect方法可以设置connect(&#123; host, port &#125;); const res = await connect(); res.on(&apos;message&apos;, (data) =&gt; &#123; console.log(&apos;Received: &apos;, data); req.send(data); &#125;); req.on(&apos;message&apos;, (data) =&gt; &#123; console.log(&apos;Sent: &apos;, data); res.send(data); &#125;); &#125;; whistle规则配置同上 操作Tunnel请求 1234567// Node &gt;= 7.6可以改用async和await exports.handleTunnel = function* (req, connect) &#123; // connect方法可以设置connect(&#123; host, port &#125;); const res = yield connect(); req.pipe(res).pipe(req); // 也可以参考上面操作WebSocket，自己监听data和write方法处理，这样就可以直接修改和打印内容 &#125;; whistle规则配置同上 参考链接whistle.script]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器内核、渲染引擎、JS引擎]]></title>
    <url>%2F2021%2F02%2F20%2F%E5%89%8D%E7%AB%AF%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E3%80%81%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E3%80%81JS%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[定义 浏览器内核分成两部分：渲染引擎和JS引擎。 由于JS引擎越来越独立，浏览器内核 就倾向于 单指 渲染引擎。 渲染引擎是一种对HTML文档进行解析并将其显示在页面上的工具。（说白了，就是按照HTML代码在界面上绘制各种控件图形） 常见引擎渲染引擎 firefox使用gecko引擎 IE使用Trident引擎 2015年微软推出自己新的浏览器，原名叫斯巴达，后改名edge,使用edge引擎 opera最早使用Presto引擎，后来弃用 chrome\safari\opera使用webkit引擎 13年chrome和opera开始使用Blink引擎 JS 引擎 老版本IE使用Jscript引擎 IE9之后使用Chakra引擎 edge浏览器仍然使用Chakra引擎 firefox使用monkey系列引擎 safari使用的SquirrelFish系列引擎 Opera使用Carakan引擎 chrome使用V8引擎。nodeJs其实就是封装了V8引擎 参考链接浏览器内核、渲染引擎、JS引擎简介]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调试神器whistle的安装使用]]></title>
    <url>%2F2021%2F02%2F20%2F%E5%89%8D%E7%AB%AF%2F%E8%B0%83%E8%AF%95%E7%A5%9E%E5%99%A8whistle%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[搭建环境准备安装nodewhistle支持v0.10.0以上版本的Node，为获取更好的性能，推荐安装最新版本的Node。 123// 未安装的去官网进行安装// 安装后通过命令行可查看版本$ node -v 安装whistle对于全局安装，Mac或Linux的非root用户需要在命令行前面加sudo。1$ npm install -g whistle whistle安装完成后，执行命令 whistle help 或 w2 help，查看whistle的帮助信息。 12// 如果能正常输出whistle的帮助信息，表示whistle已安装成功$ w2 help 使用whistle123// 启动whistle// 不设置端口，默认8899$ w2 start -p 8899 Note: 如果要防止其他人访问配置页面，可以在启动时加上登录用户名和密码 -n yourusername -w yourpassword。 12// 重启whsitle$ w2 restart 12// 停止whistle$ w2 stop 123// 调试模式启动whistle// 主要用于查看whistle的异常及插件开发$ w2 run 配置代理配置信息 代理服务器：127.0.0.1 默认端口：8899，若被占用，可启动时设置端口 配置方式一：pc端官网推荐配置浏览器代理，推荐安装浏览器代理插件SwitchyOmega，就按官网的来吧，其他配置方式可参考官网 由于常用chrome，以chrome为例 安装根证书 参考网站：安装根证书 安装证书后就可以抓取https的包了 SwitchyOmega配置进入SwitchyOmega，点击安装扩展后，页面会自动跳转到 SwitchyOmega 的配置页，随后便有新手教程 点击左侧“新建情景模式…”，弹框提示“情景模式名称”，你可以输入“whistle” 类型为代理服务器，点击创建 修改代理服务器参数，代理协议为HTTP，代理服务器为127.0.0.1，代理端口为8899 “不代理的地址列表” 的输入框里的所有文本都删掉，因为里面的 host 在本地开发很大概率会用到 点击左侧“应用选项” 点击chrmoe右上角的圆圈，切换为whistle（一定是切换后才可以抓包） 浏览器进入local.whistlejs.com，可以打开界面，证明配置成功，可以开始抓包了 配置方式二：移动端移动端需要在设置中配置当前Wi-Fi的代理，以 iOS 为例： 注意 安装插件后要重启whistle才可以打开插件，否则unknown 参考链接whistle]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React：路由跳转]]></title>
    <url>%2F2021%2F01%2F12%2FReact%2FReact%EF%BC%9A%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[路由跳转引入依赖1import &#123; withRouter, RouteComponentProps &#125; from &apos;react-router-dom&apos;; 组件继承上面依赖中的路由组件接口123class testPage extends React.Component&lt;RouteComponentProps, &#123;&#125;&gt; &#123; // ...&#125; 如果props有其他参数 123456type Props = RouteComponentProps &amp; &#123; // ...&#125;class testPage extends React.Component&lt;Props, &#123;&#125;&gt; &#123; // ...&#125; 导出使用 withRouter 包装 1export default withRouter(testPage); 如果有引入redux 1export default connect(stateToProps, dispatchToProps)(withRouter(testPage)); 使用123public clickSearch = (value: string) =&gt; &#123; this.props.history.push( &apos;/test/testpage&apos; );&#125; 路由传参路由表配置参数地址栏显示，刷新页面，参数不丢失1&lt;Route path=&quot;/test/testpage/:id&quot; component=&#123; OtherDetail &#125; /&gt; 需要获取参数的页面的类型声明 1234// RouteComponentProps里的参数必须为stringtype Props = RouteComponentProps&lt;&#123; id: string &#125;&gt; &amp; &#123; // ...&#125; 跳转1this.props.history.push( &apos;/test/testpage/2&apos; ); 获取1this.props.match.params.id query方法(新版本已废弃)路由不需要额外配置，参数地址栏不显示，刷新地址栏，参数丢失 跳转123456this.props.history.push(&#123; pathname: &apos;/test/testpage&apos;, query: &#123; id: &apos;0&apos; &#125;&#125;) 获取1this.props.location.query.id search方法（新版本）路由不需要额外配置，参数地址栏显示，刷新地址栏，参数不丢失 跳转12345this.props.history.push(&#123; pathname: &apos;/test/testpage&apos;, search: &apos;?id=1&apos; &#125;) 获取1this.props.location.search state方法路由不需要额外配置，参数地址栏不显示，刷新地址栏，参数丢失 跳转123456this.props.history.push(&#123; pathname: &apos;/test/testpage&apos;, state: &#123; id: &apos;0&apos; &#125;&#125;) 获取1this.props.location.state.id]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React：Antd组件踩坑记]]></title>
    <url>%2F2021%2F01%2F11%2FReact%2FReact%EF%BC%9AAntd%E7%BB%84%E4%BB%B6%E8%B8%A9%E5%9D%91%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Form 问题：表单中的Select组件设置value值无效 解决：Select中增加key属性，取值与value值一致 问题：item中无法设置value， 解决：通过initialValues设置 Select 问题：动态设置的Select组件设置defaultValue值无效 解决：Select中增加key属性，取值与defaultValue值一致]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React：初学React]]></title>
    <url>%2F2021%2F01%2F04%2FReact%2FReact%EF%BC%9A%E5%88%9D%E5%AD%A6React%2F</url>
    <content type="text"><![CDATA[chrome中的react插件 点击chrome浏览器右上角三个点-更多工具-&gt;扩展程序（或者在浏览器里面直接输入chrome://extensions/也可以进入到扩展程序里面） 点击左上角【扩展程序】-【打开Chrome网上应用店】 搜索React，将会出现一系列与react有关的插件，安装react developer tools插件。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React：父子组件通信]]></title>
    <url>%2F2020%2F12%2F25%2FReact%2FReact%EF%BC%9A%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[父组件向子组件通信由于react是单向数据流向的，父组件一般通过props向子组件传递相关的一些信息 12345// 父组件&lt;Test visible=&#123;visible&#125; /&gt;// 子组件this.props.visible 子组件向父组件通信父组件向子组件传递方法，子组件可以通过调用方法向父组件传递子组件的参数，或者操作父组件的数据。 12345// 父组件&lt;Test visible=&#123;visible&#125; onCancel=&#123;(visible)=&gt; this.setState(&#123; visible &#125;)/&gt;// 子组件this.props.onCancel(this.state.visible); 跨级组件通信通过context进行通信。 我们可以把组件之间的关系想象成一个组件树，原始的方法就是通过props一级一级的把状态往下传，在通过调用方法一级一级传回去。 另一种方法就是在他们之间设置一个区域，每个组件都可以访问到，相当于父组件下的一个全局变量。 123456789101112131415161718192021222324252627// 最顶部的父组件import PropTypes from &apos;prop-types&apos;;class Index extends Component &#123; static childContextTypes = &#123; themeColor: PropTypes.string &#125; constructor () &#123; super() this.state = &#123; themeColor: &apos;red&apos; &#125; &#125; getChildContext () &#123; return &#123; themeColor: this.state.themeColor &#125; &#125; render () &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;Main /&gt; &lt;/div&gt; ) &#125;&#125; 要在父组件设置这个context区域，在childContextTypes中设置允许子组件们访问的变量的名称，getChildContext（）会设置这个区域，这样所有的子组件都可以访问到themeColor这个参数了 12345678910111213141516// 子组件// 通过在this.context就可以访问import PropTypes from &apos;prop-types&apos;;class Title extends Component &#123; static contextTypes = &#123; themeColor: PropTypes.string &#125; render () &#123; return ( &lt;h1 style=&#123;&#123; color: this.context.themeColor &#125;&#125;&gt;React.js 小书标题&lt;/h1&gt; ) &#125;&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：为什么Array.forEach无法跳出循环]]></title>
    <url>%2F2020%2F11%2F20%2FJS%2FJS%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88Array.forEach%E6%97%A0%E6%B3%95%E8%B7%B3%E5%87%BA%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[参考：JS-为什么forEach无法跳出循环 前情提要之前发现使用forEach循环数组时是无法跳出循环的，break和return都不生效。使用break会报错而使用return，数组中的所有元素依然会被遍历。 foreach的使用123arr.forEach(callback(currentValue[, index[, array]]) &#123; // execute something&#125;[, thisArg]); callback： 在每个元素上执行的功能。它接受一到三个参数： currentValue：数组中正在处理的当前元素。 index（可选的）：currentValue数组中的索引。 array（可选的）：该数组forEach()被调用。 thisArg（可选的）：this执行时用作的值callback。 有一段关于跳出循环的提示 为什么foreach的源码有点长，可以简单易懂地总结为如下 1234Array.prototype.myEach = function(callback) &#123; for (var i = 0; i &lt; this.length; i++) callback(this[i], i, this);&#125;; 我们传入的function是这里的回调函数。在回调函数里面使用break肯定是非法的，因为break只能用于跳出循环，而我们的回调函数不是循环体。 在forEach中使用return，就只是在回调函数中使用return，将结果返回到上级函数，也就是这个for循环中，并不能影响到上级函数中的for循环，并没有结束for循环，所以return也是无效的。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Egret：drawcall优化]]></title>
    <url>%2F2020%2F11%2F19%2FEgret%2FEgret%EF%BC%9Adrawcall%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[原理绘制成图集，需要时直接获取添加 将每一个纸屑生成动态纹理，再全部添加到一个容器中，一起生成一个图集 图集保留在单例中，不需要反复生成 注意 图集中的每一片纸屑不能重合 容器中的x、y要对应图集中的位置 图集中y轴的基准与容器中的是相反的 容器中y的0点在最上方，越往下越大 图集中y的0点在最下方，越往上越大 因此在图集中生成texture对象时，容器中的y1 = 20，对应图集中的y2 = 屏幕高度 - y1 - 纸屑高度]]></content>
      <categories>
        <category>Egret</category>
      </categories>
      <tags>
        <tag>Egret</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git：git stash]]></title>
    <url>%2F2020%2F11%2F02%2FGit%2FGit%EF%BC%9Agit%20stash%2F</url>
    <content type="text"><![CDATA[参考：git stash的详细讲解 作用 git stash命令用于暂时保存没有提交的工作。运行该命令后，所有没有commit的代码，都会暂时从工作区移除，回到上次commit时的状态。 它处于git reset –hard（完全放弃还修改了一半的代码）与git commit（提交代码）命令之间，很类似于“暂停”按钮。 1234567891011121314151617181920212223242526# 暂时保存没有提交的工作，并且将当前代码切换到HEAD提交上# 可以多次运行，以“先进后出”的stack结构存储$ git stash // git stash save# 展示目前存在的stash$ git stash show -p# 列出所有暂时保存的工作$ git stash liststash@&#123;0&#125;: WIP on workbranch: 56cd5d4 Revert &quot;update old files&quot;stash@&#123;1&#125;: WIP on project1: 1dd87ea commit &quot;fix typos and grammar&quot;# 恢复某个暂时保存的工作$ git stash apply stash@&#123;1&#125;# 恢复最近一次stash的文件$ git stash pop# 丢弃最近一次stash的文件$ git stash drop# 丢弃某一个stash的文件$ git stash drop stash@&#123;1&#125;# 删除所有的stash$ git stash clear 实际应用开发到一半,同步远端代码当你的开发进行到一半,但是代码还不想进行提交 ,然后需要同步去关联远端代码时.如果你本地的代码和远端代码没有冲突时,可以直接通过git pull解决.但是如果可能发生冲突怎么办.直接git pull会拒绝覆盖当前的修改. 遇到这种情况,需要先保存本地的代码,进行git pull,然后再pop出本地代码 123git stashgit pullgit stash pop 工作流被打断,需要先做别的需求当开发进行到一半,老板过来跟你说”线上有个bug,你现在给我改好,不然扣你鸡腿”.当然,你可以开一个新的分支,把当前代码提交过去,回头再merge,具体代码如下 繁琐的工作流示例 1234567$ git checkout -b my_wip$ git commit -a -m &quot;WIP&quot;$ git checkout master// edit emergency fix$ git commit -a -m &quot;Fix in a hurry&quot;$ git checkout my_wip$ git reset --soft HEAD^ 我们可以通过git stash来简化这个流程 正确姿势 1234$ git stash // 保存开发到一半的代码// edit emergency fix$ git commit -a -m &quot;Fix in a hurry&quot;$ git stash pop // 将代码追加到最新的提交]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git：git reset和git revert]]></title>
    <url>%2F2020%2F10%2F23%2FGit%2FGit%EF%BC%9Agit%20reset%E5%92%8Cgit%20revert%2F</url>
    <content type="text"><![CDATA[参考：Git撤销&amp;回滚操作(git reset 和 get revert) git reset git reset ：回滚到某次提交。 git reset –soft：此次提交之后的修改会被退回到暂存区 git reset –hard：此次提交之后的修改不做任何保留，git status 查看工作区是没有记录的。 git reset的作用是修改HEAD的位置 即将HEAD指向的位置改变为之前存在的某个版本，且那个版本之后提交的版本都会不见 查看版本号 1$ git log 回退，版本号填写前六位即可 1234$ git reset --hard &lt;目标版本号&gt;$ git reset --hard HEAD //当前版本$ git reset --hard HEAD^ //回退到上一个版本$ git reset --hard HEAD^^ //回退到上上一个版本 提交 12// 直接push会报错，需要强制push$ git push origin &lt;分支名&gt; --force git revert git revert用于“反做”某一个版本，以达到撤销该版本的修改的目的 即新增一个版本，该版本与想要回退的版本一致 查看版本号 1$ git log 回退，版本号填写前六位即可 12// -n是--no-commit如果不带这个参数会自动提交一条commit$ git revert -n &lt;目标版本号&gt; 提交 123$ git add .$ git commit -m &quot;revert&quot;$ git push origin &lt;分支名&gt; 实际应用场景场景一 糟了，我刚把不想要的代码，commit到本地仓库中了，但是还没有做push操作！ 在未进行git push前的所有操作，都是在“本地仓库”中执行的。我们暂且将“本地仓库”的代码还原操作叫做“撤销” 情况一文件被修改了，但未执行git add操作(working tree内撤销) 12$ git checkout fileName$ git checkout . 情况二同时对多个文件执行了git add操作，但本次只想提交其中一部分文件 1234$ git add *$ git status// 取消暂存$ git reset HEAD &lt;filename&gt; 情况三文件执行了git add操作，但想撤销对其的修改（index内回滚） 1234// 取消暂存$ git reset HEAD fileName// 撤销修改$ git checkout fileName 情况四修改的文件已被git commit，但想再次修改不再产生新的Commit 123// 修改最后一次提交 $ git add sample.txt$ git commit --amend -m&quot;说明&quot; 情况五已在本地进行了多次git commit操作，现在想撤销到其中某次Commit 1$ git reset [--hard|soft|mixed|merge|keep] [commit|HEAD] 场景二 彻底完了，刚线上更新的代码出现问题了，需要还原这次提交的代码！ 已进行git push，即已推送到“远程仓库”中。我们将已被提交到“远程仓库”的代码还原操作叫做“回滚”！注意：对远程仓库做回滚操作是有风险的，需提前做好备份和通知其他团队成员！ 如果你每次更新线上，都会打tag，那恭喜你，你可以很快的处理上述场景二的情况 1$ git checkout &lt;tag&gt; 如果你回到当前HEAD指向 1$ git checkout &lt;branch_name&gt; 情况一撤销指定文件到指定版本 1234// 查看指定文件的历史版本$ git log &lt;filename&gt;// 回滚到指定commitID$ git checkout &lt;commitID&gt; &lt;filename&gt; 情况二删除最后一次远程提交 方式一：使用revert12$ git revert HEAD$ git push origin master 方式二：使用reset 12$ git reset --hard HEAD^$ git push origin master -f 二者区别： revert是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在； reset是指将HEAD指针指到指定提交，历史记录中不会出现放弃的提交记录。 情况三回滚某次提交 123// 找到要回滚的commitID$ git log$ git revert commitID 场景三刚才我发现之前的某次提交太愚蠢了，现在想要干掉它！ 123$ git log// ^号代表目标版本号的前一次提交$ git rebase -i &lt;目标版本号&gt;^ 进入编辑器 将对应版本号前的 pick 改为 d ，即drop = remove commit，然后保存退出 1$ git push origin &lt;分支名&gt; -f 通过上述操作，如果你想对历史多个commit进行处理或者，可以选择git rebase -i，只需删除对应的记录就好 rebase还可对 commit 消息进行编辑，以及合并多个commit]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode：阶乘后的零]]></title>
    <url>%2F2020%2F10%2F16%2F%E7%AE%97%E6%B3%95%2FLeetCode%EF%BC%9A%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[阶乘后的零给定一个整数 n，返回 n! 结果尾数中零的数量。 测试用例121. 3 // 02. 6 // 1 解法一思路 3! = 3 2 1 6! = 6 5 4 3 2 * 1 10! = （5 2） 8 7 6 5 4 3 2 * 1 每一个5都可以找到偶数配对，就相当于一个5可以产生一个0。 找出阶乘中含有多少个因子5就可以了 算法123456789101112131415/** * @param &#123;number&#125; n * @return &#123;number&#125; */var trailingZeroes = function(n) &#123; let count = 0; for(let i = 5; i &lt;= n; i++)&#123; let temp = i; while(temp % 5 === 0) &#123; count ++; temp /= 5 &#125; &#125; return count;&#125;; 解法二思路 5 的因子一定是每隔 5 个数出现一次 25 = 5 5, 125 = 5 5 * 5 每隔 5 个数，出现一个 5，每隔 25 个数，出现 2 个 5，每隔 125 个数，出现 3 个 5… 因此找出现了多少次五个数，当这个次数大于5时，证明n大于25，有多一个5，以此类推，125同理。 count = n / 5 + n / 25 + n / 125 … 算法123456789101112/** * @param &#123;number&#125; n * @return &#123;number&#125; */var trailingZeroes = function(n) &#123; let count = 0; while (n &gt; 0) &#123; n = Math.floor(n / 5); count += n; &#125; return count;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：事件模型]]></title>
    <url>%2F2020%2F09%2F04%2FJS%2FJS%EF%BC%9A%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1&lt;button id=&quot;btn&quot;&gt;click me&lt;/button&gt; DOM0级事件模型DOM0级事件模型是早期的事件模型，所有的浏览器都是支持的，而且其实现也是比较简单。没有事件流的概念。 事件绑定监听函数直接在dom对象上注册事件1&lt;button onclick=&quot;console.log(&apos;DOM0&apos;)&quot;&gt; 123document.getElementById(&apos;btn&apos;).onclick = function()&#123; console.log(&apos;DOM0&apos;);&#125; 事件移除监听函数解除事件是将null复制给事件函数 1document.getElementById(&apos;btn&apos;).onclick = null; 一个dom对象只能注册一个同类型的函数，因为注册多个同类型的函数的话，就会发生覆盖，之前注册的函数就会无效。 IE事件模型事件流： 事件处理阶段：事件到达目标元素，触发目标元素的监听函数。 事件冒泡阶段：事件从目标元素冒泡到document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。 事件绑定监听函数1234// attachEvent(&apos;事件名称&apos;,&apos;事件回调&apos;);document.getElementById(&apos;btn&apos;).attachEvent(&apos;onclick&apos;, function()&#123; console.log(&apos;IE&apos;);&#125;); 事件移除监听函数detachEvent(‘要移除的事件名称’,’要移除的函数’); DOM2级事件模型事件流阶段： 事件捕获阶段：事件从document一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。 处于目标阶段：事件到达目标元素，触发目标元素的监听函数。 事件冒泡阶段：事件从目标元素冒泡到document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。 事件绑定监听函数一个dom对象可以注册多个相同类型的事件，不会发生事件的覆盖，会依次的执行各个事件函数。 DOM2事件函数不会覆盖DOM0事件函数。 12345678//addEventListener(&apos;事件名称&apos;,&apos;事件回调&apos;,&apos;捕获/冒泡&apos;)var click = document.getElementById(&apos;btn&apos;);click.addEventListener(&apos;click&apos;,function()&#123; console.log(&apos;DOM2 捕获&apos;);&#125;,true);click.addEventListener(&apos;click&apos;,function()&#123; console.log(&apos;DOM2 冒泡&apos;);&#125;,false); 第一个参数是事件名称，与DOM0级不同的是没有”on“，另外第三个参数代表是否在捕获阶段进行处理，true代表在捕获阶段进行处理，false代表在冒泡阶段进行处理，默认为false。 事件移除监听函数removeEventListener(‘要移除的事件名称’,’要移除的函数’) 注意当我们移除 child 对象后，此时对于 DOM Tree 来说 child 当然是不存在的了，但是内存中依然有对于它的引用，也就是 child 本身，只不过它没有在 DOM Tree 中而已。因此，clickHandler 也同样驻留在内存中。 123parent.removeChild(child);this.removeEventListener();// child = null; 因此在移除节点时，同时需要移除事件回调，当然了移除事件回调也不一定非要用 removeEventListener，像上例那种情况使用最简单的办法可以 child = null 即可。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：n数之和]]></title>
    <url>%2F2020%2F08%2F10%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9An%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[两数之和为0题目给定一个不重复的数字数组，找出该数组中两个数之和等于0的所有情况。 测试用例121. [1,2,3,-1] // [[1,-1]]2. [1,2,3,-3,-1] // [[1,1],[3,-3]] 解法思路 数组长度少于2则直接返回 取数组首元素，与剩余元素比较是否相加为0，若为0取该值，拼接为数组，否则undefined 递归剩余元素，将得到的返回值拼接，对于undefined的值不拼接 算法123456789101112131415161718192021222324252627/** * @param &#123;array&#125; arr * @return &#123;array&#125; */var addUpToZero = function (arr) &#123; if(arr.length &lt; 2) &#123; return; &#125; var left = arr.splice(0,1)[0]; var right, res; for(let i in arr) &#123; if(left + arr[i] === 0) &#123; right = arr.splice(i,1)[0]; &#125; &#125; if(right) &#123; res = [left, right]; &#125; var next = test(arr); if(res &amp;&amp; next)&#123; return [res].concat(next); &#125; else if (res) &#123; return [res]; &#125; else if (next) &#123; return next; &#125;&#125; 两数之和为target题目给定一个已按照升序排列的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1必须小于index2。 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 测试用例11. [2,7,11,15],9 // [1,2] 解法思路 双指针法，一个指向头，一个指向尾 判断和是否为target，是则返回 否则，若sum小于target，则指向头的指针往前移动；若大于，则尾部移动 算法123456789101112131415161718/** * @param &#123;number[]&#125; numbers * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function(numbers, target) &#123; let i = 0, j = numbers.length -1; while(i &lt; j) &#123; const sum = numbers[i] + numbers[j]; if (sum === target) &#123; return [i + 1, j + 1]; &#125; else if (sum &lt; target) &#123; i++; &#125; else &#123; j--; &#125; &#125;&#125;; n数之和为target题目给定一个无序数组，判断该数组中能否实现n个数之和等于target的情况。 测试用例11. [1,2,3,4],2,7 // true 解法思路算法12345678910111213141516 function getResult(arr,n,target)&#123; if(n==0&amp;&amp;target==0)&#123; return true; &#125; if(n&lt;0)&#123; return false; &#125; if(n&gt;0)&#123; for(var i in arr)&#123; var temp = arr.slice(i+1,arr.length); return getResult(temp,n-1,target-arr[i]) || getResult(temp,n,target); &#125; &#125;&#125;console.log(getResult([1,2,3,4],2,7)); //true]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git：git branch -f]]></title>
    <url>%2F2020%2F08%2F07%2FGit%2FGit%EF%BC%9Agit%20branch%20-f%2F</url>
    <content type="text"><![CDATA[使用相对引用最多的就是移动分支，可以直接使用 -f 选项让分支指向另一个提交 1git branch -f &lt;分支名&gt; &lt;目的位置&gt; 将mater分支指向HEAD的父级提交，即HEAD后退1步后的那次提交12// 需要注意HEAD指向哪里git branch -f master HEAD^ 将mater分支指向HEAD的第3级父提交，即HEAD后退3步后的那次提交1git branch -f master HEAD~3 将mater分支指向代号为c1那次提交，可通过git log查找其哈希值来替换c11git branch -f master c1]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：纯函数]]></title>
    <url>%2F2020%2F08%2F04%2FJS%2FJS%EF%BC%9A%E7%BA%AF%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[纯函数 应始终返回相同的值。 函数的返回结果只依赖于它的参数。 函数执行过程里面没有副作用。 以下例子符合纯函数，不依赖于任何外部输入，不改变任何外部数据、没有副作用。123function getSum (a, b) &#123; return a + b&#125; 应始终返回相同的值不管调用该函数多少次，无论今天、明天还是将来某个时候调用它。 以下是一个随时间或每次调用而变化的函数，为非纯函数1Math.random() // 返回一个随机数 返回结果只依赖其参数纯函数不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。 以下例子为非纯函数，返回值与a相关，无法预料1234var a = 1;function getSum (b) &#123; return a + b&#125; 函数执行过程中没有副作用 函数执行的过程中对外部产生了可观察的变化，我们就说函数产生了副作用。 例如修改外部的变量、调用DOM API修改页面，发送Ajax请求、调用window.reload刷新浏览器甚至是console.log打印数据，都是副作用。 以下例子为非纯函数，修改了外部变量a12345678var a = 1;function getSum (b) &#123; a = 2 return a + b&#125;console.log(a) // 1getSum(2)console.log(a) // 2]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git：删除远程仓库文件但不删除本地]]></title>
    <url>%2F2020%2F07%2F24%2FGit%2FGit%EF%BC%9A%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%96%87%E4%BB%B6%E4%BD%86%E4%B8%8D%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%2F</url>
    <content type="text"><![CDATA[更新 1$ git pull origin master 删除 1$ git rm -r --cached &lt;文件相对路径&gt; 备注 1$ git commit -m &quot;delete&quot; 上传 1$ git push -u origin master]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git：查看克隆下来的代码的信息]]></title>
    <url>%2F2020%2F07%2F24%2FGit%2FGit%EF%BC%9A%E6%9F%A5%E7%9C%8B%E5%85%8B%E9%9A%86%E4%B8%8B%E6%9D%A5%E7%9A%84%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[列出已经存在的远程分支 1$ git remote 列出详细信息，在每一个名字后面列出其远程url地址 1$ git remote -v v: verbose，显示对应的克隆地址。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TS：interface和type]]></title>
    <url>%2F2020%2F07%2F24%2FTS%2FTS%EF%BC%9Ainterface%E5%92%8Ctype%2F</url>
    <content type="text"><![CDATA[参考：【区分】Typescript 中 interface 和 type interface：接口 TypeScript 的核心原则之一是对值所具有的结构进行类型检查。 而接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。 接口就好比一个名字，用来描述值所具有的结构 特性可选属性1234// ? 代表 类型为SquareConfig的值可以不含有color属性interface SquareConfig &#123; color?: string;&#125; 只读属性1234// readonly 代表 x属性只读interface Point &#123; readonly x: number;&#125; 多余属性防止使用不属于接口的属性 1234567891011interface Preson &#123; name: string; age?: number;&#125;let p1:Person = &#123;name: &apos;小明&apos;, age: 18, sex: &apos;男&apos;&#125;; // 报错interface Preson &#123; name: string; age?: number; [propName: string]: any&#125;let p2:Person = &#123;name: &apos;小明&apos;, age: 18, sex: &apos;男&apos;&#125;; 函数类型123interface SearchFunc &#123; (source: string, subString: string): boolean;&#125; 索引类型: 针对数组12345interface StringArray &#123; [index: number]: string;&#125;let myArray: StringArray = [&quot;Bob&quot;, &quot;Fred&quot;]; 类类型 类实现接口 123456789101112interface ClockInterface &#123; currentTime: Date; setTime(d: Date);&#125;class Clock implements ClockInterface &#123; currentTime: Date; setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123; &#125;&#125; 接口继承接口，可多个 12345678910111213141516interface Shape &#123;color: string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface Square extends Shape, PenStroke &#123; sideLength: number;&#125;let square = &lt;Square&gt;&#123;&#125;;square.color = &quot;blue&quot;;square.sideLength = 10;square.penWidth = 5.0; type：类型别名type 会给一个类型起个新名字。 type 有时和 interface 很像，但是可以作用于原始值（基本类型），联合类型，元组以及其它任何你需要手写的类型。 1234567891011type Name = string; // 基本类型type NameResolver = () =&gt; string; // 函数type NameOrResolver = Name | NameResolver; // 联合类型function getName(n: NameOrResolver): Name &#123; if (typeof n === &apos;string&apos;) &#123; return n; &#125; else &#123; return n(); &#125;&#125; 起别名不会新建一个类型，它创建了一个新 名字来引用那个类型。给基本类型起别名通常没什么用，尽管可以做为文档的一种形式使用。 同接口一样，类型别名也可以是泛型， 我们可以添加类型参数并且在别名声明的右侧传入： 1type Container&lt;T&gt; = &#123; value: T &#125;; 也可以使用类型别名来在属性里引用自己： 12345type Tree&lt;T&gt; = &#123; value: T; left: Tree&lt;T&gt;; right: Tree&lt;T&gt;;&#125; 与交叉类型一起使用，我们可以创建出一些十分稀奇古怪的类型。 1234567891011type LinkedList&lt;T&gt; = T &amp; &#123; next: LinkedList&lt;T&gt; &#125;;interface Person &#123; name: string;&#125;var people: LinkedList&lt;Person&gt;;var s = people.name;var s = people.next.name;var s = people.next.next.name;var s = people.next.next.next.name; 然而，类型别名不能出现在声明右侧的任何地方。 1type Yikes = Array&lt;Yikes&gt;; // error interface vs type1. Objects / Functions两者都可以用来描述对象或函数的类型，但是语法不同。 Interface 12345678interface Point &#123; x: number; y: number;&#125;interface SetPoint &#123; (x: number, y: number): void;&#125; Type alias 123456type Point = &#123; x: number; y: number;&#125;;type SetPoint = (x: number, y: number) =&gt; void; 2. Other Types与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组。 12345678910111213141516// primitivetype Name = string;// objecttype PartialPointX = &#123; x: number; &#125;;type PartialPointY = &#123; y: number; &#125;;// uniontype PartialPoint = PartialPointX | PartialPointY;// tupletype Data = [number, string];// domlet div = document.createElement(&apos;div&apos;);type B = typeof div; 3. Extend两者都可以扩展，但是语法又有所不同。此外，请注意接口和类型别名不是互斥的。接口可以扩展类型别名，反之亦然。 Interface extends interface 12interface PartialPointX &#123; x: number; &#125;interface Point extends PartialPointX &#123; y: number; &#125; Type alias extends type alias 12type PartialPointX = &#123; x: number; &#125;;type Point = PartialPointX &amp; &#123; y: number; &#125;; Interface extends type alias 12type PartialPointX = &#123; x: number; &#125;;interface Point extends PartialPointX &#123; y: number; &#125; Type alias extends interface 12interface PartialPointX &#123; x: number; &#125;type Point = PartialPointX &amp; &#123; y: number; &#125;; 4. class Implements类可以以相同的方式实现接口或类型别名。但是请注意，类和接口被认为是静态的。因此，它们不能实现/扩展命名联合类型的类型别名。 123456789101112131415161718192021222324252627interface Point &#123; x: number; y: number;&#125;class SomePoint implements Point &#123; x: 1; y: 2;&#125;type Point2 = &#123; x: number; y: number;&#125;;class SomePoint2 implements Point2 &#123; x: 1; y: 2;&#125;type PartialPoint = &#123; x: number; &#125; | &#123; y: number; &#125;;// FIXME: can not implement a union typeclass SomePartialPoint implements PartialPoint &#123; x: 1; y: 2;&#125; 5. extends class类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。 12345678class Point &#123; x: number; y: number;&#125;interface Point3d extends Point &#123; z: number;&#125; 6. Declaration merging与类型别名不同，接口可以定义多次，并将被视为单个接口(合并所有声明的成员)。 123456// These two declarations become:// interface Point &#123; x: number; y: number; &#125;interface Point &#123; x: number; &#125;interface Point &#123; y: number; &#125;const point: Point = &#123; x: 1, y: 2 &#125;; 7. 计算属性，生成映射类型type 能使用 in 关键字生成映射类型，但 interface 不行。 语法与索引签名的语法类型，内部使用了 for .. in。 具有三个部分： 类型变量 K，它会依次绑定到每个属性。 字符串字面量联合的 Keys，它包含了要迭代的属性名的集合。 属性的结果类型。 123456789101112131415type Keys = &quot;firstname&quot; | &quot;surname&quot;type DudeType = &#123; [key in Keys]: string&#125;const test: DudeType = &#123; firstname: &quot;Pawel&quot;, surname: &quot;Grzybek&quot;&#125;// 报错//interface DudeType2 &#123;// [key in keys]: string//&#125; 8. 其他细节12345678910111213export default interface Config &#123; name: string&#125;// export default type Config1 = &#123;// name: string// &#125;// 会报错type Config2 = &#123; name: string&#125;export default Config2 总结interface 和 type 很像，很多场景，两者都能使用。但也有细微的差别： 类型：对象、函数两者都适用，但是 type 可以用于基础类型、联合类型、元祖。 同名合并：interface 支持，type 不支持。 计算属性：type 支持, interface 不支持。 总的来说，公共的用 interface 实现，不能用 interface 实现的再用 type 实现。主要是一个项目最好保持一致。]]></content>
      <categories>
        <category>TS</category>
      </categories>
      <tags>
        <tag>TS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx：安装]]></title>
    <url>%2F2020%2F07%2F24%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%2FNginx%EF%BC%9A%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[安装工具homebrew 安装nginx 先查找nginx是否已存在 12$ brew search nginx // 查询nginx是否已存在$ brew info nginx // 查看更详细的信息 安装 1$ brew install nginx 查看nginx安装目录 1$ open /usr/local/etc/nginx/ 12// 这才是nginx被安装到的目录$ open /usr/local/Cellar/nginx 打开会看到一个以当前安装的nginx的版本号为名称的文件夹，这个就是我们安装的nginx根目录啦。进入1.12.2_1/bin 目录，会看到nginx的可执行启动文件。 同样的，我们在1.12.2_1/目录下还可以看到一个名字为html的快捷方式文件夹（暂且就这么叫吧），进入该目录我们会发现其实它指向的就是/usr/local/var/www目录，这个在上面我们查看的info信息中有提到（Dcroot） 启动 1$ nginx 访问 打开浏览器访问localhost:8080，即可看到nginx的欢迎界面 关闭和重启 12345678910// 关闭1: 快速停止$ nginx -s stop // 关闭2: 完整有序停止$ nginx -s quit // 重启$ nginx -s reload]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决3000端口被占用问题]]></title>
    <url>%2F2020%2F07%2F24%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%2F%E8%A7%A3%E5%86%B33000%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[打开终端查看被占用端口情况 1$ sudo lsof -i tcp:3000 输入密码后即可查看到详细信息，随后kill占有端口的id 1$ kill &lt;PID&gt; 虽然这不是一个很好的方法，但也能暂时解决问题]]></content>
      <categories>
        <category>服务器端</category>
      </categories>
      <tags>
        <tag>服务器端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Koa：入门]]></title>
    <url>%2F2020%2F07%2F24%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%2FKoa%2FKoa%EF%BC%9A%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[创建koa工程首先，我们创建一个目录hello-koa并作为工程目录。然后，在工程目录下创建app.js并输入以下代码 12345678910111213141516// 导入koa，和koa 1.x不同，在koa2中，我们导入的是一个class，因此用大写的Koa表示:const Koa = require(&apos;koa&apos;);// 创建一个Koa对象表示web app本身:const app = new Koa();// 对于任何请求，app将调用该异步函数处理请求app.use(async (ctx, next) =&gt; &#123; await next(); ctx.response.type = &apos;text/html&apos;; ctx.response.body = &apos;&lt;h1&gt;Hello, koa2!&lt;/h1&gt;&apos;;&#125;);// 在端口3000监听:app.listen(3000);console.log(&apos;app started at port 3000...&apos;); 对于每一个http请求，koa将调用我们传入的异步函数来处理 其中，参数ctx是由koa传入的封装了request和response的变量，我们可以通过它访问request和response next是koa传入的将要处理的下一个异步函数。 上面的异步函数中，我们首先用await next();处理下一个异步函数，然后，设置response的Content-Type和内容。 由async标记的函数称为异步函数，在异步函数中，可以用await调用另一个异步函数，这两个关键字将在ES7中引入。 安装koa在工程目录下创建一个package.json，这个文件描述了我们的hello-koa工程会用到哪些包。 12345678// 命令&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node app.js&quot;&#125;,// 工程依赖的包以及版本号&quot;dependencies&quot;: &#123; &quot;koa&quot;: &quot;2.0.0&quot;&#125; 然后执行命令即可将依赖包安装 1$ npm install 运行执行app.js文件 1234// 直接使用node运行文件$ node app.js// 或者运行命令$ npm start 打开浏览器，输入http://localhost:3000，即可看到效果]]></content>
      <categories>
        <category>Koa</category>
      </categories>
      <tags>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Koa：连接数据库]]></title>
    <url>%2F2020%2F07%2F24%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%2FKoa%2FKoa%EF%BC%9A%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[本地环境 mysql 1234// 开启$ mysql -u root -p// 退出$ exit navicat 连接在package.json中添加依赖项然后安装 1&quot;mysql&quot;: &quot;^2.18.1&quot; 封装mysqlDB123456789101112131415161718192021222324252627282930const mysql = require(&apos;mysql&apos;); //建立连接的方法function __connection()&#123; var connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, //host user : &apos;root&apos;, //数据库用户名 password : &apos;&apos;, //密码 database : &apos;candy-crush&apos; //数据库名 &#125;); connection.connect(); return connection;&#125; exports.query=function(sql,parmas=null)&#123; //1.获取数据库连接对象 var connection=__connection(); return new Promise(function(reject,resolve)&#123; //2执行sql语句 connection.query(sql, parmas, function (error, results, fields) &#123; if (error) throw error; reject(results); &#125;); //3关闭连接 connection.end(); &#125;)&#125; 使用1234567891011121314151617181920212223242526272829303132333435const mysql = require(&apos;mysql&apos;);const DB = require(&apos;./mysqlDB&apos;); // log request URL:app.use(async (ctx, next) =&gt; &#123; console.log(`Process $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;...`); await next();&#125;);// add url-route:router.get(&apos;/api/user_guide&apos;, async (ctx, next) =&gt; &#123; var name = ctx.params.name; const result = await DB.query(&apos;select name, stamp, guided from guide where userID = 99&apos;); //查询数据库 console.log(result); ctx.response.body = &#123; code: 0, msg: &apos;success&apos;, data: &#123; userID: &apos;99&apos;, items: result &#125; &#125;&#125;);router.post(&apos;/api/user_guide&apos;, async (ctx, next) =&gt; &#123; var guideNames = ctx.request.body.guideNames.split(&apos;,&apos;) || []; for (let i in guideNames) &#123; await DB.query(`update guide set guided = true where userID = 99 and name = &apos;$&#123;guideNames[i]&#125;&apos;`) &#125; ctx.response.body = &#123; code: 0, msg: &quot;success&quot;, data: null &#125;;&#125;);]]></content>
      <categories>
        <category>Koa</category>
      </categories>
      <tags>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node：EventEmitter类（事件监听）]]></title>
    <url>%2F2020%2F07%2F24%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%2FNode%2FNode%EF%BC%9AEventEmitter%E7%B1%BB%EF%BC%88%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%EF%BC%89%2F</url>
    <content type="text"><![CDATA[引入Node.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件 1234// 引入 events 模块var events = require(&apos;events&apos;);// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter(); .on12// 绑定事件及事件的处理程序eventEmitter.on(&apos;eventName&apos;, eventHandler); .emit12// 触发事件eventEmitter.emit(&apos;eventName&apos;); .once为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器，也就是说不管某个事件在将来被触发多少次，都只调用一次回调函数。 12eventEmitter.once(&apos;eventName&apos;, eventHandler);//尽管事件会触发多次，但事件处理函数只会执行一次]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Koa：接收请求]]></title>
    <url>%2F2020%2F07%2F21%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%2FKoa%2FKoa%EF%BC%9A%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[路由为了处理URL，我们需要引入koa-router这个middleware，让它负责处理URL映射 先在package.json中添加依赖项然后安装 1&quot;koa-router&quot;: &quot;7.0.0&quot; 修改app.js的代码 1234567891011121314151617181920212223242526272829const Koa = require(&apos;koa&apos;);// 注意require(&apos;koa-router&apos;)返回的是函数// 最后的()是函数调用const router = require(&apos;koa-router&apos;)();const app = new Koa();// log request URL:app.use(async (ctx, next) =&gt; &#123; console.log(`Process $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;...`); await next();&#125;);// add url-route:router.get(&apos;/hello/:name&apos;, async (ctx, next) =&gt; &#123; var name = ctx.params.name; ctx.response.body = `&lt;h1&gt;Hello, $&#123;name&#125;!&lt;/h1&gt;`;&#125;);router.get(&apos;/&apos;, async (ctx, next) =&gt; &#123; ctx.response.body = &apos;&lt;h1&gt;Index&lt;/h1&gt;&apos;;&#125;);// add router middleware:app.use(router.routes());app.listen(3000);console.log(&apos;app started at port 3000...&apos;); 处理get请求使用router.get(‘/path’, async fn)来注册一个GET请求。 可以在请求路径中使用带变量的/hello/:name，变量可以通过ctx.params.name访问 处理post请求处理post请求，可以用router.post(‘/path’, async fn) koa-bodyparserpost请求通常会发送一个表单，或者JSON，它作为request的body发送，但无论是Node.js提供的原始request对象，还是koa提供的request对象，都不提供解析request的body的功能！ 所以，我们又需要引入另一个middleware，koa-bodyparser来解析原始request请求，然后，把解析后的参数，绑定到ctx.request.body中。 在package.json中添加依赖项然后安装 1&quot;koa-bodyparser&quot;: &quot;3.2.0&quot; 修改app.js，引入koa-bodyparser： 1const bodyParser = require(&apos;koa-bodyparser&apos;); 在合适的位置加上（必须在router之前） 1app.use(bodyParser()); 使用1234567891011router.post(&apos;/signin&apos;, async (ctx, next) =&gt; &#123; var name = ctx.request.body.name || &apos;&apos;, password = ctx.request.body.password || &apos;&apos;; console.log(`signin with name: $&#123;name&#125;, password: $&#123;password&#125;`); if (name === &apos;koa&apos; &amp;&amp; password === &apos;12345&apos;) &#123; ctx.response.body = `&lt;h1&gt;Welcome, $&#123;name&#125;!&lt;/h1&gt;`; &#125; else &#123; ctx.response.body = `&lt;h1&gt;Login failed!&lt;/h1&gt; &lt;p&gt;&lt;a href=&quot;/&quot;&gt;Try again&lt;/a&gt;&lt;/p&gt;`; &#125;&#125;); 注意，用var name = ctx.request.body.name || ‘’拿到表单的name字段，如果该字段不存在，默认值设置为’’ 跨域当发送请求时，会出现一个跨域问题，这时候就需要koa2-cors来处理 在package.json中添加依赖项然后安装 1&quot;koa2-cors&quot;: &quot;^2.0.6&quot; 修改app.js 1234var cors = require(&apos;koa-cors&apos;);// 必须放到router前面app.use(cors()); 重构1234567891011121314151617url2-koa/|+- .vscode/| || +- launch.json &lt;-- VSCode 配置文件|+- controllers/| || +- login.js &lt;-- 处理login相关URL| || +- users.js &lt;-- 处理用户管理相关URL|+- app.js &lt;-- 使用koa的js|+- package.json &lt;-- 项目描述文件|+- node_modules/ &lt;-- npm安装的所有依赖包 前端使用 按照惯用的发送请求的方法 url为http://127.0.0.1:3000[请求路径]]]></content>
      <categories>
        <category>Koa</category>
      </categories>
      <tags>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Egret：反向遮罩]]></title>
    <url>%2F2020%2F07%2F17%2FEgret%2FEgret%EF%BC%9A%E5%8F%8D%E5%90%91%E9%81%AE%E7%BD%A9%2F</url>
    <content type="text"><![CDATA[原理 先绘制需要高亮的区域 绘制遮罩 设置高亮区域的blendMode为擦除，此属性确定如何将一个源（新的）图像绘制到目标（已有）的图像上 将遮罩及高亮区域都加入到同一个显示对象中，这样就会在遮罩中擦除出高亮的区域 将显示对象绘制成纹理，再将纹理作为图片加入到显示列表 12345678910111213141516171819202122232425262728const container = new egret.DisplayObjectContainer();// 遮罩const mask = new egret.Shape();mask.graphics.beginFill(0x000000, 0.5);mask.graphics.drawRect(0, 0, width, height);mask.graphics.endFill();const displayArea = new egret.Shape();displayArea.graphics.beginFill(0x00ff00);displayArea.graphics.drawRoundRect(0, 0, width, height, 24, 24)container.addChild(mask);container.addChild(displayArea);displayArea.blendMode = egret.BlendMode.ERASE;const renderTexture: egret.RenderTexture = new egret.RenderTexture();renderTexture.drawToTexture(container);this.bitmap = new egret.Bitmap(renderTexture);this.mainStage.addChild(this.bitmap); this.bitmap.touchEnabled = true; //遮罩允许点击this.bitmap.addEventListener(egret.TouchEvent.TOUCH_TAP, (e) =&gt; &#123; console.log(&apos;点击遮罩后回调&apos;) &#125;, this);//镂空区域不响应点击，这样可以穿透点击到下面的背景this.bitmap.pixelHitTest = true;]]></content>
      <categories>
        <category>Egret</category>
      </categories>
      <tags>
        <tag>Egret</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Egret：资源管理]]></title>
    <url>%2F2020%2F07%2F17%2FEgret%2FEgret%EF%BC%9A%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[ResDepotResDepot主要目的是为了方便大家编辑和创建resource.json文件 打开resource.json文件，将需要添加的资源拖进资源窗口 对资源分组，并将资源窗口中属于该组的资源拖动至该组中 点击保存，或生成即可]]></content>
      <categories>
        <category>Egret</category>
      </categories>
      <tags>
        <tag>Egret</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[whistle：利用whistle mock 数据]]></title>
    <url>%2F2020%2F07%2F17%2F%E5%89%8D%E7%AB%AF%2Fwhistle%EF%BC%9A%E5%88%A9%E7%94%A8whistle%20mock%20%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[vasevase 是 whistle 提供了一个强大的 mock 数据的插件，强大之处是可以结合 js 语句 + mock 语法去生成数据。 安装1$ npm i -g whistle.vase 使用在whistle界面的“Plugins”菜单中可以打开 vase 的界面 mock 语法在vase界面新建配置 “mock_json_demo”，并选择模板为 mock，输入 12345678910// mock 语法&#123; &quot;list|5&quot;: [ &#123; &quot;name&quot;: &quot;@string&quot;, &quot;avatar&quot;: &quot;http://lorempixel.com/100/100/&quot;, &quot;id|+1&quot;: 10000 &#125; ]&#125; 然后在“Rules”中配置一条规则 1http://mock.local/data.json vase://mock_json_demo 打开测试地址 http://mock.local/data.json ，即可看到模拟的数据。 js 语法在vase界面新建配置 “json_engine_script”，并选择模板为 script，输入 1234567891011121314// js 语法var json = merge(&#123; page: req.query.pi, // 取url查询参数的分页字段，加到要返回的数据里，达到模拟分页数据的效果 total: 60&#125;, render(&apos;mock_json_demo&apos;, null, &apos;mock&apos;)); // render 可以渲染上文提到名为“mock_json_demo”的数据模板，返回一个json if (req.query.callback) &#123; // 如果查询参数带了callback，则返回jsonp out(header(&apos;content-type&apos;, &apos;application/javascript; charset=utf8&apos;)); var json_text = join([req.query.callback + &apos;(&apos;, json, &apos;)&apos;]); // join是内置方法，可合并一组数据 out(json_text); // 向body输出数据&#125; else &#123; // 没有callback则返回json out(header(&apos;content-type&apos;, &apos;application/json; charset=utf8&apos;)); out(json);&#125; 然后在“Rules”中配置一条规则 1http://mock.local/data.json vase://json_engine_script 打开 http://mock.local/data.json?callback=cb&amp;pi=1 ，即可看到模拟的数据，可尝试改变、删除 callback、pi 参数，会发现返回的数据会随之改变。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：关于闭包]]></title>
    <url>%2F2020%2F05%2F24%2FJS%2FJS%EF%BC%9A%E5%85%B3%E4%BA%8E%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包对闭包的理解 闭包是有权访问另一个函数作用域中的变量的一个函数。 简单来说就是定义在一个函数内部的函数。 闭包可以访问到父级函数的变量，且该变量不会销毁。 闭包的原理利用了作用域链的特性，我们都知道作用域链就是在当前执行环境下访问某个变量时，如果不存在就一直向外层寻找，最终寻找到最外层也就是全局作用域，这样就形成了一个链条 闭包的体现闭包只能取得包含函数中的任何变量的最后一个值12345678910111213141516function person ()&#123; var age = 18; function cat()&#123; age ++; console.log(age); &#125; console.log(age) return cat;&#125;person() // 18var p = person(); // p相当于函数cat// 调用时会先在cat函数作用域内查找变量age，没有则顺着作用域链往上查找，找到person中的age// 经过首次调用后cat中存在age变量，这样每次调用都不经过age的初始值，就可以一直增加p() // 19，p()即cat()p() // 20person() // 18，每次调用person函数，进入该作用域，age都会重新赋值为18 闭包的作用 隐藏变量，避免全局污染 可以读取函数内部的变量 闭包的缺点 通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在创建了一个闭包以后，这个函数的作用域就会一直保存到闭包不存在为止。 闭包会导致局部变量能在函数作用域之外被访问，但是这不是变量不可被回收的充分条件，通常情况下是考虑局部变量是否被全局或者一个不可被回收的对象引用了。 闭包被引用后始终在内存中，不会在调用结束后被垃圾回收机制回收，可能会造成内存消耗。12// 释放闭包引用p = null; 闭包的应用场景封装变量为避免全局污染，把变量封装到函数作用域中 循环绑定事件处理函数1234567891011121314151617181920var lis = document.getElementsByTagName(&apos;li&apos;)// 每循环一次给lis添加一个function，最后lis是这样的 lis[function()&#123;&#125;,function()&#123;&#125;,function()&#123;&#125;]// 里面有3个function，在for里面声明了function，但还没有立即执行// 真正执行的时候是当点击li的时候才执行这个函数// 当执行的时候for循环已经结束，i已经变成最后一个取值了，所以每触发一次事件都访问的是等于最后一个取值的ifor(var i=0;i&lt;lis.length;i++)&#123; lis[i].onclick = function()&#123; console.log(i); &#125;; &#125;// 立即执行函数要保护j这个索引值的变量不被污染for(var i=0;i&lt;lis.length;i++)&#123; (function(j)&#123; lis[j].onclick = function()&#123; console.log(j); &#125;; &#125;)(i); //事件处理函数中闭包的写法&#125; 循环打印1234567891011// 定时器中的回调函数是一个在立即执行函数中的闭包，单独的立即执行函数能不能叫做闭包说法各有不同。function fn()&#123; for(var i = 1;i &lt;= 5;i ++)&#123; (function(j)&#123; setTimeout(function () &#123; console.log(j) &#125;, 1000) &#125;)(i); &#125;&#125;fn() // 1 2 3 4 5 拓展垃圾回收机制标记清除工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。 工作流程： 垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。 去掉环境中的变量以及被环境中的变量引用的变量的标记。 再被加上标记的会被视为准备删除的变量。 垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。 引用计数工作原理：跟踪记录每个值被引用的次数。 工作流程： 声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。 同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1. 当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1. 当引用次数变成0时，说明没办法访问这个值了。 当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。 引起内存泄漏 全局变量 闭包 原因：都是由于不能被回收]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：__proto__和prototype]]></title>
    <url>%2F2020%2F05%2F14%2FJS%2FJS%EF%BC%9A__proto__%E5%92%8Cprototype%2F</url>
    <content type="text"><![CDATA[__proto__每一个对象都有的属性（在JS里，万物皆对象），指向构造该对象的构造函数的原型。 prototype 每一个方法都有的属性，这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。 原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。 方法也是对象，所以方法既有prototype属性又有proto属性 实例对象的proto和其自身构造函数的prototype都是指向构造函数的原型。 123456789101112131415var A = function()&#123;&#125; //A是一个方法，也是一个对象var a = new A() //a是由A创造出来的一个对象，不是方法//对象console.log(a.__proto__); //Objectconsole.log(a.prototype); //undefined,因为a不是方法，没有该属性//方法，也是对象console.log(A.__proto__); //function () &#123; [native code] &#125;console.log(A.prototype); //Objectconsole.log(a.__proto__==A.prototype); //trueconsole.log(a.prototype==undefined); //trueconsole.log(A.__proto__==Function.prototype); //trueconsole.log(A.prototype==a.__proto__); //true]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：浅拷贝与深拷贝]]></title>
    <url>%2F2020%2F05%2F14%2FJS%2FJS%EF%BC%9A%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[浅拷贝拷贝对象的内存地址，新旧对象共享同一块内存，修改新对象会导致旧对象也改变。 12345678910var obj = &#123; a: &#123;a:&quot;kobe&quot;,b:39&#125; &#125;;var arr = [&quot;a&quot;,&quot;b&quot;,&#123;name:&quot;kobe&quot;&#125;];//第一种var obj1 = obj;//第二种var obj2 = Object.assign(&#123;&#125;,obj);//当object只有一层时为深拷贝//第三种var arr1 = arr.concat();//第四种var arr2 = arr.slice(); 深拷贝创造一个一模一样的对象，，新旧对象不共享同一块内存，修改新对象不会导致旧对象改变。 递归实现深拷贝123456789101112131415161718192021222324252627282930function clone(target) &#123; var temp; if (target instanceof Array) &#123; temp = []; &#125; else if (target instanceof Object) &#123; temp = &#123;&#125;; &#125; else &#123; return target; &#125; for (var i in target) &#123; temp[i] = clone(target[i]); &#125; return temp;&#125;console.log(clone([&quot;111&quot;, &quot;222&quot;, &#123; a: &quot;1&quot; &#125;, [1, 1]]));console.log(clone(&#123; a: [1, 1], b: &#123; a: &quot;1&quot;, b: &quot;11&quot; &#125;, c: &quot;11&quot;&#125;));console.log(clone(&quot;111&quot;)); JSON.parse(JSON.stringify())123function clone(target)&#123; return JSON.parse(JSON.stringify(target));&#125; 原理： 用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。 这种方法虽然可以实现数组或对象深拷贝，但不能处理函数。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：类数组对象]]></title>
    <url>%2F2020%2F05%2F14%2FJS%2FJS%EF%BC%9A%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[类数组对象只包含使用从零开始，且自然递增的整数做键名，并且定义了length表示元素个数的对象。 1234var arr = [1,2,3];var obj = &#123;0: 1, 1: 2, 2: 3, length: 3&#125;;console.log(arr[0], obj[0])//1, 1console.log(arr[&apos;length&apos;], obj[&apos;length&apos;])//3，3 我们可以使用对象来模拟数组，只要我们定义的对象的每个元素的键名都使用数字并且让其保持递增，且动态的定义一个length属性来表示元素个数，那么从效果上来说，基本就和数组相同了。 argumentsarguments就是一个典型的类数组对象，为一个参数集 1234567891011121314151617181920212223242526// 数组function printArr () &#123; return [&apos;ming&apos;,18];&#125;printArr()// 打印结果(2) [&quot;ming&quot;, 18] 0: &quot;ming&quot; 1: 18 length: 2 __proto__: Array(0) // argumentsfunction printArg (name,age) &#123; return arguments;&#125;printArg(&apos;ming&apos;,18)// 打印结果Arguments(2) [&quot;ming&quot;, 18, callee: ƒ, Symbol(Symbol.iterator): ƒ] 0: &quot;ming&quot; 1: 18 callee: ƒ fn(name,age) length: 2 Symbol(Symbol.iterator): ƒ values() __proto__: Object arguments转换为数组1234567function toArr()&#123; var arr = []; for（var i in arguments）&#123; arr.push(arguments[i]); &#125; return arr;&#125; 12345function toArr()&#123; var arr = []; arr = Array.prototype.slice.call(arguments); return arr;&#125;]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全：XSS和CSRF]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%85%B6%E4%BB%96%2F%E5%AE%89%E5%85%A8%EF%BC%9AXSS%E5%92%8CCSRF%2F</url>
    <content type="text"><![CDATA[XSS攻击（跨站脚本攻击）原理恶意攻击者往web页面里插入恶意可执行网页脚本代码，当用户浏览该页面时，嵌入其中web里面的脚本代码会被执行，从而达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。 分类 存储型XSS恶意代码存储在数据库中 反射型XSS恶意代码存储在url中 DOM型XSS取出和执行恶意代码都是浏览器端完成防御开启CSP建立白名单，明确告诉浏览器哪些外部资源可以加载和执行。 设置http header中的Content-Security-Policy 设置meta标签1&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt; 输入输出过滤前端负责，后端也要做相同的过滤检查，因为攻击者完全可以绕过正常的输入流程，直接利用相关接口向服务器发送设置。 转义字符转义输入输出的内容，对于引号、尖括号、斜杠进行转义。 cookieweb应用程序在设置cookie时，将其属性设为HttpOnly，这样设置的cookie，js就无法进行读写，就可以预防XSS攻击窃取用户cookie，保护用户cookie信息。 CSRF攻击（跨站请求伪造）原理攻击者通过一些技术手段欺骗用户的浏览器去訪问一个自己以前认证过的站点并运行一些操作。 利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。可以这么理解：攻击者盗用了你的身份，以你的名义发送恶意请求。 一般发起攻击的是第三方网站。是利用用户的登录凭证，冒用用户信息，不能获取用户的数据。 CSRF攻击是源于WEB的隐式身份验证机制。WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的。 分类 get类型可以将get请求嵌入img标签，打开页面自动发送请求。 post类型可以利用自动提交的form表单，访问页面就会自动提交。 链接型需要用户点击链接才会触发。防御post尽量使用post请求，避免get请求。 cookie对cookie设置SameSite属性。该属性表示cookie不随跨域请求发送，可以很大程度减少csrf攻击。 token 用户访问某个表单页面。 服务端生成一个Token，放在用户的Session或者浏览器的Cookie中。 在页面表单附带上Token参数。 用户发送请求时以参数的形式带上本次页面中生成的token，服务端验证表单中的Token是否与用户Session（或Cookies）中的Token一致，一致为合法请求，不是则非法请求。 仅仅用来防御csrf攻击，当加上xss攻击时，无用 验证码xss和csrf 通常来说csrf是由xss引起的 xss是代码注入问题，csrf是http问题 同源策略同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。所以a.com下的js脚本采用ajax读取b.com里面的文件数据是会报错的。 不受同源策略限制的： 页面中的链接，重定向以及表单提交是不会受到同源策略限制的。 跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的script标签的src属性、img标签、link标签、iframe标签等。 通过标签的方式发起的请求不受同源策略的限制。且发送请求时浏览器会携带对应的cookie。 SQL注入原理通过传入一些特殊字符，从而达到欺骗服务器执行恶意的SQL命令的目的。 如输入特殊的用户名 123456//理想中的输入：admin passwordSELECT * FROM user WHERE username=&apos;admin&apos; AND psw=&apos;password&apos;//特殊用户名：admin&apos; --SELECT * FROM user WHERE username=&apos;admin&apos; --&apos; AND psw=&apos;xxxx&apos;//在SQL中，--是注释后面的内容的意思 防御 严格限制web应用的数据库的操作权限。 后端代码检查输入的数据是否符合预期。 对特殊字符进行转义处理。]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全：cookie和session]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%85%B6%E4%BB%96%2F%E5%AE%89%E5%85%A8%EF%BC%9Acookie%E5%92%8Csession%2F</url>
    <content type="text"><![CDATA[前言 会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。 Cookie通过在客户端记录信息确定用户身份。 Session通过在服务器端记录信息确定用户身份。 cookie在程序中，会话跟踪是很重要的事情。理论上，一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。 Web应用程序是使用HTTP协议传输数据的。==HTTP协议是无状态的协议==。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。 什么是cookiecookie其实是存储在浏览器中的纯文本，是服务器发送出来存储在浏览器上的一组组键值对，浏览器的安装目录下会专门有一个cookie文件夹来存放各个域下设置的cookie。 cookie怎么工作 存储cookie是浏览器提供的功能。 若客户端首次请求服务器，浏览器会添加请求头中的 cookie字段为{}，把请求的网址连同该Cookie一同提交给服务器。如果服务器需要记录该用户状态，就向客户端浏览器返回Cookie，客户端浏览器会把Cookie保存起来。 当网页要再次发http请求时，浏览器会先检查是否有相应的 cookie，有则自动把所有这个服务器Cookie添加在 request header中的 cookie字段中，把请求的网址连同该Cookie一同提交给服务器。这些是浏览器自动帮我们做的，而且每一次 http请求浏览器都会自动帮我们做。 服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容 cookie的存放有大小限制，不可以超过4kb, 每一个域名下的cookie数量最多是20个 获取cookiedocument.cookie，只能获取非HttpOnly类型的cookie。 打印出的结果是一个字符串类型，因为 cookie本身就是存储在浏览器中的字符串。但这个字符串是有格式的，由键值对 key=value构成，键值对之间由一个 分号和一个 空格隔开。 1key=value; key=value Cookie的不可跨域名性受同源策略限制，跨域的ajax请求默认不携带cookie，那为什么还会有csrf攻击呢？ 12由于script、img、iframe的src都不受同源策略影响，可以利用此来实现跨域请求，来实施攻击。浏览器会依据加载的域名附带上对应域名的cookie 例如，a.com是一个银行网站，用户在此网站登录且生成了授权的cookie，此时浏览器保存了这个cookie。随后访问 b.com，在这个网站中伪造一个请求a网站的请求，如转账、删除操作等，利用script、img、iframe来加载a网站的地址，浏览器就会携带上a网站此登陆用户的授权cookie信息，这样就构成了csrf攻击。 cookie的属性 属性名 数据类型 描述 name String 该Cookie的名称。Cookie一旦创建，名称便不可更改 value Object 该Cookie的值。如果值为Unicode字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码 maxAge int 该Cookie失效的时间，单位秒。如果为正数，则该Cookie在maxAge秒之后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。如果为0，表示删除该Cookie。默认为–1 secure boolean 该Cookie是否仅被使用安全协议传输。安全协议。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false path String 该Cookie的使用路径。如果设置为“/sessionWeb/”，则只有contextPath为“/sessionWeb”的程序可以访问该Cookie。如果设置为“/”，则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为“/” domain String 可以访问该Cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.” comment String 该Cookie的用处说明。浏览器显示Cookie信息的时候显示该说明 version int 该Cookie使用的版本号。0表示遵循Netscape的Cookie规范，1表示遵循W3C的RFC 2109规范 cookie的修改和删除 服务器可以对cookie进行操作，浏览器只能对非HttpOnly类型的cookie进行操作（为了预防xss攻击）。 Cookie并不提供修改、删除操作。 如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。 如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。注意是0而不是负数。负数代表其他的意义。 注意：修改、删除Cookie时，新建的Cookie除value、maxAge之外的所有属性，例如name、path、domain等，都要与原Cookie完全一样。否则，浏览器将视为两个不同的Cookie不予覆盖，导致修改、删除失败。 session除了使用Cookie，Web应用程序中还经常使用Session来记录客户端状态。Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。 session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。 什么是session 客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。 客户端浏览器再次访问时只需要从该session中查找该客户的状态就可以了。 session对象是在客户端第一次请求服务器的时候创建的。session也是一种key-value的属性对 如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。 session的生命周期session保存在服务器端。为了获得更高的存取速度，服务器一般把session放在内存里。每个用户都会有一个独立的session。如果session内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。因此，session里的信息应该尽量精简。 session在用户第一次访问服务器的时候自动创建。需要注意只有访问JSP、Servlet等程序时才会创建session，只访问HTML、IMAGE等静态资源并不会创建session。如果尚未生成session，也可以使用request.getSession(true)强制生成session。 session生成后，只要用户继续访问，服务器就会更新session的最后访问时间，并维护该session。用户每访问服务器一次，无论是否读写session，服务器都认为该用户的Session“活跃（active）”了一次。 为防止内存溢出，服务器会把长时间内没有活跃的session从内存删除。这个时间就是session的超时时间。如果超过了超时时间没访问过服务器，session就自动失效了。tomcat默认失效时间为20分钟。 session对浏览器的要求虽然session保存在服务器，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为session需要使用Cookie作为识别标志。HTTP协议是无状态的，session不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为JSESSIONID的Cookie，它的值为该session的id（也就是HttpSession.getId()的返回值）。session依据该Cookie来识别是否为同一用户。 如果客户端浏览器将Cookie功能禁用，或者不支持Cookie怎么办？例如，绝大多数的手机浏览器都不支持Cookie。Java Web提供了另一种解决方案：URL地址重写。 URL地址重写URL地址重写是对客户端不支持Cookie的解决方案。URL地址重写的原理是将该用户session的id信息重写到URL地址中。服务器能够解析重写后的URL获取session的id。这样即使客户端不支持Cookie，也可以使用session来记录用户状态。 两者区别 cookie数据存放在客户的浏览器上，session数据放在服务器上的，但名为JSESSIONID的Cookie（值为该Session的id）是放在客户端的。 cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。 设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话。 session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。(Session对象没有对存储的数据量的限制，其中可以保存更为复杂的数据类型) 两者最大的区别在于生存周期，session是IE启动到IE关闭.(浏览器页面一关 ,session就消失了)，cookie是预先设置的生存周期，或永久的保存于本地的文件。]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web页面性能优化]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%89%8D%E7%AB%AF%2Fweb%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[请求和响应减少http请求。一个完整的请求都需要经过 DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个 “漫长” 而复杂的过程。资源上由于每个请求都需要携带数据，因此每个请求都需要占用带宽。 使用CDN加速（缓存）。CDN（内容发布网络）是一组分布在多个不同地理位置的Web服务器，用于更加有效地向用户发布内容。其本质上是一个缓存，而且将数据（js、css、image等静态资源）缓存在离用户最近的地方，使用户以最快速度获取数据，即所谓网络访问第一跳。 使用内容传递网络(CDN)提供 JavaScript 文件,CDN 不仅可以提高性能,它还可以为你管理压缩和缓存。 当用户发起访问时，他的访问请求被只能dns定位到最近的缓存服务器，当服务器中没有缓存时，就会去请求最近的服务器中的资源。 利用浏览器缓存通过设置 HTTP 响应报文头使 JavaScript 文件可缓存,将网络资源存储到本地，下次请求资源时，如果命中可直接在本地获取，不需要重新向服务器请求资源 避免重定向。当页面发生了重定向，就会延迟整个HTML文档的传输。在HTML文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载。 重定向和404将浪费加载请求。 HTML合理使用内联。脚本和样式，应按需选择内联或者外链。对于访问少、样式和脚本复用少的页面，可以考虑使用内联样式从而减少 HTTP 请求。 但如果页面访问频繁，样式脚本在多个页面经常复用，使用外链则是最优选择。 这样浏览器可以缓存它们，下次加载时可以直接从缓存加载。 减少dom过多的DOM元素会影响渲染、加载、执行。除了精简页面结构外，还可以适时删除不必要的DOM元素（页面内已经不会再访问的元素），又或者可以懒加载（不一定会使用到的元素，如登录框）。 优化dom操作 使用事件委托来减少事件处理器的数量 减少重绘和回流 如果需要在 DOM操作时添加样式，尽量使用 增加 class 属性，而不是通过 style 一个一个地操作样式。 删除HTML的默认属性。js优化js。 将所有script标签放置在页面的底部,紧靠 body 关闭标签的上方。因为页面解析生成dom树时遇到script标签会停下去加载执行js。此法可以保证页面在脚本运行之前完成解析。 将脚本成组打包。页面的标签越少,页面的加载速度就越快,响应也更加迅速。不论外部脚本 文件还是内联代码都是如此。 由于浏览器渲染机制的设置，gui渲染线程和js引擎互斥，因此js的执行会阻塞dom的解析和渲染以及其他资源的加载。 css将样式表放在头部。css在head中通过link引入下载会阻塞页面的渲染，页面的渲染会等待css解析完生成cssom树，再结合dom树生成渲染树进行渲染。所以最好的做法是把css放在页面的最上面，让浏览器尽快下载css，减少首屏加载时间，避免白屏。 为了浏览器的渲染，能让页面显示的时候视觉上更好。避免某些情况，如：假设你放在页面最底部，则不会阻塞，用户打开页面时，有可能出现，页面先是显示一大堆文字或图片，自上而下，丝毫没有排版和样式可言。最后，页面又恢复所要的效果 由于gui渲染机制和js引擎互斥，因此css加载会阻塞js的加载，但是cssom和dom是并行的，css加载并不阻塞dom的解析，也不阻塞其他资源的加载，但两者需要互相配合生成渲染树，因此会阻塞dom的渲染。 优化css，避免css表达式。会导致效率低下。 资源延迟加载图片。不直接给src路径，而是在页面加载完成后用js操作src，减少了页面加载图片的时间。 懒加载在进入可视区域之后在进行请求资源 预加载在静态资源使用前先加载，在使用时可直接在缓存中获取]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器本地缓存]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%89%8D%E7%AB%AF%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[定义缓存是性能优化中简单高效的一种优化方式。 和本地存储不一样，浏览器缓存是浏览器请求网站留下的资源副本。 好处 减少带宽消耗 提升性能 缓解服务器压力 缓存位置 Service Worker Memory Cache Disk Cache Push Cache 缓存策略浏览器第一次向服务器发起请求拿到请求结果后，根据请求资源时返回的响应头来确定该不该缓存。 浏览器常见字段 Expires：告知客户端资源缓存失效的绝对时间。 Cache-Control：告知客户端或服务器如何处理缓存 max-age=xxx：表示缓存内容将在缓存时间的xxx秒后失效 no-cache：表示可以缓存，但每次用都要去向服务器验证缓存是否可用。 no-store：表示所有内容都不会缓存。 private：客户端可以缓存。 public：客户端和代理服务器都可以缓存。默认值。 Last-Modified：资源最后一次修改时间。 Etag：文件的特殊标识。用于文件内容对比，判断内容是否修改。 Cache-Control优先级高于Expires。 Etag优先级高于Last-Modified。 强缓存 根据本地缓存资源的header中的Expires和Cache-Control来判断是否命中强缓存。 如果命中强缓存则返回缓存的数据。 如果没有命中则进入协商缓存。 协商缓存 如果没有命中强缓存，浏览器会将本地缓存资源的header中的Last-Modified和Etag的值分别放入请求头的IF-Modified-Since和IF-None-Match字段中，向服务器发送请求，由服务器根据请求中的相关header信息来对比结果是否命中协商缓存。 若命中即资源未更新，则服务器返回新的响应header信息且返回的http状态为304，但是并不返回资源内容，它会显示一个Not Modified的字符串，来告知浏览器使用缓存。 否则返回最新的数据，并将新数据存入缓存。 总结当浏览器再次访问一个已经访问过的资源时，会 先判断是否存在缓存，再看是否命中强缓存，如果命中，就直接使用缓存了。 如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存。 如果命中协商缓存，服务器会返回 304。 告诉浏览器使用本地缓存。 否则，返回最新的资源。 拓展ctrl+F5和F5的区别F5只是刷新本地缓存，强缓存无效，协商缓存有效；ctrl+F5是强缓存与协商缓存均无效，重新向服务器请求。 禁止浏览器缓存方法 设置响应头 12//把Cache-Control设置为no-cache&lt;meta HTTP-EQUIV=&quot;Cache-Control&quot; CONTENT=&quot;no-cache&quot;&gt; 在访问的url后添加一个参数，可以是随机数或者时间戳。这样url时刻在变化，就要重新发送http请求]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器渲染机制]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%89%8D%E7%AB%AF%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[进程和线程 进程时cpu资源分配的最小单位，是能拥有资源和独立运行的最小的单位。 线程是cpu调度的最小单位，是建立在进程基础上的一次程序运行单位。 对于操作系统来说，一个任务就是一个进程，一个进程至少有一个线程 浏览器的多进程架构 主进程负责浏览器界面的显示与交互。各个页面的管理,创建和销毁其他进程。网络的资源管理、下载等。 第三方插件进程每种类型的插件对应一个进程,仅当使用该插件时才创建。 GPU 进程最多只有一个,用于 3D 绘制等 渲染进程称为浏览器渲染进程或浏览器内核,内部是多线程的。主要负责页面渲染,脚本执行,事件处理等。 渲染进程浏览器的渲染进程是多线程的 GUI 渲染线程 负责渲染浏览器界面，解析 HTML、CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。 注意，==GUI 渲染线程与 JS 引擎线程是互斥的==，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。 JS 引擎线程 Javascript 引擎，也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎） JS 引擎线程负责解析 Javascript 脚本，运行代码。 JS 引擎一直等待着任务队列中任务的到来,然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序。 注意，==GUI 渲染线程与 JS 引擎线程是互斥的==，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。 事件触发线程 归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解,JS 引擎自己都忙不过来，需要浏览器另开线程协助） 当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程，如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理 注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行） 定时触发器线程 传说中的 setInterval 与 setTimeout 所在线程 浏览器定时计数器并不是由 JavaScript 引擎计数的，（因为 JavaScript 引擎是单线程的， 如果处于阻塞线程状态就会影响记计时的准确） 因此通过单独线程来计时并触发定时（计时完毕后,添加到事件队列中，等待 JS 引擎空闲后执行） 注意，W3C 在 HTML 标准中规定,规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。 异步 http 请求线程 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求。 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。 题目1. 为什么 Javascript 要是单线程的 ? 如果 JavaScript 是多线程的方式来操作这些 UI DOM,则可能出现 UI 操作的冲突。 如果 Javascript 是多线程的话,在多线程的交互下,处于 UI 中的 DOM 节点就可能成为一个临界资源, 假设存在两个线程同时操作一个 DOM,一个负责修改一个负责删除,那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。 当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性,Javascript 在最初就选择了单线程执行。 2. 为什么 JS 阻塞页面加载 ? 由于 JavaScript 是可操纵 DOM 的,如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了。 因此为了防止渲染出现不可预期的结果,浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系。 3. css 加载会造成阻塞吗 ？ CSS 加载不会阻塞 DOM 的解析，会阻塞 Dom 的渲染 DOM 和 CSSOM 通常是并行构建的,所以 CSS 加载不会阻塞 DOM 的解析。 然而,由于 渲染树 是依赖于 DOM树 和 CSSOM树 的,所以他必须等待到 CSSOM树 构建完成,也就是 CSS 资源加载完成(或者 CSS 资源加载失败)后,才能开始渲染。因此,CSS 加载会阻塞 Dom 的渲染。 css 会阻塞后面 js 的执行。 由于 GUI 渲染线程与 JavaScript 引擎为互斥的关系。因此,样式表会在后面的 js 执行前先加载执行完毕,所以css 会阻塞后面 js 的执行。 4. DOMContentLoaded 与 load 的区别 ? 当 DOMContentLoaded 事件触发时,仅当 DOM 解析完成后,不包括样式表,图片。 当文档中没有脚本时,浏览器解析完文档便能触发 DOMContentLoaded 事件。如果文档中包含脚本,则脚本会阻塞文档的解析,而脚本需要等 CSSOM 构建完成才能执行。在任何情况下,DOMContentLoaded 的触发不需要等待图片等其他资源加载完成。 当 onload 事件触发时,页面上所有的 DOM,样式表,脚本,图片等资源已经加载完毕。 DOMContentLoaded -&gt; load 5. defer 和 async 的区别 ? 没有 defer 或 async,浏览器会立即加载并执行指定的脚本,“立即”指的是在渲染该 script 标签之下的文档元素之前,也就是说不等待后续载入的文档元素,读到就加载并执行。 有 async,加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。 有 defer,加载后续文档元素的过程将和 script.js 的加载并行进行（异步）,但是 script.js 的执行要在所有元素解析完成之后,DOMContentLoaded 事件触发之前完成。 总结 defer 和 async 在网络读取（下载）这块儿是一样的,都是异步的（相较于 HTML 解析），差别在于脚本下载完之后何时执行,显然 defer 是最接近我们对于应用脚本加载和执行的要求的 关于 defer，它是按照加载顺序执行脚本的；async 则是乱序执行的，反正对它来说脚本的加载和执行是紧紧挨着的,所以不管你声明的顺序如何,只要它加载完了就会立刻执行 仔细想想,async 对于应用脚本的用处不大,因为它完全不考虑依赖（哪怕是最低级的顺序执行）,不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网：http和https]]></title>
    <url>%2F2020%2F05%2F14%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9Ahttp%E5%92%8Chttps%2F</url>
    <content type="text"><![CDATA[关于https用处： 建立一个信息安全通道，来保证数据传输的安全。 确认网站的真实性，防止钓鱼网站。 https就是在http下加入了ssl层，从而保护了交换数据隐私和完整性，提供了对网站服务器身份认证的功能，简单来说就是安全版的http。 http和https的区别 同属于应用层的协议 http协议是运行在tcp之上的，所有传输的内容都是未加密的，也就是明文的。https协议是运行在SSL\TLS之上的，而SSL\TLS协议运行在tcp之上，在http和tcp之间，所有传输的内容都经过加密的，比http更安全。（加密采用对称加密，而密钥的传输利用非对称加密） http默认使用端口80。https默认使用端口443。 https的工作原理 使用HTTPS的url访问服务器，客户端向服务器端请求建立SSL连接。（可以说TLS为SSL的新版本） 服务器收到客户端请求后，会将网站的证书信息（证书包含公钥）传送一份给客户端。 客户端浏览器和服务器端协商信息加密的等级。 客户端浏览器根据协商好的安全等级，建立会话密钥，然后利用网站的公钥加密会话密钥，并传送给服务器。 服务器利用私钥解密会话密钥，并利用会话密钥加密与客户端之间的通信。 非对称密码解密速度比较慢，但比较安全；对称密码解密速度比较快。所以用对称密码加密数据，非对称密码加密对称密钥。 非对称加密算法中私钥是基于不同的算法生成不同的随机数，私钥通过一定的加密算法推导出公钥，但私钥到公钥的推导过程是单向的，也就是说公钥无法反推导出私钥。]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网：TCP]]></title>
    <url>%2F2020%2F05%2F14%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9ATCP%2F</url>
    <content type="text"><![CDATA[TCP和UDP 都是运输层协议 tcp有连接，可靠：数据包校验、对失序数据包重排序、丢弃重复数据、应答机制、超时重传、流量控制。 udp无连接，快。只是传输数据，不管服务器是否收到。 TCP拥塞控制防止过多数据注入到网络中，这样可以使网络中的路由器或链路不致过载。 慢开始 把初始拥塞窗口cwnd设置为1或2个发送方的最大报文段（SMSS），由小到大逐渐增大发送窗口。每经过一个传输轮次，cwnd加倍。 把拥塞窗口允许发送的报文段都连续发送出去，收到对已发送的最后一个字节的确认，为一个传输轮次，时间为一个往返时间。 拥塞避免 让拥塞窗口缓慢增大，没经过一个往返时间RTT就加1 快重传 让发送方尽早知道发生了个别报文段丢失 快恢复 发送方知道丢失报文段，则不启动慢开始，用快恢复，调整门限值cwnd/2. TCP建立连接——三次握手 客户端发送连接请求报文，将SYN位置设为1 服务器端收到报文后回复ACK+SYN报文。 客户端接收到报文后也向服务器端发送ACK报文，这个报文发送完毕后，完成了三次握手。 通过三次握手确认双方收发功能都正常，四次也可以但是显得比较多余。 TCP释放连接——四次挥手（断开连接） 客户端向服务器传送断开的请求包。客户端进入FIN_WAIT_1状态。 服务器端确定收到断开的请求，回复ACK报文。客户端进入FIN_WAIT_2状态。 服务器端向客户端FIN报文，请求关闭连接。服务器端进入LAST_ACK状态。 客户端收到FIN报文后，回复ACK报文。客户端进入TIME_WAIT状态。服务器端收到ACK报文就会关闭连接（不然一直处于LAST_ACK状态），客户端没有收到服务器端的回复，证明服务器端已关闭连接，客户端也可以关闭连接了。]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6：箭头函数]]></title>
    <url>%2F2020%2F03%2F17%2FES6%2FES6%EF%BC%9A%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[箭头函数体内的this对象是定义时所在的对象，而不是使用时所在的对象。 this指向调用箭头函数外层函数的对象（即箭头函数所在作用域的父级作用域），没有外层函数则指向window。 箭头函数相当于匿名函数。 箭头函数不可以当作构造函数，即不可以用new命令。 箭头函数不可以使用arguments对象，该对象在函数体内不存在。要用，就用rest参数代替。 箭头函数的this指向其上下文的this，通过call、apply也无法修改其指向。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git：Git使用]]></title>
    <url>%2F2020%2F03%2F17%2FGit%2FGit%EF%BC%9AGit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[git的简介、安装就不罗嗦了，详细的教程可参考廖雪峰的git教程 创建版本库（初始化一个git仓库）第一步选择一个合适的地方，创建一个空目录learngit 123$ mkdir learngit$ cd learngit$ pwd pwd命令用于显示当前目录 第二步通过git init命令把这个目录变成Git可以管理的仓库 1$ git init 1、此时可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 2、如果没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 添加文件到Git仓库编写一个readme.txt文件内容为： 12Git is a version control system.Git is free software. 第一步用命令git add告诉Git，把文件添加到仓库 1$ git add readme.txt 1、执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功 2、add可反复多次使用，添加多个文件 第二步用命令git commit告诉Git，把文件提交到仓库 1$ git commit -m &quot;wrote a readme file&quot; 1、-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的 2、commit可以一次提交很多文件，所以你可以多次add不同的文件 修改文件并提交修改readme.txt文件，改成如下内容 12Git is a distributed version control system.Git is free software. git status运行git status命令看看结果 1$ git status git status命令可以让我们时刻掌握仓库当前的状态 git diff比如有一个项目，隔了好几天没碰过了，想要继续写的时候，又忘了上次是怎么修改的，那么运行git diff命令看看具体修改了什么内容 1$ git diff readme.txt git diff顾名思义就是查看difference 提交修改（与提交新文件一样）第一步git add 1$ git add readme.txt 第二步git commit 1$ git commit -m &quot;add distributed&quot; 版本回退现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了 版本一：wrote a readme file 12Git is a version control system.Git is free software. 版本二：add distributed 12Git is a distributed version control system.Git is free software. git log运行git log命令可以查看每次修改的历史记录 1$ git log 该命令显示从最近到最远的提交日志 回退git reset运行git reset命令把版本二回退到版本一 123$ git reset --hard HEAD //当前版本$ git reset --hard HEAD^ //回退到上一个版本$ git reset --hard HEAD^^ //回退到上上一个版本 若有多个版本，可继续使用git reset命令回退 cat 看看readme.txt的内容是不是版本一 1$ cat readme.txt 后悔回退，恢复版本此时，使用git log看一下版本库里的版本，哎呀，版本二不见了那如果此时我又后悔了，我想要回退之前的版本了 1$ git reset --hard 所需版本的commit id commit id不知道怎么办？？？1、不怕，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到回退前执行git log后的版本库，每一个版本的commit后那一长串乱码一样的东西就是该版本的commit id了当然，commit id很长，没必要写全，写前几位就好了（一般七位吧） 恢复版本二 1$ git reset --hard f3ab58 2、可是，当你关掉了命令行窗口后才后悔怎么办？？？不怕，在Git中，总是有后悔药可以吃的 Git提供了一个命令git reflog用来记录你的每一次命令 1$ git reflog 又可以找回所需版本的commit id了 工作区与暂存区工作区就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区 版本库工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库 Git的版本库里存了很多东西1、最重要的就是称为stage（或者叫index）的暂存区2、还有Git为我们自动创建的第一个分支master3、以及指向master的一个指针叫HEAD 前面讲了提交新文件到Git版本库： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支 撤销修改git checkout – file场景一（仅修改了文件） 有一次头脑混乱，在readme.txt中加了一行乱码，死定了，要赶紧手动删掉，以为这样就没事了吗？不，事儿可大了，运行git status查看 1$ git status 会显示改动了readme.txt 这时候，运行git checkout – file丢弃工作区的修改即可 1$ git checkout -- readme.txt 有两种情况（都是修改了工作区的文件导致工作区与版本库不一致）： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态 git reset HEAD file场景二（修改文件后，git add到暂存区了） 有一次头脑更混乱，不仅在readme.txt中加了一行乱码，还git add到暂存区了 幸好，用git status查看 1$ git status 显示还没有提交 这时候运行命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区即可 1$ git reset HEAD readme.txt 再用git status查看 1$ git status 现在暂存区是干净的，工作区有修改，回到场景一即可 1$ git checkout -- readme.txt 版本回退场景三（改了文件，不仅添加了，还提交了） 回到上上一个内容版本回退了 删除文件一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了 1$ rm test.txt Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了 1$ git status 此时有两种情况 第一种情况确实要从版本库中删除该文件 运行命令git rm删掉 1$ git rm test.txt 并且git commit 1$ git commit -m &quot;remove test.txt&quot; 第二种情况删错了 因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本 1$ git checkout -- test.txt git checkout – file 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原” 远程仓库git的杀手级功能—远程仓库这个世界上有个叫GitHub的神奇的网站，这个网站是提供Git仓库托管服务的，只要注册一个GitHub账号，就可以免费获得Git远程仓库 设置SSH Key由于本地Git仓库和GitHub仓库之间的传输是通过SSH加密的 第一步创建SSH Key 在用户主目录下，看看有没有.ssh目录；如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件；如果已经有了，可直接跳到下一步 如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码 第二步登陆GitHub，打开“Account settings”，“SSH Keys”页面， 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容 把本地项目添加到远程库第一步通过命令git init把项目文件夹变成Git可管理的仓库 1$ git init 第二步把项目粘贴到这个本地Git仓库里面 1$ git add . 第三步把项目提交到仓库 1$ git commit -m &quot;注释&quot; 第四步登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库，在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库 目前，在GitHub上的这个learngit仓库还是空的 第五步在本地的learngit仓库下运行命令 1$ git remote add origin git@github.com:michaelliao/learngit.git michaelliao替换成自己的GitHub账户名使本地仓库关联远程库添加后，远程库的名字就是origin，这是Git默认的叫法 第六步把本地库的所有内容推送到远程库上 1$ git push -u origin master 最后的最后从现在起，只要本地作了提交，就可以运行命令把本地master分支的最新修改推送至GitHub 1$ git push origin master 从远程库克隆到本地库第一步登陆GitHub，创建一个新的仓库，名字叫gitskills勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件 第二步用命令git clone克隆一个本地库 1$ git clone git@github.com:michaelliao/gitskills.git michaelliao替换成自己的GitHub账户名 分支管理创建与合并分支一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长 第一步创建dev分支 1$ git branch dev 切换到dev分支 1$ git checkout dev 可合并为创建并切换到dev分支 1$ git checkout -b dev 第二步用git branch命令查看当前分支 123$ git branch* dev master git branch命令会列出所有分支，当前分支前面会标一个*号 第三步在dev分支上正常提交比如对readme.txt做个修改，加上一行 1Creating a new branch is quick. 然后提交 12$ git add readme.txt $ git commit -m &quot;branch test&quot; 第四步现在，dev分支的工作完成，我们就可以切换回master分支 1$ git checkout master 切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变 第五步把dev分支的工作成果合并到master分支上 1$ git merge dev git merge命令用于合并指定分支到当前分支注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式 第六步合并完成后，就可以放心地删除dev分支了 1$ git branch -d dev 删除后，查看branch，就只剩下master分支了 12$ git branch* master 解决冲突第一步此时，创建了一个新的分支feature1 1$ git checkout -b feature1 在readme.txt最后添加一行并提交 1Creating a new branch is quick AND simple. 第二步切换到master分支 1$ git checkout master 在master分支上readme.txt最后添加一行并提交 1Creating a new branch is quick &amp; simple. 此时，master分支和feature1分支各自都分别有新的提交 第三步由于两个分支各自有修改，两者合并起来可能会有冲突 1$ git merge feature1 git status会告诉我们冲突的文件 1$ git status 也可以查看readme.txt的内容 1234567Git is a distributed version control system.Git is free software distributed under the GPL.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 第四步此时，需要手动修改冲突内容 123Git is a distributed version control system.Git is free software distributed under the GPL.Creating a new branch is quick and simple. 再提交 12$ git add readme.txt $ git commit -m &quot;conflict fixed&quot; 现在，master分支和feature1分支变成这样用带参数的git log也可以看到分支的合并情况 1$ git log --graph --pretty=oneline --abbrev-commit 第五步最后，删除feature1分支 1$ git branch -d feature1 分支管理策略通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息 第一步创建并切换dev分支 1$ git checkout -b dev 第二步修改readme.txt文件，并提交一个新的commit 12$ git add readme.txt $ git commit -m &quot;add merge&quot; 第三步切换回master 1$ git checkout master 第四步准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward 1$ git merge --no-ff -m &quot;merge with no-ff&quot; dev 加上-m参数，把commit描述写进去 合并后，我们用git log看看分支历史 1$ git log --graph --pretty=oneline --abbrev-commit Bug分支某天突然接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但当前正在dev上进行的工作还没有提交，并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug 第一步把当前工作现场“储藏”起来，等以后恢复现场后继续工作 1$ git stash 现在，用git status查看工作区，就是干净的 第二步首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支 1$ git checkout master 1$ git checkout -b issue-101 第三步修复bug，然后提交 12$ git add readme.txt $ git commit -m &quot;fix bug 101&quot; 第四步修复完成后，切换到master分支，并完成合并，最后删除issue-101分支 1$ git checkout master 1$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101 1$ git branch -d issue-101 第五步接着回到dev分支干活了 1$ git checkout dev 1$ git status 工作区是干净的，用git stash list命令看看刚才的工作现场存到哪去了？ 1$ git stash list 第六步恢复stash内容 一种是用git stash apply恢复，然后用git stash drop删除stash内容 另一种方式是用git stash pop，恢复的同时把stash内容也删了 1$ git stash pop 可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash 1$ git stash apply stash@&#123;0&#125; 疑问第一个问题在dev中工作，在master中创建分支修改bug，好像互不相干呀，为什么要stash呢？ 暂存区是公用的，如果不通过stash命令隐藏，会带到其它分支（issue-101）去 第二个问题为什么要创建分支修改bug呢，直接在master中改不就好了吗？ 实际项目中，这个bug可能很麻烦，你需要修复一天的时间才能搞定，如果你不创建101分支，那么这时候你们组内其他小伙伴也要紧急修复线上一个bug，但是他的bug可能就1分钟。他修复好了却不能上线，因为你没有创建分支，要等你一天，才能把你处理好的正确代码一起上线。可能也会觉得创建分支不够效率，但是工作中稳健很重要 Feature分支每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支 第一步开发并提交 1$ git checkout -b feature-vulcan 12$ git add vulcan.py$ git commit -m &quot;add feature vulcan&quot; 第二步切回dev，准备合并 1$ git checkout dev 第三步一切顺利的话，feature分支和bug分支是类似的，合并，然后删除但是，由于种种原因，新功能取消，这个分支必须就地销毁 1$ git branch -d feature-vulcan 销毁失败 Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改如果要强行删除，需要使用命令git branch -D feature-vulcan 1$ git branch -D feature-vulcan 多人协作查看远程库的信息 1$ git remote 显示更详细的信息 1$ git remote -v 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库 推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上 1$ git push origin master 或推送其他分支 1$ git push origin dev 注意： 1、master分支是主分支，因此要时刻与远程同步； 2、dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； 3、bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； 4、feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 抓取分支当push失败时，则因为远程分支比你的本地更新 先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送 1$ git pull git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接 设置dev和origin/dev的链接 1$ git branch --set-upstream dev origin/dev 再pull 1$ git pull git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样 解决后，提交，再push 标签管理创建标签首先，切换到需要打标签的分支上 12345$ git branch* dev master$ git checkout masterSwitched to branch &apos;master&apos; 创建一个新标签 1$ git tag &lt;name&gt; 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字 1$ git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot; 查看所有标签 12$ git tag //按字母排序$ git show &lt;tagname&gt; 默认标签是打在最新提交的commit上的 有时候，如果忘了打标签 方法是找到历史提交的commit id 1$ git log --pretty=oneline --abbrev-commit 然后打上标签就可以了1$ git tag &lt;name&gt; &lt;commit id&gt; 未完待续]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git：分支管理之合并]]></title>
    <url>%2F2020%2F03%2F17%2FGit%2FGit%EF%BC%9A%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E4%B9%8B%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[假设已存在分支dev，且修改部分代码 先把已修改的推上分支dev 把切换回主分支，下拉 运行合并指令 1git merge dev 合并后在本地修改冲突 再次commit并提交到主分支]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git：将在master分支上做的修改提交到分支]]></title>
    <url>%2F2020%2F03%2F17%2FGit%2FGit%EF%BC%9A%E5%B0%86%E5%9C%A8master%E5%88%86%E6%94%AF%E4%B8%8A%E5%81%9A%E7%9A%84%E4%BF%AE%E6%94%B9%E6%8F%90%E4%BA%A4%E5%88%B0%E5%88%86%E6%94%AF%2F</url>
    <content type="text"><![CDATA[前提我在master上修复了某个bug，但是master被锁定了，我想提交到dev分支，那么使用 cherry-pick可以满足我们的要求 1234//先从主分支记下id$ git log//切换到dev分支上$ git cherry-pick &lt;id&gt;]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git：添加到远程github仓库的一个错误]]></title>
    <url>%2F2020%2F03%2F17%2FGit%2FGit%EF%BC%9A%E6%B7%BB%E5%8A%A0%E5%88%B0%E8%BF%9C%E7%A8%8Bgithub%E4%BB%93%E5%BA%93%E7%9A%84%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[问题今天使用git 添加到远程github仓库的时候提示错误：fatal: remote origin already exists. 解决办法 先删除远程 Git 仓库 1$ git remote rm origin 再添加远程 Git 仓库 1$ git remote add origin 仓库地址]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：文件上传]]></title>
    <url>%2F2020%2F03%2F17%2FJS%2FJS%EF%BC%9A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[获取文件内容1234567&lt;input type=&quot;file&quot; id=&quot;fileUpload&quot;/&gt;document.getElementById(&apos;fileUpload&apos;).onchange = function (e) &#123; var e = e || window.event; // files 为选择的所有文件 var files = e.target.files; &#125; files 为FileList，每一个元素为一个对象，里面包含： lastModified lastModifiedDate name size type webkitRelativePath 获取文件上传进度123456789101112131415161718192021222324252627282930313233343536373839var xhrOnProgress=function(fun) &#123; xhrOnProgress.onprogress = fun; //绑定监听 //使用闭包实现监听绑 return function() &#123; //通过$.ajaxSettings.xhr();获得XMLHttpRequest对象 var xhr = $.ajaxSettings.xhr(); //判断监听函数是否为函数 if (typeof xhrOnProgress.onprogress !== &apos;function&apos;) return xhr; //如果有监听函数并且xhr对象支持绑定时就把监听函数绑定上去 if (xhrOnProgress.onprogress &amp;&amp; xhr.upload) &#123; xhr.upload.onprogress = xhrOnProgress.onprogress; &#125; return xhr; &#125;&#125;function Submit()&#123; var fileObj = document.getElementById(&quot;FileUpload&quot;).files[0]; // js 获取文件对象 var formFile = new FormData(); formFile.append(&quot;file&quot;, fileObj); //加入文件对象 var data = formFile; $.ajax(&#123; url: &quot;http://up.qiniu.com/&quot;, data: data, type: &quot;Post&quot;, dataType: &quot;json&quot;, cache: false,//上传文件无需缓存 processData: false,//用于对data参数进行序列化处理 这里必须false contentType: false, //必须 xhr:xhrOnProgress(function(e)&#123; var percent=e.loaded/e.total; console.log(percent); &#125;), success: function (result) &#123; console.log(result); &#125;, &#125;)&#125; 断点续传指的是在上传/下载时，将任务（一个文件或压缩包）人为的划分为几个部分，每一个部分采用一个线程进行上传/下载，如果碰到网络故障，可以从已经上传/下载的部分开始继续上传/下载未完成的部分，而没有必要从头开始上传/下载。可以节省时间，提高速度。 它通过在 Header 里两个参数实现的，客户端发请求时对应的是 Range ，服务器端响应时对应的是 Content-Range Range 1用于请求头中，指定第一个字节的位置和最后一个字节的位置。 Content-Range 1用于响应头中，在发出带 Range 的请求后，服务器会在 Content-Range 头部返回当前接受的范围和文件总大小。 在响应完成后，返回的响应头内容也不同，根据返回的状态码判断是否使用断点续传 200 Ok（不使用断点续传方式） 206 Partial Content（使用断点续传方式）]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：青蛙跳台阶和斐波那契数列]]></title>
    <url>%2F2020%2F03%2F17%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E5%92%8C%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[简单一次跳一层或两层，求跳上一个n级的台阶总共有多少种跳法。因为n级台阶，第一步有n种跳法：跳1级、跳2级跳1级，剩下n-1级，则剩下跳法是f(n-1)跳2级，剩下n-2级，则剩下跳法是f(n-2) f(0)=0f(1)=1f(2)=2f(n)=f(n-1)+f(n-2) 1234567891011function jump(n)&#123; if(n==0)&#123; return 0; &#125;else if(n==1)&#123; return 1; &#125;else if(n==2)&#123; return 2; &#125;else&#123; return jump(n-1)+jump(n-2); &#125;&#125; 复杂一次可以跳上1级台阶，也可以跳上2级……也可以跳上n级。求跳上一个n级的台阶总共有多少种跳法。因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级跳1级，剩下n-1级，则剩下跳法是f(n-1)跳2级，剩下n-2级，则剩下跳法是f(n-2)所以f(n)=f(n-1)+f(n-2)+…+f(1)因为f(n-1)=f(n-2)+f(n-3)+…+f(1)所以f(n)=2*f(n-1) 123456789function jumpII(number)&#123; if(number == 0)&#123; return 0; &#125;else if(number == 1)&#123; return 1; &#125; return 2*jumpII(number-1)&#125; 斐波那契数列斐波那契数列，又称黄金分割数列、因数学家列昂纳多·斐波那契以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、…… 性能优化之缓存 缓存: 存储数据的容器(cache) 在js中, 可以使用数组或者是对象进行存储数据,用键存储值,这样就可以实现既能存值也能取值 用缓存的基本思路 创建一个空对象，作为缓存的容器。 首先去缓存容器中查看缓存中是否有对应的数据，如果有，直接取出来使用。 如果没有，就先计算结果，然后把结果存储到缓存容器中，方便下次复用。123456789101112131415161718var cache = &#123; &#125;;var count = 0;function fib(n)&#123; count++; if(n === 1 || n === 2)&#123; return 1; &#125; if(cache[n])&#123; return cache[n]; &#125;else&#123; var ret = fib(n - 1) + fib(n - 2); cache[n] = ret; return ret; &#125;&#125;console.log(fib(10));console.log(&quot;fib函数调用的次数 &quot; + count); 总结 缓存: 存数据(该案例中,用键存月份,值存的对数) 在js中,缓存中如何表示, 对象 || 数组]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：垂直水平居中]]></title>
    <url>%2F2020%2F03%2F03%2FCSS%2FCSS%EF%BC%9A%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[基于绝对定位要求元素具有固定的高度和宽度123456789&#123; position:absolute; top:50%; left:50%; margin-top:-20px; margin-left:-20px; height:40px; width:40px;&#125; 局限性：不能自适应，边距大小与padding，box-sizing有关 借助calc()函数 1234567&#123; position:absolute; top:calc(50%-20px); left:calc(50%-20px); height:40px; width:40px;&#125; 不需要在偏移量中把元素尺寸写死123456&#123; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);&#125; 局限性：ie8不支持 基于Flex布局123456&#123; display:flex; justify-content:center;//使子元素水平居中 align-items:center;//使子元素垂直居中 height:40px;&#125; 局限性：ie7/8不兼容 基于table布局12345&#123; display: table-cell; vertical-align: middle;//使子元素垂直居中 text-align: center;//使子元素水平居中&#125; 局限性：需要额外html标记 基于inline-block12345&#123; display: inline-block; vertical-align: middle;//使元素垂直居中 text-align: center;//使元素水平居中&#125; 只有文字1234&#123; line-height: 24px;//使元素垂直居中 text-align: center;//使元素水平居中&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：圣杯布局和双飞翼布局]]></title>
    <url>%2F2020%2F02%2F27%2FCSS%2FCSS%EF%BC%9A%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[圣杯布局 header和footer占屏幕全部宽度，高度固定 中间的contaier部分是一个三栏布局 left和right宽度固定，middle自适应填满整个区域；高度为三栏中最大的高度 浮动1234567&lt;header class=&quot;header&quot;&gt;header&lt;/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;middle&quot;&gt;middle&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;/div&gt;&lt;footer class=&quot;footer&quot;&gt;footer&lt;/footer&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344.header&#123; height:50px; width:100%; border:1px solid black;&#125;// 中间部分center设置100%撑满// 这样因为浮动的关系，center会占据整个container，左右两块区域被挤下去了.middle&#123; float: left; width: 100%; height:100%; background-color:pink;&#125;// 设置left的 margin-left: -100%;，让left回到上一行最左侧.left &#123; float: left; width: 100px; height: 100%; margin-left: -100%; background: black;&#125;// left回到第一行后，right位于第二行的最左侧// 设置margin-left把right拉回第一行的最右侧.right&#123; float: left; width:100px; height:100%; margin-left: -100px; background-color:black;&#125;// left和right这会把middle给遮住了// 所以这时给外层的container设置 padding，给left和right空出位置.container&#123; height: 300px; padding: 0 100px;&#125;.footer&#123; height:50px; width:100%; border:1px solid black;&#125; flex布局1234567&lt;header class=&quot;header&quot;&gt;header&lt;/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt;middle&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;/div&gt;&lt;footer class=&quot;footer&quot;&gt;footer&lt;/footer&gt; 123456789101112131415161718192021222324252627282930//middle占据除left和right之外的剩余所有空间，并不被遮挡.header&#123; height:50px; width:100%; border:1px solid black;&#125;.container&#123; display: flex; height:300px;&#125;.left&#123; width:100px; height:100%; background-color:black;&#125;.middle&#123; flex:1;//middle占据剩余所有空间 height:100%; background-color:pink;&#125;.right&#123; width:100px; height:100%; background-color:black;&#125;.footer&#123; height:50px; width:100%; border:1px solid black;&#125; 绝对定位以上两种dom结构均可1234567891011121314151617181920212223242526272829303132333435.header&#123; height:50px; width:100%; border:1px solid black;&#125;.container&#123; height:300px; position: relative; padding: 0 100px;&#125;.left&#123; position: absolute; top: 0; left: 0; width:100px; height:100%; background-color:black;&#125;.middle&#123; height:100%; background-color:pink;&#125;.right&#123; position: absolute; top:0; right: 0; width:100px; height:100%; background-color:black;&#125;.footer&#123; height:50px; width:100%; border:1px solid black;&#125; 双飞翼布局双飞翼布局和圣杯布局几乎一样，区别在于处理middle中被遮挡的部分。 圣杯布局是在三栏布局的父容器中设置padding。 双飞翼布局是在middle中再放一个div用来显示内容，为其设置margin。 123456789&lt;header&gt;header&lt;/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;middle&quot;&gt; &lt;div class=&quot;main&quot;&gt;middle&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;/div&gt;&lt;footer&gt;footer&lt;/footer&gt; 1234//使用圣杯布局的浮动和绝对定位时设置，同时把container中的padding去除.main&#123; margin:0 100px;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：line-height]]></title>
    <url>%2F2020%2F02%2F27%2FCSS%2FCSS%EF%BC%9Aline-height%2F</url>
    <content type="text"><![CDATA[line-height在应用到一个块级元素时，它定义了该元素中基线之间的最小距离 1234line-height:15px;//行间距为15pxline-height:150%;//行间距=当前的字体尺寸*150%line-height:1.5;//行间距=当前的字体尺寸*1.5line-height:1.5em;//行间距=当前的字体尺寸*1.5（若当前没有设置，继承父元素）]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端SEO（搜索引擎优化）和语义化]]></title>
    <url>%2F2020%2F02%2F23%2F%E5%89%8D%E7%AB%AF%2F%E5%89%8D%E7%AB%AFSEO%EF%BC%88%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96%EF%BC%89%E5%92%8C%E8%AF%AD%E4%B9%89%E5%8C%96%2F</url>
    <content type="text"><![CDATA[合理的title、description、keywords title值强调重点，要靠前，不同页面title不要相同。 description对页面内容高度概括，长度合适，不同页面有所不同。 keywords列举重点关键词即可，不要过分堆砌关键词。 语义化语义化的标签，旨在让标签有自己的含义，就是用合理、正确的标签来展示内容，比如h1~h6定义标题。 优点 易于用户阅读，css样式丢失的时候能让页面呈现清晰的结构。 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。 方便其他设备解析，如盲人阅读器根据语义渲染网页 有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。 常见语义化标签12345678910111213141516171819202122&lt;title&gt;：页面主体内容。&lt;hn&gt;：h1~h6，分级标题，&lt;h1&gt; 与 &lt;title&gt; 协调有利于搜索引擎优化。&lt;ul&gt;：无序列表。&lt;li&gt;：有序列表。&lt;small&gt;：呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权。&lt;strong&gt;：和 em 标签一样，用于强调文本，但它强调的程度更强一些。&lt;em&gt;：将其中的文本表示为强调的内容，表现为斜体。&lt;mark&gt;：使用黄色突出显示部分文本。&lt;figure&gt;：规定独立的流内容（图像、图表、照片、代码等等）（默认有40px左右margin）。&lt;figcaption&gt;：定义 figure 元素的标题，应该被置于 figure 元素的第一个或最后一个子元素的位置。&lt;cite&gt;：表示所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。&lt;blockquoto&gt;：定义块引用，块引用拥有它们自己的空间。&lt;q&gt;：短的引述（跨浏览器问题，尽量避免使用）。&lt;time&gt;：datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。&lt;abbr&gt;：简称或缩写。&lt;dfn&gt;：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。&lt;address&gt;：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）。&lt;del&gt;：移除的内容。&lt;ins&gt;：添加的内容。&lt;code&gt;：标记代码。&lt;meter&gt;：定义已知范围或分数值内的标量测量。（Internet Explorer 不支持 meter 标签）&lt;progress&gt;：定义运行中的进度（进程）。 h5新增语义化标签1234567&lt;header&gt; 定义文档或者文档的部分区域的页眉&lt;nav&gt; 描述一个含有多个超链接的区域&lt;main&gt; 定义文档的主要内容，该内容在文档中应当是独一无二的&lt;article&gt; 表示文档、页面、应用或网站中的独立结构&lt;aside&gt; 表示一个和其余页面内容几乎无关的部分&lt;footer&gt; 定义最近一个章节内容或者根节点元素的页脚&lt;section&gt; 表示文档中的一个区域（或节），比如，内容中的一个专题组。 重要内容的html代码放最前搜索引擎抓取html的顺序是从上到下，保证重要内容一定会被抓取 重要内容不要用js输出爬虫不会执行js获取内容 提高网站速度网站速度也是搜索引擎排序的一个重要指标]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：二进制转十进制]]></title>
    <url>%2F2020%2F02%2F23%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6%2F</url>
    <content type="text"><![CDATA[解法一按权相加1234567function toDecimal(str)&#123; var res = 0; for(var i=str.length-1;i&gt;=0;i--)&#123; res = str[i]===&apos;1&apos; ? Math.pow(2,str.length-1-i) + res : res; &#125; return res;&#125; 123456789function toDecimal(str)&#123; var res = 0; var temp = 1; for(var i=str.length-1;i&gt;=0;i--)&#123; res = str[i]===&apos;1&apos; ? res + temp : res; temp *= 2; &#125; return res;&#125; 解法二parseInt 的第二个参数表示要解析的数字的基数123function toDecimal(str)&#123; return parseInt(str,2);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网：http报文结构]]></title>
    <url>%2F2020%2F02%2F23%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9Ahttp%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[http报文的产生HTTP通信过程包括客户端往服务器端发送请求以及服务器端给客户端返回响应两个过程。在这两个过程中就会产生请求报文和响应报文。 什么是HTTP报文呢？HTTP报文是用于HTTP协议交互的信息，HTTP报文本身是由多行数据构成的字符串文本。客户端的HTTP报文叫做请求报文，服务器端的HTTP报文叫做响应报文。 报文结构 HTTP报文由报文首部和报文主体构成，中间由一个空行分隔。 报文首部是客户端或服务器端需处理的请求或响应的内容及属性， 可以传递额外的重要信息。 报文首部包括请求行和请求头部。 报文主体主要包含应被发送的数据。 通常，不一定有报文主体。 http请求报文一个HTTP请求报文由请求行、请求头部、空行和请求数据4个部分构成。 请求行数据格式由三个部分组成：请求方法、URI、HTTP协议版本，他们之间用空格分隔。12// 该部分位于数据首行，基本格式为：GET /index.html HTTP/1.1 该部分的请求方法字段给出了请求类型，URI给出请求的资源位置(/index.html)。HTTP中的请求类型包括:GET、POST、HEAD、PUT、DELETE。一般常用的为GET和POST方式。最后HTTP协议版本给出HTTP的版本号。 http响应报文HTTP响应报文由状态行（HTTP版本、状态码（数字和原因短语））、响应头部、空行和响应体4个部分构成。 状态行主要给出响应HTTP协议的版本号、响应返回状态码、响应描述，同样是单行显示。格式为：1HTTP/1.1 200 OK 状态码告知从服务器端返回的请求的状态，一般由一个三位数组成,分别以整数1～5开头组成。 报文首部结构 由首部字段名和字段值构成的，中间用冒号“:”分割。 首部字段格式： 首部字段名:字段值。 类型 通用首部字段：请求报文和响应报文两方都会使用的首部。 请求首部字段：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。 响应首部字段：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。 实体首部字段：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等和实体有关的信息。]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：选择器]]></title>
    <url>%2F2020%2F02%2F22%2FCSS%2FCSS%EF%BC%9A%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[选择器优先级从高到低 在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。 内联样式，作为style属性写在元素内的样式 id选择器 class带伪类，如 .input:first-child 标签[指定属性]，如 input[type=’file’] 类选择器 标签带伪类，如input:first-child，与5、6按css的顺序排优先级 标签选择器 通配符选择器 属性选择器属性选择器支持正则匹配 选择器 含义 tag[attr] 匹配具有attr属性的所有元素，不考虑它的值 tag[attr=’val’] 匹配attr属性值等于val的所有元素 tag[attr^=’val’] 匹配attr属性值以指定的值val开头的所有元素 tag[attr$=’val’] 匹配attr属性值以指定的值val结尾的所有元素 tag[attr*=’val’] 匹配attr属性值中包含指定的值val的所有元素 tag为标签名 attr为属性 val为属性值 选择器解析 CSS选择器时==从右往左解析==的 尽量少使用不必要的层级关系]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行内元素、块元素、行内块元素]]></title>
    <url>%2F2020%2F02%2F22%2F%E5%89%8D%E7%AB%AF%2F%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E3%80%81%E5%9D%97%E5%85%83%E7%B4%A0%E3%80%81%E8%A1%8C%E5%86%85%E5%9D%97%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[行内元素 设置宽高无效。 margin水平方向有效，垂直方向无效。 padding水平方向有效，垂直方向在显示上有效果即会增大元素的内容范围，但对其他元素无影响。 不会自动进行换行。 123456789101112131415161718常见行内元素a - 锚点b - 粗体(不推荐)big - 大字体br - 换行em - 强调font - 字体设定(不推荐)i - 斜体img - 图片input - 输入框label - 表格标签select - 项目选择small - 小字体文本span - 常用内联容器，定义文本内区块strong - 粗体强调textarea - 多行文本输入框u - 下划线var - 定义变量 块元素 能够识别宽高。 margin和padding的上下左右均对其有效。 可以自动换行。 多个块状元素标签写在一起，默认排列方式为从上至下。 12345678910111213141516171819常见块元素address - 地址enter - 居中对齐块dir - 目录列表div - 常用块级容器，也是css layout的主要标签dl - 定义列表form - 交互表单h1 - 大标题h2 - 副标题h3 - 3级标题h4 - 4级标题h5 - 5级标题h6 - 6级标题hr - 水平分隔线menu - 菜单列表ol - 排序表单p - 段落table - 表格ul - 非排序列表（无序列表） 可变元素可变元素由上下文语境来决定是块元素还是内联元素 1234567button - 按钮del - 删除文本iframe - inline frameins - 插入的文本map - 图片区块（map）object - object对象script - 客户端脚本 行内块元素 不自动换行 能够识别宽高 默认排列方式为从左到右 三者转换使用display属性能够将三者任意转换： display:inline;转换为行内元素 display:block;转换为块状元素 display:inline-block;转换为行内块状元素]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：各种单位]]></title>
    <url>%2F2020%2F02%2F21%2FCSS%2FCSS%EF%BC%9A%E5%90%84%E7%A7%8D%E5%8D%95%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[% padding和margin的%垂直水平方向都是基于父元素的宽度计算px（pixel，像素）是一个虚拟长度单位，是计算机系统的数字化图像长度单位。物理像素（px）设备能控制显示的最小单位逻辑像素（px）又称css像素，浏览器使用的抽象单位，而不是实际存在的设备独立像素（dip或dp）独立于设备的用于逻辑上衡量像素的单位，包括了CSS像素设备像素缩放比（dpr） dpr=物理像素/逻辑像素 1px = (dpr)^2 * dp dpr=ppi/160屏幕像素密度（PPI） 每英寸内有多少个设备像素点（物理像素） PPI越高，像素数越高，图像越清晰 屏幕分辨率（XxY）指屏幕上垂直有x个物理像素，水平有y个物理像素。 屏幕尺寸（x in）指屏幕对角线的长度有x英寸 em（相对长度单位） 子元素字体大小的em是相对于父元素字体大小，如果自身定义了font-size按自身来计算。 元素的width/height/padding/margin用em的话是相对于自身的font-size。 最多取到小数点后三位。 rem（根em） 相对于html元素上字体的大小。 1rem等于html元素上字体设置的大小。 vw、vh 1vw等于视窗宽度的1%。 1vh等于视窗高度的1%。 单位 含义 vw 相对于视图窗口的宽度，视窗宽度为100vw vh 相对于视图窗口的高度，视窗高度为100vh vmin vw和vh中的较小值 vmax vw和vh中的较大值]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：隐藏元素]]></title>
    <url>%2F2020%2F02%2F20%2FCSS%2FCSS%EF%BC%9A%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[display:none visibility: hidden opacity: 0 空间占据 display隐藏后不占据空间，会产生回流和重绘 其余两个虽隐藏，但仍占据空间，只会引起重绘 子元素继承 display不会被继承，父元素都不存在了，子元素自然也不会显示 visibility会被子元素继承，可以通过设置子元素visibility为visible使其显示 opacity也会被子元素继承，但不能通过设置子元素opacity为1使其显示 事件绑定 display隐藏后已经不存在了，肯定也无法触发事件 其余两个虽隐藏，但仍存在，可以触发事件 过渡动画transition对display和visibility无效，对opacity有效]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6：promise]]></title>
    <url>%2F2020%2F02%2F20%2FES6%2FES6%EF%BC%9Apromise%2F</url>
    <content type="text"><![CDATA[一句话概述什么是promisePromise对象用于异步操作，它表示一个尚未完成且预计在未来完成的异步操作。 为什么用promise用于异步操作，除了promise还可以用异步回调解决异步操作。 那为什么有异步回调还要promise，promise可以多重链式调用，可以避免层层嵌套回调。可以利用then进行「链式回调」，将异步操作以同步操作的流程表示出来。 注意 Promise在生命周期内有三种状态，分别是pending、fulfilled 和 rejected。 状态改变只能是pending-&gt;fulfilled(成功)，或者pending-&gt;rejected(失败)。而且状态一旦改变，就不能再次改变。 Promise中调用resolve或reject并不会终结 Promise 的参数函数的执行。 Promise的构造函数中代码是同步执行的，但是then方法是异步执行的，then方法需要等到resolve函数执行时才得到执行。 reject 和 catch 的区别 在resolve中发生异常的话，在reject中是捕获不到这个异常的。.then中产生的异常能在.catch中捕获 如果在then中抛错，而没有对错误进行处理（即catch），那么会一直保持reject状态，直到catch了错误。且catch之前的函数都不会执行。 每次调用then都会返回一个新创建的promise对象，而then内部只是返回的数据。 在异步回调中抛错，不会被catch到。 promise状态变为resolve或reject，就凝固了，不会再改变。 Promise一旦执行了resolve函数后，就不会再执行reject和其他的resolve函数了。一旦Promise执行了reject函数，将会被catch函数捕获，执行catch中的代码。 如何处理异步 promise 回调函数 12345678function f1(callback)&#123; setTimeout(function () &#123; // f1的任务代码 callback(); &#125;, 1000);&#125;// 执行f1(f2) 发布订阅 事件监听 async/await 一个简单的promise对象12345new Promise(test).then(function (result) &#123; console.log(&apos;成功：&apos; + result);&#125;).catch(function (reason) &#123; console.log(&apos;失败：&apos; + reason);&#125;);]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：事件委托]]></title>
    <url>%2F2020%2F02%2F20%2FJS%2FJS%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%2F</url>
    <content type="text"><![CDATA[概述事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。 为什么要用减少DOM操作，优化性能。 在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能。 原理事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件。 举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。 1234567891011121314151617181920212223242526272829&lt;ul id=&quot;ul1&quot;&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt;&lt;/ul&gt;window.onload = function()&#123; var oUl = document.getElementById(&quot;ul1&quot;); oUl.onclick = function()&#123; alert(123); &#125;&#125;//改进：只有点击li才会触发window.onload = function()&#123; var oUl = document.getElementById(&quot;ul1&quot;); oUl.onclick = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == &apos;li&apos;)&#123; alert(123); alert(target.innerHTML); &#125; &#125;&#125;//target就可以表示为当前的事件操作的dom，但是不是真正操作dom。//这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement， e.target 和 e.currentTarget e.target指向触发事件监听的对象 e.currentTarget指向绑定事件监听的对象]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：数组和链表]]></title>
    <url>%2F2020%2F02%2F20%2FJS%2FJS%EF%BC%9A%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[物理地址存储的连续性 数组的元素在内存中是连续存放的。 链表的元素在内存中不一定是连续存放的，通常是不连续的。 访问速度 数组的访问速度很快，因为数组可以根据数组可以根据下标进行快速定位。 链表的访问速度较慢，因为链表访问元素需要移动指针。 添加、删减元素速度 数组的元素增删速度较慢，因为需要移动大量的元素。 链表的元素增删速度较快，因为只需要修改指针即可。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue：组件间的传值]]></title>
    <url>%2F2020%2F02%2F20%2FVue%2FVue%EF%BC%9A%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[父组件向子组件传值 父组件把要传递的值绑定在调用的子组件上 子组件通过props[“”]来接收值来使用 子组件向父组件传值 子组件通过$emit(‘函数名’,’参数’)来抛出事件传递参数 父组件通过在调用的子组件上绑定函数名来使用参数（@函数名） vuex 兄弟之间传值 vuex 通过路由带参数进行传值 123this.$router.push(&#123; path: &apos;/conponentsB&apos;, query: &#123; orderId: 123 &#125; &#125;) // 跳转到Bthis.$route.query.orderId // 在B组件拿到的参数 通过设置本地存储，如Session Storage缓存的形式进行传递 123const orderData = &#123; &apos;orderId&apos;: 123, &apos;price&apos;: 88 &#125;sessionStorage.setItem(&apos;缓存名称&apos;, JSON.stringify(orderData))const dataB = JSON.parse(sessionStorage.getItem(&apos;缓存名称&apos;)) // 在其他组件拿到session Storage缓存的值]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：作用域]]></title>
    <url>%2F2020%2F02%2F19%2FJS%2FJS%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[作用域就是变量和函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。 全局作用域在代码任何地方都能访问到的对象拥有全局作用域。拥有作用域的情况： 程序最外层定义的函数或变量。 所有未定义直接赋值的变量，相当于在window对象上创建属性。（不推荐） 所有window对象的属性和方法。 局部作用域（函数作用域）局部作用域在函数内创建，在函数内可访问，函数外不可访问。 变量声明js引擎解析js代码时，会先把变量和函数的声明提前进行预解析，然后再去执行其他代码。 直接赋值不会引起变量提升，在执行期间创建，为window的属性，可删除。 函数声明 function name(){}直接创建 new Function构建函数创建 给变量赋值匿名函数方法创建1var name = function()&#123; &#125; 后两者，在声明前访问，返回undefined。函数名与变量名声明时相同，函数优先声明。 作用域链 当代码在一个环境中执行时，一般情况下，会到当前执行环境中访问变量。 但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条（即这样逐层的作用域形成的链条）就叫做作用域链。 作用域链是函数被创建的作用域中对象的集合。作用域链保证了对变量和函数的有序访问。 每次进入一个新的执行环境，都会创建一个用于搜索变量和函数的作用域链。 作用域链的前端，始终是当前执行代码所在环境的变量对象。如果当前环境是函数，则将其活动对象作为变量对象。活动对象最开始只包含arguments对象（这个对象在全局环境中不存在）。 全局执行环境的变量对象始终都是作用域链的最后一个对象。 js每一个函数执行时，会先在自己创建的AO上找对应的属性值。若找不到，则往父函数的AO上找，直到找到全局作用域，这样就形成一条作用域链。 VO（变量对象）：函数创建阶段，js解析引擎进行预解析时，所有变量和函数的声明组成VO。 AO（活动对象）：函数执行阶段，当函数被调用执行时，会建立一个执行上下文，该执行上下文包含了函数所需的所有变量，这些变量组成AO。 执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：BFC]]></title>
    <url>%2F2020%2F02%2F17%2FCSS%2FCSS%EF%BC%9ABFC%2F</url>
    <content type="text"><![CDATA[BFC定义块级格式化上下文，是指一个独立的块级渲染区域。该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。 BFC生成满足下列css声明之一的元素便会生成BFC 根元素或其它包含它的元素 float的值不为none； overflow的值不为visible； position的值不为static； display的值为inline-block、table-cell、table-caption； flex boxes (元素的display: flex或inline-flex)； BFC布局规则 内部的元素会在垂直方向一个接一个地排列，可以理解为是BFC中的一个常规流 元素垂直方向的距离由margin决定，即属于同一个BFC的两个相邻盒子的margin可能会发生重叠 每个元素的左外边距与包含块的左边界相接触(从左往右，否则相反)，即使存在浮动也是如此，这说明BFC中的子元素不会超出它的包含块 BFC的区域不会与float元素区域重叠 计算BFC的高度时，浮动子元素也参与计算 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然 位于不同BFC下的相邻元素之间不会发生margin重叠 BFC的应用解决margin塌陷和margin合并问题 margin塌陷为父子元素都设置margin，只取最大的一个。解决方法为父元素触发bfc，使其遵循bgc渲染规则。 margin合并的原理为它们处于同一个BFC中，符合“属于同一个BFC的两个相邻元素的margin会发生重叠”的规则。解决方法为在其中一个元素外面包裹一层容器，并触发容器生成一个BFC（overflow：hidden），使两个元素处于不同的BFC。 解决高度塌陷问题当我们不给父节点设置高度，子节点设置浮动的时候，会发生高度塌陷，这个时候我们就要清除浮动。 给父元素设置overflow：hidden可以清除子元素的浮动是应用了BFC的原理：给父元素设置overflow：hidden触发了BFC，形成一个独立的渲染区域，所以内部的元素就不会影响外面的布局，BFC把浮动的子元素的高度当作自己的高度去处理溢出，从外面看起来就是清除了浮动 解决侵占浮动元素的问题当一个元素浮动，另一个元素不浮动时，浮动元素因为脱离文档流，就会盖在不浮动的元素上。 解决方法：不浮动的元素也设为浮动，或者添加overflow：hidden 原理：为不浮动的元素建立BFC环境，BFC不与float box重叠。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：margin塌陷和margin合并]]></title>
    <url>%2F2020%2F02%2F17%2FCSS%2FCSS%EF%BC%9Amargin%E5%A1%8C%E9%99%B7%E5%92%8Cmargin%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[margin塌陷 标准文档流中，垂直方向的margin不叠加，以较大的为准。即父子嵌套元素在垂直方向的margin,父子元素是结合在一起的,他们两个的margin会取其中最大的值。 正常情况下,父级元素应该相对浏览器进行定位,子级相对父级定位。 但由于margin的塌陷,父级相对浏览器定位.而子级没有相对父级定位,子级相对父级,就像坍塌了一样。 原理是他们处于同一个BFC中。 体现 红色方块margin-top为100px 现在给里面的小方块设置margin-top:100px，发现两个方块位置没动 而当给里面的小方块设置margin-top:150px，小方块带着大方块往下移动了50px（100和150取了150，里面的小方块依然紧贴大方块最上面） 解决 给父元素设置边框或内边距(不建议使用) 给父元素添加某些条件触发bfc(块级格式上下文),改变父级的渲染规则 position:absolute/fixed display:inline-block/table float:left/right overflow:hidden 给子元素的前面加一个兄弟元素。 margin合并 标准文档流中，两个兄弟结构的元素在垂直方向上的margin不叠加，是合并的，以较大的为准。 原因是他们处于同一个BFC中。 解决margin塌陷的原理是使两个元素处于不同的bfc中，不同的bfc是不会发生margin塌陷的 解决 给其中一个元素添加盒子div并触发bfc 给两个元素都添加盒子div并触发bfc position:absolute/fixed display:inline-block; float:left/right overflow:hidden]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue：路由原理]]></title>
    <url>%2F2020%2F02%2F15%2FVue%2FVue%EF%BC%9A%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[单页面应用随着前端应用的业务功能越来越复杂、用户对于使用体验的要求越来越高，单页应用（SPA）成为前端应用的主流形式。大型单页应用最显著特点之一就是采用前端路由系统，通过改变URL，在不重新请求页面的情况下，更新页面视图。 vue-router实现方式“更新视图但不重新请求页面”是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有两种方式： hash模式，url带#号，但是访问网页不会404。 history模式。url不带#号。前端的 URL 必须和实际向后端发起请求的 URL 一致，如果后端没有规定好路由，直接复制url会404。 1234// hashhttp://localhost:8080/#/test// historyhttp://localhost:8080/test mode在vue-router中是通过mode这一参数控制路由的实现模式的，创建VueRouter的实例对象时，mode以构造函数参数的形式传入。 123456789const router = new VueRouter(&#123; mode: &apos;history&apos;, routes: [...]&#125;)// mode 参数：- 默认hash- history 注：如果浏览器不支持history新特性,则采用hash方式- 如果不在浏览器环境则使用abstract（node环境下） history对象当选择mode类型之后，程序会根据你选择的mode 类型创建不同的history对象 HashHistory HTML5History AbstractHistory 1234567891011121314151617// 源码// 根据mode确定history实际的类并实例化switch (mode) &#123; case &apos;history&apos;: this.history = new HTML5History(this, options.base) break case &apos;hash&apos;: this.history = new HashHistory(this, options.base, this.fallback) break case &apos;abstract&apos;: this.history = new AbstractHistory(this, options.base) break default: if (process.env.NODE_ENV !== &apos;production&apos;) &#123; assert(false, `invalid mode: $&#123;mode&#125;`) &#125;&#125; HashHistory替换路由的两个方法 HashHistory.push() HashHistory.replace() HashHistory.push()将新路由添加到浏览器访问历史的栈顶 1234561 $router.push() //调用方法2 HashHistory.push() //根据hash模式调用,设置hash并添加到浏览器历史记录（添加到栈顶）（window.location.hash= XXX）3 History.transitionTo() //监测更新，更新则调用History.updateRoute()4 History.updateRoute() //更新路由5 &#123;app._route= route&#125; //替换当前app路由6 vm.render() //更新视图 HashHistory.replace()replace()方法与push()方法不同之处在于，它并不是将新路由添加到浏览器访问历史的栈顶，而是替换掉当前的路由 12345678910111213replace (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; this.transitionTo(location, route =&gt; &#123; replaceHash(route.fullPath) onComplete &amp;&amp; onComplete(route) &#125;, onAbort)&#125; function replaceHash (path) &#123; const i = window.location.href.indexOf(&apos;#&apos;) window.location.replace( window.location.href.slice(0, i &gt;= 0 ? i : 0) + &apos;#&apos; + path )&#125; 监听地址栏在浏览器中，用户还可以直接在浏览器地址栏中输入改变路由，因此VueRouter还需要能监听浏览器地址栏中路由的变化，并具有与通过代码调用相同的响应行为。在HashHistory中这一功能通过setupListeners实现 12345678910setupListeners () &#123; window.addEventListener(&apos;hashchange&apos;, () =&gt; &#123; if (!ensureSlash()) &#123; return &#125; this.transitionTo(getHash(), route =&gt; &#123; replaceHash(route.fullPath) &#125;) &#125;)&#125; 该方法设置监听了浏览器事件hashchange，调用的函数为replaceHash，即在浏览器地址栏中直接输入路由相当于代码调用了replace()方法 HTML5History History interface是浏览器历史记录栈提供的接口，通过back(), forward(), go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。 从HTML5开始，History interface有进一步修炼：pushState(), replaceState() 这下不仅是读取了，还可以对浏览器历史记录栈进行修改 当然了，HTML5History用到了HTML5的新特特性，是需要特定浏览器版本的支持的 window.history.pushState()和window.history.replaceState() window.history.pushState(stateObject, title, URL) window.history.replaceState(stateObject, title, URL) stateObject: 当浏览器跳转到新的状态时，将触发popState事件，该事件将携带这个stateObject参数的副本 title: 所添加记录的标题 URL: 所添加记录的URL 监听地址变化在HTML5History的构造函数中监听popState（window.onpopstate） 在HTML5History中添加对修改浏览器地址栏URL的监听是直接在构造函数中执行的 1234567891011constructor (router: Router, base: ?string) &#123; window.addEventListener(&apos;popstate&apos;, e =&gt; &#123; const current = this.current this.transitionTo(getLocation(this.base), route =&gt; &#123; if (expectScroll) &#123; handleScroll(router, route, current, true) &#125; &#125;) &#125;)&#125; 两者区别 pushState设置的新URL可以是与当前URL同源的任意URL；而hash只可修改#后面的部分，故只可设置与当前同文档的URL pushState设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中；而hash设置的新值必须与原来不一样才会触发记录添加到栈中 pushState通过stateObject可以添加任意类型的数据到记录中；而hash只可添加短字符串 pushState可额外设置title属性供后续使用 一个问题用户直接在地址栏中输入并回车，浏览器重启重新加载应用时 hash模式仅改变hash部分的内容，而hash部分是不会包含在HTTP请求中的，故在hash模式下遇到根据URL请求页面的情况不会有问题。 12http://oursite.com/#/user/id // 如重新请求只会发送http://oursite.com/ 而history模式则会将URL修改得就和正常请求后端的URL一样。1http://oursite.com/user/id 如后端没有配置对应/user/id的路由处理，则会返回404错误。 官方推荐的解决办法是在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSocket]]></title>
    <url>%2F2020%2F02%2F15%2F%E5%89%8D%E7%AB%AF%2FWebSocket%2F</url>
    <content type="text"><![CDATA[长连接和短连接长连接是存在于网络层的一种连接状态，而实现它则需要在传输层进行开发，因为它是基于对真实数据的收发，需要在底层进行管控。 http http1.0不支持长连接，http1.1支持长连接 http1.x是文本协议，http2.0是二进制协议 HTTP作为应用层协议，其实它的生命周期在服务器返回结果时就已经结束了，而所谓的支持长连接，其实是基于’Keep-Alive’请求头所约定，从而向下进行长连接发起的一种机制。该长连接依然是基于TCP的。 短连接所谓短连接，即连接只保持在数据传输过程，请求发起，连接建立，数据返回，连接关闭。它适用于一些实时数据请求，配合轮询来进行新旧数据的更替。 长连接长连接便是在连接发起后，在请求关闭连接前客户端与服务端都保持连接，实质是保持这个通信管道，之后便可以对其进行复用。它适用于涉及消息推送，请求频繁的场景（直播，流媒体）。连接建立后，在该连接下的所有请求都可以重用这个长连接管道，避免了频繁了连接请求，提升了效率。 轮询 所谓轮询，即是浏览器通过JavaScript启动一个定时器，然后以固定的间隔给服务器发请求，询问服务器有没有新消息这样一个机制。 然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。 只要有请求的的地方，都可以实现轮询，譬如各种事件驱动模型。它的长短是在于某次请求的返回周期。 短轮询短轮询指的是在循环周期内，不断发起请求，每一次请求都立即返回结果，根据新旧数据对比决定是否使用这个结果。 长轮询而长轮询即是在请求的过程中，若是服务器端数据并没有更新，那么则将这个连接挂起，直到服务器推送新的数据，再返回，然后再进入循环周期。 由上可以看到，长短轮询的理想实现都应当基于长连接，否则若是循环周期太短，那么服务器的荷载会相当重；当然，即便是在长连接下，访问人数过多，长短轮询都有可能造成服务器的瞬时访问量庞大，这就需要一些相应的优化实践了。 websocket WebSocket是HTML5新增的一种在单个 TCP 连接上进行全双工通讯的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。 在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 为什么http不能实现这是因为HTTP协议是一个请求－响应协议，请求必须先由浏览器发给服务器，服务器才能响应这个请求，再把数据发送给浏览器。换句话说，浏览器不主动请求，服务器是没法主动发数据给浏览器的。 用轮询是可以实现的，但这个机制的缺点一是实时性不够，二是频繁的请求会给服务器带来极大的压力。 websocket实现WebSocket并不是全新的协议，而是利用了HTTP协议来建立连接。 实际上HTTP协议是建立在TCP协议之上的，TCP协议本身就实现了全双工通信，但是HTTP协议的请求－应答机制限制了全双工通信。WebSocket连接建立以后，其实只是简单规定了一下：接下来，咱们通信就不使用HTTP协议了，直接互相发数据吧。 创建websocket连接首先，WebSocket连接必须由浏览器发起，因为请求协议是一个标准的HTTP请求，格式如下： 1234567GET ws://localhost:3000/ws/chat HTTP/1.1Host: localhostUpgrade: websocketConnection: UpgradeOrigin: http://localhost:3000Sec-WebSocket-Key: client-random-stringSec-WebSocket-Version: 13 该请求和普通的HTTP请求有几点不同： GET请求的地址不是类似/path/，而是以ws://开头的地址； 请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接； Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据； Sec-WebSocket-Version指定了WebSocket的协议版本。 一个WebSocket连接就建立成功，浏览器和服务器就可以随时主动发送消息给对方。消息有两种，一种是文本，一种是二进制数据。通常，我们可以发送JSON格式的文本。 浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。 安全的websocket安全的WebSocket连接机制和HTTPS类似。首先，浏览器用wss://xxx创建WebSocket连接时，会先通过HTTPS创建安全的连接，然后，该HTTPS连接升级为WebSocket连接，底层通信走的仍然是安全的SSL/TLS协议。 浏览器很显然，要支持WebSocket通信，浏览器得支持这个协议，这样才能发出ws://xxx的请求。目前，支持WebSocket的主流浏览器如下： Chrome Firefox IE &gt;= 10 Sarafi &gt;= 6 Android &gt;= 4.4 iOS &gt;= 8 服务器由于WebSocket是一个协议，服务器具体怎么实现，取决于所用编程语言和框架本身。Node.js本身支持的协议包括TCP协议和HTTP协议，要支持WebSocket协议，需要对Node.js提供的HTTPServer做额外的开发。已经有若干基于Node.js的稳定可靠的WebSocket实现，我们直接用npm安装使用即可。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回流（Reflow）和重绘（Repaint）]]></title>
    <url>%2F2020%2F02%2F15%2F%E5%89%8D%E7%AB%AF%2F%E5%9B%9E%E6%B5%81%EF%BC%88Reflow%EF%BC%89%E5%92%8C%E9%87%8D%E7%BB%98%EF%BC%88Repaint%EF%BC%89%2F</url>
    <content type="text"><![CDATA[浏览器渲染解析HTML，生成DOM树，解析CSS，生成CSSOM树。将DOM树和CSSOM树结合，生成渲染树（Render Tree）。 回流当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流。 每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。 重绘当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。 回流必定触发重绘，而重绘不一定触发回流。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面渲染过程（输入一个url）]]></title>
    <url>%2F2020%2F02%2F13%2F%E5%89%8D%E7%AB%AF%2F%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%EF%BC%88%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAurl%EF%BC%89%2F</url>
    <content type="text"><![CDATA[输入一个url到网页呈现 输入网址 发送到DNS服务器，并获取域名对应的web服务器对应的ip地址。 与web服务器建立TCP连接 浏览器向web服务器发送http请求 web服务器响应请求，并返回指定url数据 浏览器下载web服务器返回的数据。 解析 HTML 文件,构建 DOM 树,同时浏览器主进程负责下载 CSS 文件 CSS 文件下载完成,解析 CSS 文件生成cssom树，调用JS执行引擎执行JS代码，然后将DOM树和CSSOM树结合生成渲染树。 根据渲染树来布局，计算每个节点的布局信息，将各个节点绘制到屏幕上来渲染页面，直至显示完成。 若dom树生成过程中遇到script标签，则暂停，执行js直至完成再继续生成。 若执行js时需要操作cssom，还得等css加载执行完生成cssom才能继续执行。 因此，css资源要先于js资源加载，js放于页面底部，尽量少影响dom树的生成 各种拓展页面加载白屏原因： 在弱网络下，网络延迟，JS加载延迟，会阻塞页面。 客户端存在bug，缓存模块错乱，不缓存js等后来挂起的文件，以及乱缓存index.html。 如果页面完全一片空白。极有可能是后端出现问题，后端配置无错误输出，并且服务状态500，这个时候页面就是一片空白。如果是前端导致的，那么极有可能是单页应用异常，比如到了一个没有设置的新的页面。1、打开能看到源码和request、response的浏览器，如chrome，查看源码输出2、如果是后端问题，那么后端查看accesslog、程序日志，看看是否有问题3、如果是前端问题，那么根据给出的js异常之类的排查 统计白屏数量：监听某个主div的变化，在规定时间内该DIV没有变化，那就可以进行白屏统计了。 监控白屏时间：监听某个主div的变化，直至页面渲染。 优化：尽量减少文件夹的嵌套，文件名不要过长。 一个网站很卡找原因首先用3g网络测试一下：如果卡就是http请求数据可能过大。可以合并JS脚本和CSS文件，css精灵图，对HTTP传输进行gzip压缩。css放顶部，javascript放底部。 可能服务端出问题：比如用户访问量大，并发量大。mysql没有优化好，造成死锁。 可以用CDN加速把数据放在离用户更近的位置。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：简化运算]]></title>
    <url>%2F2020%2F02%2F12%2FJS%2FJS%EF%BC%9A%E7%AE%80%E5%8C%96%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[三元运算12345678let type;if(type === &apos;a&apos;) &#123; type = &apos;typeA&apos;;&#125; else if (type === &apos;b&apos;) &#123; type = &apos;typeB&apos;&#125;// 简化let type = type === &apos;a&apos; ? &apos;typeA&apos; : &apos;typeB&apos; 四元运算12345678910let type;if(type === &apos;a&apos;) &#123; type = &apos;typeA&apos;;&#125; else if (type === &apos;b&apos;) &#123; type = &apos;typeB&apos;&#125; else if (type === &apos;c&apos;) &#123; type = &apos;typeC&apos;&#125;// 简化let type = type === &apos;a&apos; ? &apos;typeA&apos; : (type === &apos;b&apos; ? &apos;typeB&apos; : &apos;typeC&apos;)]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：this指向]]></title>
    <url>%2F2020%2F01%2F15%2FJS%2FJS%EF%BC%9Athis%E6%8C%87%E5%90%91%2F</url>
    <content type="text"><![CDATA[普通函数 普通函数被调用时，即运行时，才会确定该函数内this的指向。 this指向调用该函数的对象。 fn() 不带任何引用形式调用函数，this指向全局对象。 严格模式下this为undefined。12345var a = 1;function fn () &#123; console.log(this.a);&#125;fn(); // 1 obj.fn()this指向调用该函数的对象12345678var a = 1;var obj = &#123; a: 2, fn: function () &#123; console.log(this.a); &#125;&#125;obj.fn(); // 2 obj1.obj.fn()这种形式的调用结果一样，函数内的this只指向直接调用该函数的对象（obj）123456789101112var a = 1;var obj = &#123; a: 2, fn: function () &#123; console.log(this.a); &#125;&#125;var obj1 = &#123; a: 3, obj&#125;obj1.obj.fn(); // 2 另一种形式的fn()普通函数的this指向只在调用时确定，在调用前无论经过什么操作都不会改变this的指向。123456789var a = 1;var obj = &#123; a: 2, fn: function () &#123; console.log(this.a); &#125;&#125;var test = obj.fntest(); // 1 拓展的fn() 当setTimeout中的回调函数为普通函数时，回调函数中的this依然是指向全局对象。 当setTimeout中的回调函数为箭头函数时，this指向定义时函数所在作用域的父级作用域的this。（父级为普通函数this指向调用父级的对象，若父级仍为箭头函数，则需要继续往上找） 12345678var a = 1;var obj = &#123; a: 2, fn: function () &#123; console.log(this.a); &#125;&#125;setTimeout(obj.fn); // 1 setTimeout内部 1234function setTimeout (fn,time) &#123; // code... fn(); //没有指明调用的对象，指向全局&#125; fn.call()、fn.apply()、fn.bind()可以改变this的指向 new fn() new这个操作符其实是new一个新对象出来，而fn被称为构造函数，可以在这个构造函数中定义一些将要到来的新对象的一些属性。 在构造函数中就是用this来描述这个即将到来的新对象，所以构造函数中的this就是指向被new出来的新对象。123456var a = 1;function fn (a) &#123; this.a = a;&#125;var b = new fn(2);console.log(b.a); // 2 箭头函数this在定义时就已经确定，指向定义时箭头函数所在的作用域（而不是箭头函数的作用域）的父级作用域的this。 若父级作用域为普通函数，则this指向调用父级函数的对象。 若父级作用域为箭头函数，则this指向父级作用域的父级作用域。 如此往上找，直到全局 首先从它的父级作用域中找，如果父级作用域还是箭头函数，再往上找，如此直至找到this的指向，最后是到window。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：多层数组转化为一层]]></title>
    <url>%2F2020%2F01%2F14%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%A4%9A%E5%B1%82%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%B8%80%E5%B1%82%2F</url>
    <content type="text"><![CDATA[题目给定一个数组，将多层数组转化为一层。 注意，数组元素不一定是数字，有可能为对象或字符串。 测试用例121. [&apos;1&apos;,[2,3],-1] // [&apos;1&apos;,2,3,-1]2. [&apos;1&apos;,[2,3],&#123;a:-1&#125;] // [&apos;1&apos;,2,3,&#123;a:-1&#125;] 解法思路 遍历数组，取出元素放入新数组，若元素为数组则递归取出 算法123456789101112131415/** * @param &#123;array&#125; arr * @param &#123;array&#125; res * @return &#123;array&#125; */var flatten = function (arr, res) &#123; for(let i in arr) &#123; if(arr[i] instanceof Array) &#123; test(arr[i],res) &#125; else &#123; res.push(arr[i]); &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode：验证回文串]]></title>
    <url>%2F2019%2F12%2F19%2F%E7%AE%97%E6%B3%95%2FLeetCode%EF%BC%9A%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 测试用例121. &quot;A man, a plan, a canal: Panama&quot; // true2. &quot;race a car&quot; // false 解法思路 先判空字符串 对非空字符串，先用正则把除字母和数字之外的字符去除，再全部转换为小写字母 把字符串分割为数组，翻转，再拼接为字符串，与原字符串进行对比 算法1234567891011121314/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isPalindrome = function(s) &#123; if(s === &apos;&apos;) &#123; return true; &#125; s = s.replace(/[^0-9a-zA-Z]/g, &apos;&apos;).toLowerCase(); if(s === s.split(&apos;&apos;).reverse().join(&apos;&apos;))&#123; return true; &#125; return false;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：AJAX]]></title>
    <url>%2F2019%2F12%2F06%2FJS%2FJS%EF%BC%9AAJAX%2F</url>
    <content type="text"><![CDATA[核心XMLHttpRequest，一个js对象，一个构造函数。 方法 open()：准备启动一个AJAX请求； setRequestHeader()：设置请求头部信息； send()：发送AJAX请求； getResponseHeader(): 获得响应头部信息； getAllResponseHeader()：获得一个包含所有头部信息的长字符串； abort()：取消异步请求； 另外，浏览器还为该对象提供了一个onreadystatechange监听事件，大明湖readyState属性改变时，就会触发该事件发送。 为了确保浏览器的兼容性，最好在调用open方法之前指定事件处理程序。 属性 responseText：包含响应主体返回文本； responseXML：如果响应的内容类型时 text/xml或 application/xml，该属性将保存包含着相应数据的XML DOM文档； status：响应的HTTP状态； statusText：HTTP状态的说明； readyState：表示“请求”/“响应”过程的当前活动阶段 拓展 什么是ajax？ajax作用是什么？ 1ajax是用来与后台交互的一种技术。用来实现客户端服务器的异步通信效果，实现页面的局部刷新。 原生js ajax发送http请求需要几个步骤？分别是什么？ 1234567891011121314151617181920//1：创建XMLHttpRequest对象var xhr = new XMLHttpRequest();//2：设置请求参数（请求方式，url，是否异步请求）xhr.open(&quot;GET&quot;,url,false);//3：设置请求头部(也可以不设置)xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);//支持跨域发送cookiexhr.withCredentials = true;//4：发送请求xhr.send(null);//5：设置事件处理程序xhr.onreadystatechange = function()&#123; if(xhr.readystate == 4)&#123; if(xhr.status == 200)&#123; console.log(xhr.responseText); &#125;else&#123; console.log(&quot;出错了&quot;); &#125; &#125;&#125; readyState的取值？ 123450：(未初始化)还没有调用open()方法。1：(启动)已调用open()方法，但send()方法还没调用。2：(发送)send()方法已经调用，请求已发送，但未接收到响应。3：(交互)服务器端发送响应，客户端正在解析响应内容。4：(完成)响应内容解析完成，可以在客户端调用了。 http的请求方法 12345678get：获取服务器中的资源。post：传输实体文本put：传输文件。要指出资源在服务器中的位置。head：获取页面的首部。delete：删除服务器中的某个资源。options：获取当前url所支持的方法。trace：追踪路径。connect：要求用隧道协议连接代理。 get和post的区别 1231. 发送方式：get请求传送的参数放在url上，即http的协议头；post把传送的参数放在http的包体中。2. 大小限制：get传的参数有长度限制；post理论上没有限制。3. 安全性：get请求传送的数据放在url上，会被缓存，请求保存在浏览器的历史记录中；post不能被缓存。 什么情况造成跨域？如何解决？ 123456789受同源策略限制。协议、子域名、主域名、端口号、ip地址、网址，任一不同都为不同源。1. jsonp 只能解决get跨域2. CORS：跨域资源共享，通过设置Access-Control-Allow-Origin来允许跨域（主要后台配置）3. 设置document.domain4. 代理请求解决接口跨域。jsonp通过script标签进行跨域请求①前端设置好回调函数，将回调函数名作为url携带的参数。②后端接到请求后，生成一个函数，函数名为前端传来的回调函数名，数据作为参数传入函数，返回js文档。③客户端解析并执行返回的js文档，将返回的数据传入回调函数执行。 http状态码（status） 状态码 含义 1xx 请求正在被处理 2xx 请求成功被处理 3xx 请求需求附加操作，如重定向 4xx 客户端出错导致请求无法被处理 5xx 服务端处理出错 常用状态码 200 请求成功处理，一切正常 301 永久重定向（新网址替换旧网址，旧网址清零） 302 临时重定向（也是替换，但是旧网址还能参与排名） 304 资源未修改 403 禁止访问 404 页面未找到 405 不允许此请求方法 500 服务器出错 回调函数 1231.一个函数作为参数传递给另一个函数，在功能下载完成后执行，作为参数的函数即为回调函数。2.可用于解决异步。3.典型例子即为ajax请求。 回调地狱 12345当许多功能需要连续调用,环环相扣依赖时。就会产生函数作为参数层层嵌套的一个效果，这就形成回调地狱。使得代码变得难以理解与维护。解决：1.保持代码简短，避免使用匿名函数。2.模块化。将不同功能的代码封装成不同的模块。3.处理每一个错误。为了让代码稳定，永远无法知道这些错误何时发生，所以必须对它们进行计划。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TS：基础类型]]></title>
    <url>%2F2019%2F12%2F06%2FTS%2FTS%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[TypeScript里的类型注解是一种轻量级的为函数或变量添加约束的方式。通常表示为 变量名:类型 布尔值1let isDone: boolean = false; 数字和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。 1234let decLiteral: number = 6;let hexLiteral: number = 0xf00d;let binaryLiteral: number = 0b1010;let octalLiteral: number = 0o744; 字符串JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 string表示文本数据类型。 和JavaScript一样，可以使用双引号（ “）或单引号（’）表示字符串。 12let name: string = &quot;bob&quot;;name = &quot;smith&quot;; 你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ `），并且以${ expr }这种形式嵌入表达式 12345let name: string = `Gene`;let age: number = 37;let sentence: string = `Hello, my name is $&#123; name &#125;.I&apos;ll be $&#123; age + 1 &#125; years old next month.`; 这与下面定义sentence的方式效果相同： 12let sentence: string = &quot;Hello, my name is &quot; + name + &quot;.\n\n&quot; + &quot;I&apos;ll be &quot; + (age + 1) + &quot; years old next month.&quot;; 数组可以在元素类型后面接上 []，表示由此类型元素组成的一个数组： 1let list: number[] = [1, 2, 3]; 也可以使用数组泛型，Array&lt;元素类型&gt;： 1let list: Array&lt;number&gt; = [1, 2, 3]; 元组 Tuple元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。 123456// Declare a tuple typelet x: [string, number];// Initialize itx = [&apos;hello&apos;, 10]; // OK// Initialize it incorrectlyx = [10, &apos;hello&apos;]; // Error 当访问一个已知索引的元素，会得到正确的类型： 12console.log(x[0].substr(1)); // OKconsole.log(x[1].substr(1)); // Error, &apos;number&apos; does not have &apos;substr&apos; 当访问一个越界的元素，会使用联合类型替代： 12345x[3] = &apos;world&apos;; // OK, 字符串可以赋值给(string | number)类型console.log(x[5].toString()); // OK, &apos;string&apos; 和 &apos;number&apos; 都有 toStringx[6] = true; // Error, 布尔不是(string | number)类型 枚举enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。 12enum Color &#123;Red, Green, Blue&#125;let c: Color = Color.Green; 默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号： 12enum Color &#123;Red = 1, Green, Blue&#125;let c: Color = Color.Green; 或者，全部都采用手动赋值： 12enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;let c: Color = Color.Green; 枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字： 123enum Color &#123;Red = 1, Green, Blue&#125;let colorName: string = Color[2];console.log(colorName); // 显示&apos;Green&apos;因为上面代码里它的值是2 Any有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量： 123let notSure: any = 4;notSure = &quot;maybe a string instead&quot;;notSure = false; // okay, definitely a boolean 在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 Object有相似的作用，就像它在其它语言中那样。 但是 Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法： 123456let notSure: any = 4;notSure.ifItExists(); // okay, ifItExists might exist at runtimenotSure.toFixed(); // okay, toFixed exists (but the compiler doesn&apos;t check)let prettySure: Object = 4;prettySure.toFixed(); // Error: Property &apos;toFixed&apos; doesn&apos;t exist on type &apos;Object&apos;. 当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据： 12let list: any[] = [1, true, &quot;free&quot;];list[1] = 100; Void某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void： 123function warnUser(): void &#123; console.log(&quot;This is my warning message&quot;);&#125; 声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null： 1let unusable: void = undefined; Null 和 UndefinedTypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大： 123// Not much else we can assign to these variables!let u: undefined = undefined;let n: null = null; 默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。 Nevernever类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。 never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。 下面是一些返回never类型的函数： 123456789101112131415// 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message);&#125;// 推断的返回值类型为neverfunction fail() &#123; return error(&quot;Something failed&quot;);&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; Objectobject表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。 使用object类型，就可以更好的表示像Object.create这样的API。例如： 123456789declare function create(o: object | null): void;create(&#123; prop: 0 &#125;); // OKcreate(null); // OKcreate(42); // Errorcreate(&quot;string&quot;); // Errorcreate(false); // Errorcreate(undefined); // Error]]></content>
      <categories>
        <category>TS</category>
      </categories>
      <tags>
        <tag>TS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode：罗马数字转整数]]></title>
    <url>%2F2019%2F12%2F06%2F%E7%AE%97%E6%B3%95%2FLeetCode%EF%BC%9A%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 测试用例123451. &quot;III&quot; // 32. &quot;IV&quot; // 43. &quot;IX&quot; // 94. &quot;LVIII&quot; // 58 解释: L = 50, V= 5, III = 35. &quot;MCMXCIV&quot; // 1994 解释:M = 1000, CM = 900, XC = 90, IV = 4 解法思路 根据题目中的所有情况写出哈希表 先匹配特殊情况，由于是匹配两个字符串，所以应考虑到最后一个字符串没有下一个的情况，所以先判断是否到最后了 若匹配，直接加，并使指针跳过这两个字符串 若不匹配，则直接得出该字符串的值，指针正常指向下一个 算法12345678910111213141516171819202122232425262728293031/** * @param &#123;string&#125; s * @return &#123;number&#125; */var romanToInt = function(s) &#123; var map = &#123; I: 1, IV: 4, V: 5, IX: 9, X: 10, XL: 40, L: 50, XC: 90, C: 100, CD: 400, D: 500, CM: 900, M: 1000 &#125; var res = 0; for(let i=0;i&lt;s.length;i++) &#123; if(i+1 &lt; s.length &amp;&amp; map[s.substr(i,2)]) &#123; res += map[s.substr(i,2)]; i++; &#125; else &#123; res += map[s.substr(i,1)]; &#125; &#125; return res;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode：有效的括号]]></title>
    <url>%2F2019%2F12%2F06%2F%E7%AE%97%E6%B3%95%2FLeetCode%EF%BC%9A%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[题目给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 测试用例123451. &quot;()&quot; // true2. &quot;()[]&#123;&#125;&quot; // true3. &quot;(]&quot; // false4. &quot;([)]&quot; // false5. &quot;&#123;[]&#125;&quot; // true 解法一思路 使用字符串的replace方法进行匹配替换，直到全部匹配成功，字符串长度为0，返回true 或直到没有相匹配的项，匹配前的字符串与匹配后的字符串相等，则返回false 算法12345678910111213141516171819/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isValid = function(s) &#123; if(s.length === 0) &#123; return true; &#125; while(s.length !== 0) &#123; var temp = s; s = s.replace(&apos;()&apos;,&apos;&apos;); s = s.replace(&apos;[]&apos;,&apos;&apos;); s = s.replace(&apos;&#123;&#125;&apos;,&apos;&apos;); if(s === temp) &#123; return false; &#125; &#125; return true;&#125;; 解法二思路 构造哈希表，遍历字符串 对于左括号，把相应的右括号放进栈里 对于右括号，若与栈顶匹配，则把栈顶去除；若是不匹配，则往栈顶添加undefined，为了防止开头就是右括号的情况 算法1234567891011121314151617181920/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isValid = function(s) &#123; var map = &#123; &apos;(&apos;: &apos;)&apos;, &apos;[&apos;: &apos;]&apos;, &apos;&#123;&apos;: &apos;&#125;&apos; &#125; var stack = []; for(let i in s) &#123; if(s[i] !== stack[stack.length-1]) &#123; stack.push(map[s[i]]) &#125; else &#123; stack.pop(); &#125; &#125; return stack.length === 0 ? true : false;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：等宽的三栏布局]]></title>
    <url>%2F2019%2F12%2F05%2FCSS%2FCSS%EF%BC%9A%E7%AD%89%E5%AE%BD%E7%9A%84%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[12345&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt; float1234567891011121314151617.box &#123; width: 100%; height: 200px; background: black;&#125;.left, .center, .right &#123; width: 33.33%; height: 100%; float: left; background: #FFA54F;&#125;.center &#123; background: #FFA500;&#125;.right&#123; background: #FFA07A;&#125; flex1234567891011121314151617.box &#123; width: 100%; height: 200px; background: black; display: flex;&#125;.left, .center, .right &#123; width: 33.33%; height: 100%; background: #FFA54F;&#125;.center &#123; background: #FFA500;&#125;.right&#123; background: #FFA07A;&#125; table123456789101112131415161718.box &#123; width: 100%; height: 200px; background: black; display: table;&#125;.left, .center, .right &#123; display: table-cell; width: 33.33%; height: 100%; background: #FFA54F;&#125;.center &#123; background: #FFA500;&#125;.right&#123; background: #FFA07A;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：字符串常用的方法]]></title>
    <url>%2F2019%2F12%2F04%2FJS%2FJS%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[charAt(index) 1返回指定索引的字符。 charCodeAt(index) 1返回指定索引的unicode字符. indexOf(char) 1判断一个字符第一次出现在某个字符串的索引，如果包含返回它的索引，如果不包含返回-1。对大小写敏感。 lastIndexOf(char) 1判断一个字符最后一次出现在某个字符串的索引，如果包含返回它的索引，如果不包含返回-1。 concat() (返回一个新字符串) 123456拼接2个字符串，返回一个新字符串，对原有字符串没有任何改变。var str=&apos;qwe&apos;;var str1=&apos;abc&apos;;var str2=str.concat(str1);console.log(str2);//&quot;qweabc&quot; substr(start,number) (不修改原字符串) 1从索引start开始，截取number个字符，将截取的字符返回。start可正可负。 substring(start,end) (不修改原字符串) 1从索引start开始，截取到索引end,不包括end.将截取的字符返回。start,end正值。 slice(start,end) (不修改原字符串) 1从索引start开始，截取到索引end,不包括end。将截取的字符返回。start,end可正可负。 split(“分割符”[,limit]) (返回数组，不修改原字符串) 1用指定字符分割字符串，返回一个数组。默认每个字符都分割。 replace(reg,new) (不修改原字符串) 12345替换指定字符，返回替换后新的字符串，不会对原有字符串有改变。var str=&apos;aaaaee&apos;;var reg=/a/g;str.replace(reg,1); //&quot;1111ee&quot;console.log(str); //&quot;aaaaee&quot; match(reg) (返回一个数组) 1可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。把符合正则表达式的字符放在数组里，返回一个数组。 search(reg) 1方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。返回第一个匹配字符串的第一个字符的位置。没有匹配的则返回-1。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：递归和非递归实现中序遍历]]></title>
    <url>%2F2019%2F12%2F02%2FJS%2FJS%EF%BC%9A%E9%80%92%E5%BD%92%E5%92%8C%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树结构1234567891011121314151617181920212223var TreeNode = &#123; val: 1, left: &#123; val: 2, left: &#123; val: 4, &#125;, right: &#123; val: 5 &#125; &#125;, right: &#123; val: 3, left: &#123; val: 6, &#125;, right: &#123; val: 7 &#125; &#125;&#125;;// 中序遍历，左根右// [4, 2, 5, 1, 6, 3, 7] 递归12345678function inOrderRecur (root，list=[]) &#123; if(root !== undefined) &#123; inOrderRecur(root.left,list); list.push(root.val); inOrderRecur(root.right,list); &#125; return list;&#125; 非递归123456789101112131415161718function inOrderUnRecur (root)&#123; var stack = []; var list = []; var head = root; while(stack.length !== 0 || head !== undefined)&#123; while(head !== undefined)&#123; stack.push(head); head = head.left; &#125; if(stack.length !== 0)&#123; head = stack.pop(); list.push(head.val); head = head.right; &#125; &#125; return list;&#125;;]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue：数据双向绑定原理]]></title>
    <url>%2F2019%2F11%2F17%2FVue%2FVue%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()（相当于observer）来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 observer：遍历data中的属性，使用Object.defineProperty()的get/set方法对其进行数据劫持。 dep：每个属性拥有自己的消息订阅器dep，用于存放所有订阅了该属性的观察者对象。 watcher：观察者（对象），通过dep实现对响应属性的监听，监听到结果后，主动触发自己的回调进行响应。 要对数据进行劫持监听，我们需要设置数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并发布通知（给dep）。 因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。 接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数。 当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。 拓展Object.defineProperty12345//在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。Object.defineProperty(obj, prop, descriptor)//obj 要在其上定义属性的对象。//prop 要定义或修改的属性的名称。//descriptor 将被定义或修改的属性描述符。 object.defineproperty()缺点 无法监听数组的变化（把对象属性换成数组就无法监听） 只能劫持对象的属性，不能劫持完整的对象（若对象属性为一个对象，则无法深度遍历劫持） 计算属性计算属性computed：一个属性通过其他属性计算而来 侦听器就是检测某一属性是否发生变化，一旦发生变化，我们就可以在侦听器里面写一下业务逻辑]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网：cdn]]></title>
    <url>%2F2019%2F11%2F16%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9Acdn%2F</url>
    <content type="text"><![CDATA[是什么内容分发网络。使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。 cdn缓存用户浏览器和服务器端之间加入cdn 用户在浏览网站的时候，向服务器请求到资源后，cdn会在本地保存网站中的图片或者js、css等其他文件的副本，通过http响应头中的cache-control字段设置数据缓存时间，这样用户再次访问该网站的时候，浏览器就不用再下载全部的文件，减少了下载量意味着提高了页面加载的速度。 再次浏览网站时，客户端浏览器会先向CDN边缘节点发起请求，CDN边缘节点会检测用户请求数据的缓存是否过期，如果没有过期，则直接响应用户请求，此时一个http请求结束；如果数据已经过期，那么CDN还需要向源站发出回源请求,来拉取最新的数据。]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git：git fetch和git pull]]></title>
    <url>%2F2019%2F11%2F13%2FGit%2FGit%EF%BC%9Agit%20fetch%E5%92%8Cgit%20pull%2F</url>
    <content type="text"><![CDATA[git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。 git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue：MVVM、MVC、MVP]]></title>
    <url>%2F2019%2F11%2F08%2FVue%2FVue%EF%BC%9AMVVM%E3%80%81MVC%E3%80%81MVP%2F</url>
    <content type="text"><![CDATA[MVCM代表Model，代表数据模型。 V代表View，代表视图。 C代表Controller，代表控制器，用来处理数据。 工作模式用户操作视图View，当数据改变时，传到Controller进行数据的处理，继而更新到Model，Model的更新会通过观察者模式通知View，View通过观察者模式收到Model变更的消息后，向Model请求最新的数据，自己同步更新视图。 优点观察者模式可以做到多视图同时更新。 缺点 controller测试困难。 view无法组件化，它强依赖特定的Model，不同程序的Model不一样。 MVPM代表Model，代表数据模型。 V代表View，代表视图。 P代表Presenter，代表呈现。 工作模式用户操作视图View，当数据改变时，传到Presenter进行数据的处理，继而更新到Model，Model的更新会通过观察者模式通知Presenter，Presenter获取到Model变更的消息后，通过View提供的接口更新界面。 和MVC的不同M和V是隔离的。 优点 便于测试。 可以组件化缺点由于需要大量的手动同步View和Model，导致维护起来很困难。 MVVMvue和angular都为mvvm框架 M代表Model，代表数据模型，可以在Model中定义数据修改和操作的业务逻辑。 V代表View，代表视图，它负责将数据模型转化成UI展现出来。 VM代表ViewModel，负责监听模型数据的改变和控制视图行为、处理用户交互。简单理解就是一个同步View和Model的对象，连接View和Model。 MVVM是以双向数据传输为思想的。ViewModel通过双向数据绑定把View和Model连接起来，View数据的变化会同步到Model中，而Model数据的变化也会立即反映到View上。 优点解决MVP大量的手动同步View和Model的问题，提供双向绑定机制。 缺点 过于简单的图形界面不适用。 没法断点debug，数据绑定的声明是指令式地写在View的模板当中的。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：一些关于date的获取方法]]></title>
    <url>%2F2019%2F10%2F11%2FJS%2FJS%EF%BC%9A%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8Edate%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[获知一个月的第一天是星期几123456789101112// 当月// 先获取第一天的时间戳var first = new Date().setDate(1); // 再通过getDay()获取var week = new Date(first).getDay();// 下个月// 先获取年份var year = new Date().getFullYear();// 获取下个月的月份var month = new Date().getMonth() + 2;var week = new Date(year, month-1, 1).getDay(); 获知一个月有多少天123456// 当月,下个月同理// 先获取年份var year = new Date().getFullYear();// 获取月份var month = new Date().getMonth() + 1;var total = new Date(year, month, 0).getDate();]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：不同类型之间的比较与运算]]></title>
    <url>%2F2019%2F09%2F26%2FJS%2FJS%EF%BC%9A%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E8%BE%83%E4%B8%8E%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[1234561. 5+&apos;5&apos; // &apos;55&apos;2. 5-true // 43. 5-&apos;2&apos; // 34. &apos;21&apos;&gt;3 // true5. null===undefined // false6. NaN===NaN // false 无论字符串与什么做+运算，最终结果都是拼接而成的字符串 无论数字与什么做-运算，另一方都会被转换成数字进行运算，结果仍为数字 字符串与数字做比较时总会把字符串转换为数字进行比较，当字符串无法转换为数字时，结果总为false ===会进行类型比较，不会进行转换，其余比较均会]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：防抖和节流]]></title>
    <url>%2F2019%2F09%2F25%2FJS%2FJS%EF%BC%9A%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[优化高频率执行js代码 防抖在事件被触发后的某个时间限制内，事件处理函数只执行一次。 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 应用场景：搜索框搜索输入，最后一次输入完再发送请求；手机号、邮箱验证输入检测。 12345678910111213141516function debounce(fn,delay)&#123; var timer; return function()&#123; var _this = this; //取debounce执行作用域的this var args = arguments;//获取传入闭包函数中的参数 //以上两句为了debounce函数最终返回的函数this指向不变（否则指向全局）和依然可以获取参数。 //因为fn有可能需要传参 if(timer)&#123; //当前正在一个计时过程中，又触发相同事件，所以取消计时，重新计时 clearTimeout(timer); &#125; timer = setTimeout(function()&#123; fn.apply(_this,args); //把回调函数应用在这些对象上 &#125;,delay); &#125;;&#125; 缺点：若不断触发同一事件会导致回调函数无法执行 节流每隔一段时间，只执行一次函数 如果短时间内大量触发同一事件，那么函数在执行一次后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。 与防抖相比，多了防止不断触发同一事件而导致不执行回调函数的情况。 应用场景：滚动加载，加载更多或滚到底部监听 123456789101112131415161718192021222324252627282930//第一种：定时器function throttle(fn,delay)&#123; var timer; return function()&#123; var _this = this; var args = arguments; if(timer)&#123; return; &#125; timer = setTimeout(function()&#123; fn.apply(_this,args); timer = null; //在delay后执行完fn后把timer清空 &#125;,delay); &#125;;&#125;//第二种：时间戳function throttle(fn,delay)&#123; var previous = 0; return function()&#123; var _this = this; var args = arguments; var now = new Date(); //若时间差大于间隔时间，就执行回调函数，并更新上一次执行时间 if(now - previous &gt; delay)&#123; fn.apply(_this,args); previous = now; &#125; &#125;&#125; 相同点 都可以使用setTimeout实现 目的都是降低回调执行频率，节省计算资源 不同点 防抖，在一段连续操作结束后，处理回调函数。 节流，在一段连续操作中，每隔一段时间只执行一次回调函数。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git：关于回退版本的一些小技巧]]></title>
    <url>%2F2019%2F08%2F27%2FGit%2FGit%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%9B%9E%E9%80%80%E7%89%88%E6%9C%AC%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[先通过 git log 查看某次提交的id 使用git reset –hard [id] 回退到某一次提交 若不想保留原来的提交记录，可把原来的分支删除 1git push origin --delete [branchName] 再把本地的修改提交到新的分支 版本回退仅仅是本地版本回退]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：position]]></title>
    <url>%2F2019%2F08%2F19%2FCSS%2FCSS%EF%BC%9Aposition%2F</url>
    <content type="text"><![CDATA[position:static没有定位，元素出现在正常的文档流中，忽略left、right、top、bottom和z-index。 position:fixed相对于浏览器窗口定位，即浏览器窗口滚动也不会影响元素位置，元素的位置与文档流无关，因此不占据空间，可能与其他元素发生重叠。 一定要设置宽度 position:relative 相对于元素自身正常位置定位，元素在正常的文档流中占位。 当设置margin或padding属性时，该对象在标准文档流中的占位空间也随之改变。 position:absolute 元素绝对定位，相对于static定位以外的第一个父元素，若无符合要求的父元素则相对于body，元素脱离文档流。 必须指定left、right、top、bottom中的至少一个，否则left，top值与原文档流位置一致，即跟当它static时的位置一样，margin和padding仍能影响其的位置，但脱离文档流，不占据位置，和其他元素形成折叠。 如果top、bottom都未指定，则其顶端将与原文档流位置一致，即垂直保持位置不变。 绝对定位对象在可视区域之外会导致滚动条出现，相对定位则不会 绝对定位对象头部超过可视区域会被裁掉。 position:inherit规定应该从父元素继承 position 属性的值。 z-index 如果两个同级元素的此属性具有同样的值，那么将依据它们在HTML文档中流的顺序层叠，写在后面的将会覆盖前面的。 需要注意的是，父子关系是无法用z-index来设定上下关系的，一定是子级在上父级在下。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：判断一个空对象或空数组]]></title>
    <url>%2F2019%2F07%2F29%2FJS%2FJS%EF%BC%9A%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%88%96%E7%A9%BA%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[判断一个空对象1234567function isEmptyObject(obj)&#123; if(JSON.stringify(obj) == &quot;&#123;&#125;&quot;)&#123; console.log(&quot;是空对象&quot;); &#125;else&#123; console.log(&quot;不是空对象&quot;); &#125;&#125; 判断一个空数组1234567function isEmptyArray(arr)&#123; if(JSON.stringify(srr) == &quot;[]&quot;)&#123; console.log(&quot;是空数组&quot;); &#125;else&#123; console.log(&quot;不是空数组&quot;); &#125;&#125; 1234567function isEmptyArray(arr)&#123; if(arr == false)&#123; console.log(&quot;是空数组&quot;); &#125;else&#123; console.log(&quot;不是空数组&quot;); &#125;&#125; 1234567function isEmptyArray(arr)&#123; if(arr.length == 0)&#123; console.log(&quot;是空数组&quot;); &#125;else&#123; console.log(&quot;不是空数组&quot;); &#125;&#125; 拓展：判断数组12341. Array.isArray(arr)2. arr instanceof Array3. object.prototype.toString.call(arr) === &apos;[object Array]&apos;4. arr.constructor === Array]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue：移动端适配]]></title>
    <url>%2F2019%2F07%2F29%2FVue%2FVue%EF%BC%9A%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[lib-flexible原理 在页面中引入flexible.js后，flexible会在html标签上增加一个data-dpr属性和font-size样式。 js首先会获取设备型号和对应的dpr，然后根据不同设备添加不同的data-dpr值，比如说1、2或者3，从源码中我们可以看到。 vue中适配通过npm下载1npm i lib-flexible --save 在main.js中引入 1import &apos;lib-flexible/flexible&apos; 把视觉稿中的px转换成remFlexible会将视觉稿分成100份（主要为了以后能更好的兼容vh和vw），而每一份被称为一个单位a。同时1rem单位被认定为10a。 px2rem-loader在build文件中找到util.js，将px2rem-loader添加到cssLoaders中，将下面代码加进cssLoaders方法中 123456const px2remLoader = &#123; loader: &apos;px2rem-loader&apos;, options: &#123; remUint: 75 &#125;&#125; 同时，对generateLoaders方法进行修改 1const loaders = options.usePostCSS ? [cssLoader, postcssLoader,px2remLoader] : [cssLoader,px2remLoader] fastclick为了检测是否为双击，从点击屏幕上的元素到触发元素的 click 事件，移动浏览器会有大约 300 毫秒的等待时间。 解决引入fastclick第三方库，其实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后真正的click事件阻止掉。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些调试小技巧]]></title>
    <url>%2F2019%2F07%2F29%2F%E5%89%8D%E7%AB%AF%2F%E4%B8%80%E4%BA%9B%E8%B0%83%E8%AF%95%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[一些常用的快捷键 快捷键 功能 ctrl + o 搜索文件 ctrl + shift + F 在所有文件中搜索特定的文字 ctrl + shift + o 在某个文件中搜索特定的文字 ctrl + G 跳转到某一行 ctrl + L 清除控制台的信息 ctrl + [ / ctrl + ] 标签切换 ctrl + shift + c 审查元素 shift + Enter / sources -&gt; snippets 在控制台编写多行代码 选中，H 显示/隐藏元素 一些常用的功能 通过js代码来设置断点：debugger，或者直接在sources中打断点，查看堆栈，了解函数调用情况 elements的event listeners中可以查看元素事件监听器 选中元素，右击Break on.. -&gt; Attributes Modifications，元素改变时启动断点 开发者工具打开的情况下右击chrome的刷新按钮，可清除缓存并硬重载]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node：REPL(交互式解释器)]]></title>
    <url>%2F2019%2F06%2F05%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%2FNode%2FNode%EF%BC%9AREPL(%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%99%A8)%2F</url>
    <content type="text"><![CDATA[概述Node.js REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。 作用Node 自带了交互式解释器，可以执行以下任务： 读取：读取用户输入，解析输入了Javascript 数据结构并存储在内存中。 执行：执行输入的数据结构 打印：输出结果 循环：循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。 Node 的交互式解释器可以很好的调试 Javascript 代码。 实现启动12$ node &gt; // 可以输入要执行的代码 简单的表达式运算可以执行简单的数学运算12345678910$ node&gt; 1+12&gt; 2*36&gt; 4/22&gt; 5-14&gt; 变量使用 可以将数据存储在变量中，并在需要的时候使用它 变量声明需要使用 var 关键字，如果没有使用 var 关键字变量会直接打印出来 使用 var 关键字的变量可以使用 console.log() 来输出变量 可以使用下划线(_)获取上一个表达式的运算结果 12345678910111213141516171819$ node&gt; x = 10 // 直接打印变量10 &gt; var y = 10 // 存储变量undefined &gt; x + y // 进行简单的数学运算20&gt; var pre = _ // 获取上一个变量并存储undefined &gt; console.log(pre) // 打印存储的变量20undefined&gt; console.log(y) // 打印存储的变量10undefined&gt; console.log(&quot;ok&quot;) // 打印字符串okundefined&gt; 多行表达式Node REPL 支持输入多行表达式，这就有点类似 JavaScript。 123456789101112$ node&gt; var x = 0undefined&gt; do &#123; // 执行一个 do-while 循环... x++;... console.log(&quot;x = &quot; + x)... &#125; while ( x &lt; 3 );x = 1x = 2x = 3undefined&gt; REPL命令 ctrl + c：退出当前终端。 ctrl + c 按下两次：退出 Node REPL。 ctrl + d：退出 Node REPL. 向上/向下键：查看输入的历史命令 tab 键：列出当前命令 .help：列出使用命令 .break：退出多行表达式 .clear：退出多行表达式 .save filename： 保存当前的 Node REPL 会话到指定文件 .load filename： 载入当前 Node REPL 会话的文件内容。 退出 REPL按下 ctrl + d 键 或 者两次 ctrl + c 键就能退出 REPL]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node：回调函数]]></title>
    <url>%2F2019%2F06%2F05%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%2FNode%2FNode%EF%BC%9A%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[概述 Node.js 异步编程的直接体现就是回调 异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了 回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数 回调函数一般作为函数的最后一个参数出现 阻塞代码实例创建一个文件 input.txt ，内容如下：1hello world 创建 block.js 文件, 代码如下： 1234var fs = require(&quot;fs&quot;);var data = fs.readFileSync(&apos;input.txt&apos;);console.log(data.toString());console.log(&quot;程序执行结束!&quot;); 执行js文件 1234$ node block.jshello world程序执行结束!// 顺序执行 在文件读取完后才执行完程序 非阻塞代码实例创建 unblock.js 文件, 代码如下： 123456var fs = require(&quot;fs&quot;);var data = fs.readFile(&apos;input.txt&apos;,function(err,data)&#123; if(err) return console.error(err); console.log(data.toString());&#125;);console.log(&quot;程序执行结束!&quot;); 执行js文件 123$ node unblock.js程序执行结束!hello world 一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作，大大提高了 Node.js 的性能，可以处理大量的并发请求。]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node：首次接触]]></title>
    <url>%2F2019%2F06%2F05%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%2FNode%2FNode%EF%BC%9A%E9%A6%96%E6%AC%A1%E6%8E%A5%E8%A7%A6%2F</url>
    <content type="text"><![CDATA[下载先下载node，查看node的版本 1node -v 初体验hello.js1console.log(&quot;hello world!&quot;); 使用node在根目录下运行12$ node hello.jshello world! 交互模式（详情见REPL）可以输入一条代码语句后立即执行并显示结果123$ node&gt; console.log(&quot;ok&quot;);ok 创建应用 引入 required 模块：我们可以使用 require 指令来载入 Node.js 模块。 创建服务器：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。 接收请求与响应请求：服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。 引入 required 模块1var http = require(&quot;http&quot;); 创建服务器使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据 123456789101112131415var http = require(&quot;http&quot;);http.createServer(function(request,response)&#123; // 发送HTTP头部 // HTTP状态值：200：OK // 内容类型：text/plain response.wirteHead(200,&#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;); //发送响应数据 “hello world” response.end(&apos;hello world\n&apos;);&#125;).listen(8888);//终端打印以下信息console.log(&apos;Server running at http://127.0.0.1:8888/&apos;); 执行12$ node server.jsServer running at http://127.0.0.1:8888/ 接下来，打开浏览器访问 http://127.0.0.1:8888/即可 分析 第一行请求（require）Node.js 自带的 http 模块，并且把它赋值给 http 变量。 接下来我们调用 http 模块提供的函数： createServer 。这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：模块化]]></title>
    <url>%2F2019%2F05%2F30%2FCSS%2FCSS%EF%BC%9A%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[文件结构常见文件结构一个项目的CSS最基本结构通常是下面这样的： base.css common.css pages.css 复杂一点的项目可能是这样分： base.css header.css footer.css sidebar.css forms.css icons.css buttons.css dropdown.css modals.css layout.css index.css user.css admin.css pages.css 如果后期不打算合并CSS的，建议尽可能减少 CSS 文件的数量。 SMACSSSMACSS 的全称叫 Scalable and Modular Architecture for CSS。即可扩展和模块化的CSS架构。 SMACSS将样式分成5种类型：Base，Layout，Module，State，Theme Base: 基础样式表，定义了基本的样式，我们平时写CSS比如reset.css就是属于基础样式表，另外我认为清除浮动，一些动画也可以归类为基础样式。 Layout: 布局样式，用于实现网页的基本布局，搭起整个网页的基本骨架。 Module: 网页中不同的区域有这个不同的功能，这些功能是相对独立的，我们可以称其为模块。模块是独立的，可重用的组件，它们不依赖于布局组件，可以安全的删除修改而不影响其他模块。 State: 状态样式，通常和js一起配合使用，表示某个组件或功能不同的状态，比如菜单选中状态，按钮不可用状态等。 Theme: 主题皮肤，对于可更换皮肤的站点来说，这个是很有必要的，分离了结构和皮肤，根据不同的皮肤应用不同的样式文件。 css选择器命名规则它的每一条规则都是全局的，在 CSS 预处理出现之前，这很容易造成命名上的冲突。 当涉及到多人维护同一段 CSS 代码时，命名的意义表达，也会影响到维护效率。 使用独一无二的规则。命名唯一。 使用简短的命名。 嵌套层级不宜过深，建议控制在3层以内。 BEMBEM是Block，Element，Modifier的缩写。是比较流行的一种 CSS 命名方式。 Block：在BEM的理论中，一个网页是由block组成的，比如头部是个block，内容是block，logo也是block，一个block可能由几个子block组成。 Element：element是block的一部分，具有某种功能，element依赖于block，比如在logo中，img是logo的一个element，在菜单中，菜单项是菜单的一个element Modifier：modifier是用来修饰block或者element的，它表示block或者element在外观或行为上的改变 123456789命名规则如下：.block &#123;&#125;.block__element &#123;&#125;.block--modifier &#123;&#125;例如：.login &#123;&#125;.login__btn &#123;&#125;.login__btn--reset &#123;&#125;.login__btn--confirm &#123;&#125; 下划线（__）被用来区分元素，而用连字符(–)是用来修饰元素的。 SUITSuit起源于BEM，但是它对组件名使用驼峰式和连字号把组件从他们的修饰和子孙后代中区分出来.]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-cli脚手架]]></title>
    <url>%2F2019%2F05%2F21%2FVue%2FVue-cli%E8%84%9A%E6%89%8B%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[vue-cli介绍Vue-cli是Vue的脚手架工具 脚手架：在工地上，是帮助工人们作业的搭建好的架子；在技术上，是编写好基础代码的工具。 安装环境查看版本（具体安装方法百度很多） 123$ node -v$ npm -v$ cnpm -v vue-cli 1.x或2.x全局安装12$ npm install -g vue-cli$ cnpm install -g vue-cli //国内镜像安装，较快 若安装失败，则先清理缓存，再重新安装 查看版本 1$ vue -V 生成项目生成项目文件夹1$ vue init &lt;template-name&gt; &lt;project-name&gt; 输入命令后，会跳出几个选项让你回答： Project name (baoge)：项目名称，直接回车，按照括号中默认名字（注意这里的名字不能有大写字母，如果有会报错Sorry, name can no longer contain capital letters），阮一峰老师博客为什么文件名要小写 ，可以参考一下。 Project description (A Vue.js project)：项目描述，也可直接点击回车，使用默认名字 Author ()： 作者，输入你的大名 接下来会让用户选择： Runtime + Compiler: recommended for most users运行加编译，既然已经说了推荐，就选它了 Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specificHTML) are ONLY allowed in .vue files - render functions are required elsewhere仅运行时，已经有推荐了就选择第一个了 Install vue-router? (Y/n)是否安装vue-router，这是官方的路由，大多数情况下都使用，这里就输入“y”后回车即可。 Use ESLint to lint your code? (Y/n)是否使用ESLint管理代码，ESLint是个代码风格管理工具，是用来统一代码风格的，一般项目中都会使用。 接下来也是选择题Pick an ESLint preset (Use arrow keys) 选择一个ESLint预设，编写vue项目时的代码风格，直接y回车 Setup unit tests with Karma + Mocha? (Y/n)是否安装单元测试，我选择安装y回车 Setup e2e tests with Nightwatch(Y/n)?是否安装e2e测试 ，我选择安装y回车 一般一路回车就好了 Official Templates webpack（常用） webpack-simplae browaerify browserify-simple simple 自定义 运行 （在项目文件目录下运行）1$ cnpm install 1$ npm run dev 项目文件介绍 build和config文件夹：webpack配置相关 node_modules文件夹：npm install安装的依赖代码库 src文件夹：存放项目源码 static文件夹：存放第三方静态资源 .babelrc文件：babel的配置（大多数浏览器不能直接支持ES6，则需通过babel编译成ES5） .editorconfig文件：编译器的配置 .eslintignore文件：忽略语法检查的目录文件（忽略对build和config进行ES6语法检查） .eslintrc.js：eslint的配置文件 .gitignore文件：使git仓库忽略里边的文件或者目录 index.html：编译过程中会自动插入到这个html中 package.json：项目的配置文件 README.md：项目的描述文件 运行 创建组件 创建一个.vue对象，由三部分组成：template、script、style，其中在script中使用export default导出一个对象（里面为组件的各种选项、属性） 使用组件 打包上线 1$ npm run build 所遇到的坑 使用vue安装项目文件后，若提示版本过低，则需把node、npm、cnpm全部升级到最新版本 命令cnpm install需要在==项目文件目录下==运行，若还运行不了，再找其他原因 vue-cli 3.0]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：new一个函数发生了什么]]></title>
    <url>%2F2019%2F04%2F25%2FJS%2FJS%EF%BC%9Anew%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[创建一个新对象； 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）。 执行构造函数中的代码（为这个新对象添加属性）； 返回新对象。 12345678var obj = new O();var obj = (function()&#123; var obj = &#123;&#125;; //使新对象的__proto__属性指向构造函数的prototype obj.__proto__= O.prototype; //其他赋值语句 return obj;&#125;)();]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器兼容问题]]></title>
    <url>%2F2019%2F04%2F25%2F%E5%89%8D%E7%AB%AF%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[css不同浏览器的标签默认的margin和padding不同 12345//解决*&#123; padding:0; margin:0;&#125; 对于一些新特性，低版本浏览器不兼容，可以用渐进增强或优雅降级。 js阻止冒泡12345678function canclebubble(event)&#123; var event = event||window.event; //兼容火狐 if(event.stopPropagation)&#123; event.stopPropagation(); //标准浏览器 &#125;else&#123; event.cancaleBubble==true; //老ie &#125; &#125; 取消默认事件12345678function stopevent(event)&#123; var event = event||window.event; //兼容火狐 if(event.preventDefault)&#123; event.preventDefault(); //标准浏览器 &#125;else&#123; event.returnValue==false; //老ie &#125; &#125; 注意 event代表事件的状态，例如触发event对象的元素、鼠标的位置及状态、按下的键等等； event对象只在事件发生的过程中才有效。 firefox里的event跟IE里的不同，IE里的是全局变量，随时可用；firefox里的要用参数引导才能用，是运行时的临时变量。 在IE/Opera中是window.event，在Firefox中是event；而事件的对象，在IE中是window.event.srcElement，在Firefox中是event.target，Opera中两者都可用。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渐进增强和优雅降级]]></title>
    <url>%2F2019%2F04%2F25%2F%E5%89%8D%E7%AB%AF%2F%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E5%92%8C%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[渐进增强针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。123456.transition&#123; -webkit-transition: all .5s; -moz-transition: all .5s; -o-transition: all .5s; transition: all .5s; &#125; 优雅降级一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。123456.transition&#123; transition: all .5s; -o-transition: all .5s; -moz-transition: all .5s; -webkit-transition: all .5s;&#125; 区别 渐进增强观点认为应该关注于内容本身。 优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：如何找出单链表中的倒数第k个元素]]></title>
    <url>%2F2019%2F04%2F25%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E6%89%BE%E5%87%BA%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[首先遍历一遍单链表，求出整个单链表的长度n，然后将倒数第k个，转换为正数第n-k个，接下来遍历一次就可以得到结果。 优化：设置两个指针p1和p2，p1在p2前，两者相差k-1个节点，当p1指向null时，p2刚好指向目标元素。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：盒模型]]></title>
    <url>%2F2019%2F04%2F22%2FCSS%2FCSS%EF%BC%9A%E7%9B%92%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[标准模型12盒模型宽高 = margin + border + padding + content元素宽高（元素占据的位置） = content IE盒模型12盒模型宽高 = margin + 元素宽高元素宽高（元素占据的位置） = border + padding + content 修改盒模型（box-sizing）box-sizing content-box：默认属性，标准盒模型 border-box：使元素宽高包括padding和border，内容区的实际宽度会是元素宽高减去border + padding的计算值。（即IE盒模型）]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：==和===]]></title>
    <url>%2F2019%2F04%2F22%2FJS%2FJS%EF%BC%9A%3D%3D%E5%92%8C%3D%3D%3D%2F</url>
    <content type="text"><![CDATA[都是用来检测两个操作数是否相等 基础类型对于如string、number、null、undefined、boolean等基本数据类型==： 对于同一类型的比较，会直接进行值的比较。 对于不同类型的比较，会先进行类型转换，再进行值的比较。 如果一个是null，一个是undefined，那么相等。 如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较。 ===： 对于同一类型的比较，会直接进行值的比较。 对于不同类型的比较，结果一定是不相等。即不仅进行值的比较，还要进行类型的比较。 高级类型对于array、object等高级类型，\==和===是没有区别的，都是进行“指针地址”的比较。 基础类型和高级类型==： 将高级类型转换为基础类型，进行值的比较。 12console.log([66]==66); //trueconsole.log([66,1]==66); //false ===： 类型不同，结果一定为不相等。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：数组去重]]></title>
    <url>%2F2019%2F04%2F22%2FJS%2FJS%EF%BC%9A%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[ES5 123456789function unique(arr)&#123; var temp = []; for(var i = 0;i&lt;arr.length;i++)&#123; if(temp.indexOf(arr[i]==-1)&#123; temp.push(arr[i); &#125; &#125; return temp;&#125; 双层循环，外循环表示从0到arr.length，内循环表示从i+1到arr.length 将重复值中右侧的值去除，并将指针重新指向该位置 1234567891011function unique(arr)&#123; for(var i=0;i&lt;arr.length-1;i++)&#123; for(var j=i+1;j&lt;arr.length;j++)&#123; if(arr[i]==arr[j])&#123; arr.splice(j,1); j--; &#125; &#125; &#125; return arr;&#125; ES6 1234function unique(arr)&#123; var temp = [...new Set(arr)]; return temp;&#125;]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象的程序设计]]></title>
    <url>%2F2019%2F04%2F22%2FJS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[理解对象面向对象和面向过程 面向过程是分析出解决问题所需要的步骤，然后用函数把步骤一步一步实现，使用时一个一个依次调用就可以了。 面向对象是把构成问题事务分解为各个对象，建立对象的目的是为了描述某个事物在整个解决问题的步骤中的行为。概念（我讲得通俗一点） 类：js中没有类的概念，取了一个新的名字—原型对象 原型对象：把猫（人、狗…）的特性提取出来，形成猫类（人类、狗类…），这个即为原型对象，代表着一类事物 对象（实例）：猫类（人类、狗类…）中的A猫（A人、A狗…），即为对象实例，代表一个具体事物 对象的属性类型一般为基本数据类型，也可以是另外的对象 数据属性 访问器属性 其特性详见书中139，感觉不会常用 小结 在js中一切都是对象 原型对象其实也是对象 判断一个对象实例具体是什么类型用instanceof运算符（引用类型中有详讲） 面向对象三大要素：封装、继承、多态。 创建对象工厂模式（最古老）1234567891011这是一个能够根据接受的参数来构建一个包含所有必要信息的对象的函数function Person(name,age)&#123; var o=new Object(); //创建对象实例，但无法得知对象的类型 o.name=name; //添加属性 o.age=age; o.sayName=function()&#123; //添加方法 alert(this.name); &#125;; return o; //返回对象引用 &#125;var person1=Person(&quot;greg&quot;,27);//调用函数创建对象实例 构造函数模式12345678function Person(name,age)&#123; this.name=name; //实例属性 this.age=age; this.sayName=function()&#123; //实例方法（不同实例地址不一样） alert(this.name); &#125;;&#125;var person1=new Person(&quot;greg&quot;,27); 原型模式1234567891011121314151617function Person()&#123; &#125;Person.prototype=&#123; constructor:Person, //强制指向Person name:&quot;greg&quot;, //原型属性 friend:[&quot;blue&quot;,&quot;yellow&quot;], sayName:function()&#123; //原型方法（共享，地址一样） alert(this.name); &#125;&#125;;var person1=new Person();var person2=new Person();person1.name=&quot;Lee&quot;; //重写person1的名字alert(person1.name); //Leealert(person2.name); //Gregperson1.friend.push(&quot;black&quot;);alert(person1.friend); //blue，yellow,blackalert(person2.friend);//blue，yellow,black 小结： 属性的查找是先从实例中找，实例中没有该属性，便从原型中找 数组friend添加了一个项，是先从person1中找数组修改，由于没找到，所以顺着原型链找到原型中的数组并修改了 实例对象的proto指向，其构造函数的原型。构造函数的prototype获得构造函数的原型。构造函数原型的constructor指向对应的构造函数 组合使用构造函数模式和原型模式（最佳）构造函数模式定义实例属性原型模式定义方法和原型属性 123456789101112function Person(name,age)&#123; this.name=name; //实例属性 this.age=age;&#125;Person.prototype=&#123; constructor:Person, //原型属性（共享） sayName:function()&#123; //原型方法（共享） alert(this.name); &#125;&#125;;var person1=new Person(&quot;Greg&quot;,27);person1.sayName(); //&quot;Greg&quot; 动态原型模式123456789101112function Person(name,age)&#123; this.name=name; this.age=age; //仅在第一次调用时初始化 if(typeof this.sayName!=&quot;function&quot;)&#123; person.prototype.sayName=function()&#123; alert(this.name); //将原型方法封装在构造函数中 &#125;; &#125;&#125;var person1=new Person(&quot;Greg&quot;,27);person1.sayName(); //&quot;Greg&quot; 寄生构造函数模式（工厂模式+构造函数模式）123456789101112function Person(name,age)&#123; var o=new Object(); o.name=name; o.age=age; o.sayName=function()&#123; alert(this.name); &#125;; return o;&#125;var person1=new Person(&quot;Greg&quot;,27);person1.sayName();不能确定对象关系，不推荐使用 稳妥构造函数模式123456789101112function Person(name,age)&#123; var o=new Object(); //可以在这里定义*私有*属性和方法 o.sayName=function()&#123; alert(name); &#125;; return o;&#125;var person1=Person(&quot;Greg&quot;,27);person1.sayName();不引用this，不使用new操作符但除了sayName()方法没有别的方法访问原始数据，安全性很高 继承原型链继承123456789101112131415161718192021222324function Super()&#123; this.val=1; this.arr=[1];&#125;Super.prototype.getSuper=function()&#123; return true; //原型方法&#125;;function Sub()&#123; &#125;//继承Super，把Super的对象实例赋给Sub的原型Sub.prototype=new Super(); var sub1=new Sub();var sub2=new Sub();var super1=new Super();sub1.val=2;alert(sub1.val);//2alert(sub2.val);//1sub1.arr.push(2);alert(sub1.arr);//1,2alert(sub2.arr);//1,2Sub.prototype.getSuper=function()&#123; //重写方法 return false; &#125;;alert(sub1.getSuper());//false //调用重写后的方法alert(super1.getSuper());//true //调用原来的方法 小结： 重写方法或添加新方法需写在继承后 属性查找是先从对象实例中找，没有就顺着原型链继续向上查找 创建子类实例时，无法向父类构造函数传参 父类方法和属性得到复用，子类实例没有自己的属性 借用构造函数继承1234567891011121314function Super(val)&#123; this.val=val; this.arr=[1]; this.getSuper=function()&#123; &#125;;//方法在构造函数中，无法复用&#125;function Sub(val)&#123; Super.call(this,val); //继承Super，类似于对象冒充&#125;var sub1=new Sub(1);var sub2=new Sub(2);alert(sub1.val); //1alert(sub2.val); //2alert(sub1.getSuper==sub2.getSuper);//false每个子类实例都有新的方法地址，内存要爆炸了！！！ 小结：子类的每个实例都有自己的属性、方法，不会相互影响，但是占用内存。 组合继承（最常用）原型链：对原型属性和方法的继承借用构造函数：对实例属性的继承 12345678910111213141516function Super(val)&#123; this.val=val; this.arr=[1];&#125;Super.prototype.getSuper=function()&#123; return true; //原型方法&#125;;function Sub(val)&#123; Super.call(this,val); //继承Super&#125;Sub.prototype=new Super(); //继承Supervar sub1=new Sub(1);var sub2=new Sub(2);alert(sub1.val); //1alert(sub2.val); //2alert(sub1.getSuper==sub2.getSuper);//true 小结： 复用了方法，子类又有各自的属性。 因为父类构造函数被执行了两次，子类的原型对象(Sub.prototype)中也有一份父类的实例属性，而且这些属性会被子类实例的属性覆盖掉，也存在内存浪费。 原型式继承（类似于对象复制）创建新对象–&gt;返回该对象–&gt;增强（添加属性/方法） 1234567891011121314151617181920// 生孩子函数 beget：龙beget龙，凤beget凤//创建新的obj的对象实例function beget(obj)&#123; var F = function()&#123;&#125;; F.prototype = obj; return new F();&#125;function Super()&#123; this.val = 1; this.arr = [1];&#125;// 生孩子var sub = beget(new Super()); // 核心// 添加属性sub.attr1 = 1;sub.attr2 = 2;alert(sub.val); // 1alert(sub.arr); // 1alert(sub.attr1); // 1不像继承？ 寄生式继承创建新对象–&gt;增强–&gt;返回该对象 12345678910111213141516171819202122232425// 生孩子函数 beget：龙beget龙，凤beget凤。function beget(obj)&#123; var F = function()&#123;&#125;; F.prototype = obj; return new F();&#125;function Super()&#123; this.val = 1; this.arr = [1];&#125;function getSubObject(obj)&#123; // 创建新对象 var clone = beget(obj); // 核心 // 添加属性 clone.attr1 = 1; clone.attr2 = 2; return clone;&#125; var sub = getSubObject(new Super());alert(sub.val); // 1alert(sub.arr); // 1alert(sub.attr1); // 1给原型式继承穿个马甲？ 寄生组合式继承（最佳，但组合继承最常用）有缺陷的寄生式继承+不完美的组合继承 123456789101112131415161718192021222324// 生孩子函数 beget：龙beget龙，凤beget凤//创建新的obj的对象实例function beget(obj)&#123; var F = function()&#123;&#125;; F.prototype = obj; return new F();&#125;function Super()&#123; this.val = 1; this.arr = [1];&#125;// 在此处声明函数Super.prototype.getSuper = function()&#123;&#125;;function Sub()&#123; Super.call(this); // 继承&#125;//继承，把实例赋给Sub的原型var proto = beget(Super.prototype); proto.constructor = Sub; Sub.prototype = proto; var sub = new Sub();alert(sub.val); //1alert(sub.arr); //1 大总结：加油！棒棒哒！熬过这一章其余就轻松啦啦啦！已经写得尽可能详细了，多多复习！ ES6创建对象123456789101112class father &#123; constructor(name,age)&#123; this.name = name; this.age = age; &#125; //方法与方法之间不需要逗号分隔 run()&#123; console.log(&quot;ok&quot;); &#125;&#125;var ming = new father(&quot;ming&quot;,20);ming.run(); //okconsole.log(ming.name); //ming 继承123456789101112131415class son extends father &#123; constructor(name,age,sex)&#123; super(); //super方法要放在最前面 this.sex = sex; //添加新属性 &#125; run()&#123; //重写run方法 console.log(&quot;true&quot;); &#125; get()&#123; //添加新方法 &#125;&#125;var hong = new son(&quot;hong&quot;,2,&quot;女&quot;);hong.run(); //trueconsole.log(hong.sex); //女 单词不要拼错：constructor]]></content>
      <categories>
        <category>红宝书</category>
      </categories>
      <tags>
        <tag>红宝书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue：生命周期]]></title>
    <url>%2F2019%2F04%2F22%2FVue%2FVue%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[8个阶段创建前(beforeCreate)在数据观测和初始化事件还未开始时。 创建后(created)完成数据观测，属性和方法的运算，初始化事件，el属性还没有显示出来。 载入前(beforeMount)在挂载开始之前被调用，相关的render函数首次被调用。vue实例的el和data都初始化了，生成了html，但还没有挂载html到页面上。 载入后(mounted)vue实例挂载完成，html页面成功渲染。 更新前(beforeUpdate)在数据更新之前调用。 更新后(updated)调用时，组件DOM已经更新，可以执行依赖于DOM的操作。 销毁前(beforeDestroy)在实例销毁之前调用。实例仍然完全可用。 销毁后(destroy)在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。 相关问题什么是vue生命周期？答： Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。 vue生命周期的作用是什么？答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。 vue生命周期总共有几个阶段？答：它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后 第一次页面加载会触发哪几个钩子？答：第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子 DOM 渲染、挂载在哪个周期中就已经完成？答：DOM 渲染、挂载在 mounted 中就已经完成了。 vue能不能挂载到body或html标签上？提供的元素只能作为挂载点。不同于 Vue 1.x，所有的挂载元素会被 Vue 生成的 DOM 替换。因此不推荐挂载vue实例到html或者body标签上。 简单描述每个周期具体适合哪些场景？答：生命周期钩子的一些使用方法： beforecreate : 可以在这加个loading事件，在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构：树的深度遍历和广度遍历]]></title>
    <url>%2F2019%2F04%2F22%2F%E5%85%B6%E4%BB%96%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[普通树深度遍历先访问根结点，然后遍历左子树接着是遍历右子树。利用堆栈的先进后出。 广度遍历从根开始访问,按照根节点左右顺序访问.每次把同层节点左右孩子访问完毕.再访问下一层，所以用队列的先进先出实现。 二叉树前序遍历根 左 右 中序遍历左 根 右 后序遍历左 右 根]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网：DNS查询过程]]></title>
    <url>%2F2019%2F04%2F22%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9ADNS%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[迭代+递归 在DNS解析器缓存中查找某主机的ip地址 向其本地域名服务器进行递归查找。 本地域名服务器查不到，就向根域名服务器进行迭代查询。 根域名服务器告诉本地域名服务器，下一步该向顶级域名服务器查找。 本地域名服务器向顶级域名服务器查找。 顶级域名服务器告诉本地域名服务器，下一步该向权限域名服务器查找。 权限域名服务器返回目标主机的ip地址。 本地域名服务器就把ip地址告诉目标主机。]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题（一）]]></title>
    <url>%2F2019%2F04%2F21%2F%E7%AE%97%E6%B3%95%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 123456789101112131415var reverse = function(x) &#123; var arr = x.toString().split(&apos;&apos;); if(arr[0]==&apos;-&apos;)&#123; var temp = arr.slice(1,arr.length); temp.reverse().unshift(&quot;-&quot;); x = parseInt(temp.join(&apos;&apos;)); &#125;else&#123; x = parseInt(arr.reverse().join(&apos;&apos;)); &#125; if(x&gt;=-Math.pow(2,31)&amp;&amp;x&lt;=Math.pow(2,31))&#123; return x; &#125;else&#123; return 0; &#125;&#125;; 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。 123456789101112131415161718192021var longestCommonPrefix = function(strs) &#123; var str=&quot;&quot;; if(strs.length == 1)&#123; str = strs[0]; &#125;else if(strs.length &gt;= 2)&#123; for(var i=1;i&lt;=Math.min(strs[0].length,strs[1].length);i++)&#123; if(strs[0].slice(0,i)==strs[1].slice(0,i))&#123; str = strs[0].slice(0,i); continue; &#125;else&#123; break; &#125; &#125; for(var j=2;j&lt;strs.length;j++)&#123; while(str!=&quot;&quot;&amp;&amp;strs[j].substr(0,str.length)!=str)&#123; str = str.slice(0,str.length-1); &#125; &#125; &#125; return str;&#125;; 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。即先开的后闭合。 123&quot;([)]&quot; //false&quot;&#123;[]&#125;&quot; //true&quot;&quot; //true 注意空字符串可被认为是有效字符串。 123456789101112131415161718var isValid = function(s) &#123; var temp = []; for(var i in s)&#123; if(s[i]==&quot;(&quot;)&#123; temp.push(&quot;)&quot;); &#125;else if(s[i]==&quot;[&quot;)&#123; temp.push(&quot;]&quot;); &#125;else if(s[i]==&quot;&#123;&quot;)&#123; temp.push(&quot;&#125;&quot;); &#125;else if(s[i]!=temp.pop())&#123; return false; &#125; &#125; return !temp.length; //只开不闭temp.length为true //空字符串temp.length为false //其余有效字符串temp会被移除空&#125;; 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 12345678var searchInsert = function(nums, target) &#123; for(var i=0;i&lt;nums.length;i++)&#123; if(nums[i]&gt;=target)&#123; return i &#125; &#125; return nums.length;&#125;; 给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指由字母组成，但不包含任何空格的字符串。 123456789101112var lengthOfLastWord = function(s) &#123; var len = s.length; var count = 0; while(len!=0&amp;&amp;s[len-1]==&quot; &quot;)&#123; len--; &#125; while(s[len-1]!=&quot; &quot;&amp;&amp;len&gt;0)&#123; count++; len--; &#125; return count;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2019%2F04%2F18%2F%E5%89%8D%E7%AB%AF%2Fcanvas%2F</url>
    <content type="text"><![CDATA[Canvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等。 属性 height width 一个Canvas定义了一个指定尺寸的矩形框1&lt;canvas id=&quot;test-canvas&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt; 检测浏览器支持由于浏览器对HTML5标准支持不一致，所以，通常在canvas内部添加一些说明性HTML代码，如果浏览器支持Canvas，它将忽略canvas内部的HTML，如果浏览器不支持Canvas，它将显示canvas内部的HTML 123&lt;canvas id=&quot;test-stock&quot; width=&quot;300&quot; height=&quot;200&quot;&gt; &lt;p&gt;Current Price: 25.51&lt;/p&gt;&lt;/canvas&gt; 在使用Canvas前，还需要用canvas.getContext来测试浏览器是否支持Canvas 123456var canvas = document.getElementById(&apos;test-canvas&apos;);if (canvas.getContext) &#123; console.log(&apos;你的浏览器支持Canvas!&apos;);&#125; else &#123; console.log(&apos;你的浏览器不支持Canvas!&apos;);&#125; 方法canvas绘图以左上角的（0， 0）为基准原点1234let canvas = document.querySelector(&apos;#canvas&apos;); // 得到canvas//得到canvas上下文环境let ctx = canvas.getContext(&apos;2d&apos;)//绘制2d图形let gl = canvas.getContext(&quot;webgl&quot;);//绘制3d图形 绘制矩形ctx.rect(x,y,width,height); 创建矩形。 但并不会真正将矩形画出，只能调用stroke() 或 fill()后才会真正作用于画布。 先填充再描边。 可通过canvas.width或canvas.height获取画布的宽度和高度 ctx.fillRect(x,y,width,height) 执行填充操作，绘制一个已填色的、以(x,y)位置为起点、大小为width x height的矩形。 有填充颜色，默认为black。 ctx.fillStyle=””为图形设置填充颜色 ctx.strokeRect(x,y,width,height); 绘制一个不填色、以(x,y)位置为起点、大小为width x height的矩形。 有边框颜色，默认为black。 ctx.strokeStyle=””为图形设置边框颜色 ctx.clearRect(x,y,width,height); 将(x,y)位置大小为width x height的矩形变为透明。 Internet Explorer 9、Firefox、Opera、Chrome 以及 Safari 支持 clearRect() 方法。 若canvas设置了背景颜色是不能被清除的，因为那是画布的背景颜色，clearRect清除的是绘制的图形，使绘制的图形变为透明，显现出画布背景色。 绘制复杂形状ctx.lineWidth=x;设置线宽为x，不需要加px ctx.fill();填充图形，可利用fillStyle设置填充颜色 ctx.stroke();绘制图形，可利用strokeStyle设置边框颜色 ctx.beginPath();清除原来的痕迹,绘制图形之前要先调用 ctx.closePath();自动完成闭合 ctx.moveTo(x,y);从(x,y)点开始绘图 ctx.lineTo(x,y);绘图终点为(x,y) ctx.arc(x, y, r, 起始弧度， 终点弧度，是否逆时针) 圆心为(x,y),半径为r 弧度 = Math.PI*角度 设置完弧线，要用moveTo()进行绘制 绘制文本ctx.font = “24px 宋体”设置字体大小、型号 ctx.fillText(“文字内容”,left,top); 绘制实心文字。 left为距画布最左边距离，top为距画布最上边距离。 可通过fillStyke设置文字填充颜色 ctx.strokeText(“文字内容”,left,top); 绘制空心文字。 left与top同上。 可通过strokeStyle设置文字边框颜色。 设置文字阴影这些要在设置文字内容之前设置 ctx.shadowOffsetX = x; x轴偏移量，默认位于元素正下方。 ctx.shadowOffsetY = y; y轴偏移量，默认位于元素正下方。 ctx.shadowBlur = num; 设置模糊系数。默认为0不模糊。 ctx.shadowColor = “”; 设置阴影颜色，同时要设置shadowBlur，否则看不见 用canvas画出一个(0,0)坐标绿色的100x100矩形框，再从(10,10)坐标将50x50的区域变成透明 123456789&lt;canvas id=&quot;test&quot; width=&quot;100px&quot; height=&quot;100px&quot;&gt;&lt;/canvas&gt;&lt;script&gt;var canvas = document.getElementById(&quot;test&quot;);var ctx = canvas.getContext(&quot;2d&quot;);ctx.fillStyle = &quot;green&quot;;ctx.fillRect(0,0,100,100);ctx.clearRect(10,10,50,50);&lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：图片预加载和懒加载]]></title>
    <url>%2F2019%2F04%2F15%2FJS%2FJS%EF%BC%9A%E5%9B%BE%E7%89%87%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[页面加载过程如果页面不是第一次访问，那么可能会出现浏览器缓存现象，在本地调试代码的时候也会遇到这种问题，所以在实在想不通页面为什么没有变化的时候，可以清除一下浏览器的缓存。 如果页面是第一次访问，浏览器向服务器http请求后，服务器返回html文件，在整个页面加载过程中，总的来说是按顺序从上到下执行，这是基于js的单线程机制（浏览器为多进程），但是html和css是并行加载的。 根据 HTML 结构生成 DOM Tree 根据 CSS 生成 CSSOM 将 DOM 和 CSSOM 整合形成 RenderTree 根据 RenderTree 开始渲染和展示 遇到script标签时，会执行并阻塞渲染，因为 Javascript 代码有权利改变DOM树 在浏览器解析页面内容的时候，若页面引用了未加载的图片，就会发送请求获取资源。此时图片还没下载完全，在页面上并不会留下图片的位置，而html不会堵塞，将会继续执行下去。等到有图片请求下载完成，html又会重新渲染页面，将图片显示出来。 为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。 预加载 图片等静态资源在使用前提前请求。 资源后续使用可以直接从缓存中加载，提升用户体验。 预加载不是为了减少页面加载时间。 预加载只是提前加载除首轮加载的图片之外以后要用到的图片，比如通过点击等事件才会用到的图片。 css 123#preload-01 &#123; background: url(img1.png); &#125;#preload-02 &#123; background: url(img2.png); &#125;#preload-03 &#123; background: url(img3.png); &#125; 像上面那样写，预加载和页面上其他内容一起加载，还会加长页面的加载时间，用户在点进页面时，等待时间加长，并没有达到我们提高用户体验的目的，我们可以封装一个函数，推迟预加载时间，等页面加载完成后再预加载。123456789101112131415161718192021function preload()&#123; if(document.getElementById)&#123; document.getElementById(&quot;preload-01&quot;).style.background = &quot;url(img1.png)&quot;; document.getElementById(&quot;preload-02&quot;).style.background = &quot;url(img2.png)&quot;; document.getElementById(&quot;preload-03&quot;).style.background = &quot;url(img3.png)&quot;; &#125; &#125; function addLoadEvent(func)&#123; var oldonload = window.onload; if(type window.onload != &quot;function&quot;)&#123; window.onload = func; &#125;else&#123; window.onload = function()&#123; if(oldonload)&#123; oldonload(); &#125; func(); &#125; &#125; &#125; addLoadEvent(preload); 懒加载 仅显示可视区的图片资源，不可见区域的资源暂不请求。 使用懒加载可以减少页面的加载时间。 使用于需要大量图片的页面。 实现要点:将图片的src设为空，或者也可以将所有图片的src设一个底图，当图片还没加载完时，用这张底图来占图片的位置，防止页面结构混乱。再给一个自定义的data-url属性，用来存放图片的真实路径。lazyload属性用来标明哪些图片是需要懒加载。监听滚动事件，只在图片出现在可视区时，才动态地将图片的真实地址赋予图片的src属性。 1234567891011121314151617181920212223242526&lt;img src=&quot;&quot; lazyload=&quot;true&quot; data-url=&quot;1.jpg&quot;/&gt;var viewHeight = document.documentElement.clientHeight;//可视区域的高度function lazyload()&#123; var eles = document.querySelectorAll(&apos;img[data-url][lazyload]&apos;); Array.prototype.forEach.call(eles,function(item,index)&#123; var rect; if(item.dataset.url === &apos;&apos;)&#123;//html5 data 钩子的写法 return; &#125; rect = item.getBoundingClientRect();//getBoundingClientRect()返回一个矩形对象. if(rect.bottom &gt;= 0 &amp;&amp; rect.top &lt; viewHeight)&#123; !function()&#123;//感叹号表明这是一个函数表达式 var img = new Image(); img.src = item.dataset.url; img.onload = function()&#123; item.src = img.src; &#125; item.removeAttribute(&apos;data-url&apos;); item.removeAttribute(&apos;lazyload&apos;); &#125;() &#125; &#125;)&#125;lazyload();//首屏调用document.addEventListener(&apos;scroll&apos;,lazyload);]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：数组的常用方法]]></title>
    <url>%2F2019%2F04%2F13%2FJS%2FJS%EF%BC%9A%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[join(“分隔符”) 1将数组的元素放入一个字符串，默认用逗号为分隔符。 push() 1把参数逐个添加到数组末尾，返回修改后数组长度。 pop() 1从数组末尾移除最后一项，返回移除的项。 shift() 1移除数组中的第一个项并返回该项。 unshift() 1在数组前面添加任意个项，返回数组长度。 reverse() （会修改原数组） 1反转数组的顺序，返回经过排序后的数组，会修改原数组。 sort([function]) （会修改原数组） 123456789参数必须是函数，若无参数则默认按照字母编码（字符编码）的顺序进行排序。会修改原数组。//数字从小到大排序arr.sort(function(a,b)&#123; return a-b;&#125;);//数字从大到小排序arr.sort(function(a,b)&#123; return b-a;&#125;); concat() (不修改原数组) 123连接两个或多个数组。参数可以为具体的值，也可以为数组对象，可以有任意多个。返回当前数组的一个浅拷贝。 slice(start,end) (不修改原数组) 123基于当前数组的一个或多个项创建一个新数组。左闭右开，返回新数组，不影响原数组。没有参数则原数组的浅拷贝。 splice(start,number,new) (会修改原数组) 1删除原数组的一部份成员，并可以在被删除的位置添加入新的数组成员，会修改原数组。返回一个数组，里面包含被删除的项目。 indexOf(search,start) 1返回search首次出现的位置，没有则返回-1。默认从第0位开始。 lastIndexOf(search,start) 1从右往左找，返回search首次出现的位置，没有则返回-1。 includes(value) 1判断一个数组是否包含一个指定的值。 forEach(callback(value,index,array){}[,this]) (不修改原数组) 123对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容，对应的数组索引，数组本身。 map(callback(value,index,array){}[,this]) (不修改原数组) 1对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 filter(callback(value,index,array){}[,this]) (不修改原数组) 1“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。 some(callback(value,index,array){}[,this]) (不修改原数组) 1判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。 every(callback(value,index,array){}[,this]) (不修改原数组) 1判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。 find(callback(value,index,array){}[,this]) (不修改原数组) 1返回数组中满足提供的测试函数的第一个元素的值。 findIndex(callback(value,index,array){}[,this]) (不修改原数组) 1返回数组中满足提供的测试函数的第一个元素的索引。 reduce(function(prev, cur, index, array){}[,初始值])和reduceRight(function(prev, cur, index, array){}[,初始值]) (不修改原数组) 123实现迭代数组的所有项，然后构建一个最终返回的值。前者从第一项开始，后者从最后一项开始。这个函数返回的任何值都会作为第一个参数自动传给下一项。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统：进程、线程、程序]]></title>
    <url>%2F2019%2F04%2F12%2F%E5%85%B6%E4%BB%96%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[程序只是一组指令的有序集合。 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是资源分配的最小单位。 线程是程序执行的最小单位。 一个程序至少一个进程，一个进程至少一个线程。 一个线程只能属于一个进程，但是一个进程可以拥有多个线程 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。 而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。 多线程处理就是允许一个进程中在同一时刻执行多个任务。 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网：计算机网络体系结构]]></title>
    <url>%2F2019%2F04%2F12%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[TCP/IP体系结构五层协议 应用层（http，ftp） 运输层（TCP，UDP） 网络层（IP） 数据链路层 物理层 四层协议 应用层（http，ftp） 运输层（TCP，UDP） 网际层IP 网络接口层 OSI模型 应用层（HTTP） 表示层 会话层（SSL\TLS） 运输层（TCP，UDP） 网络层（IP） 数据链路层 物理层]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网：http的header字段]]></title>
    <url>%2F2019%2F04%2F12%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9Ahttp%E7%9A%84header%E5%AD%97%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[http头 = 通用头 + 请求头 + 响应头 通用头(General)通用头域包含请求和响应消息都支持的头域，提供了与报文相关的最基本的信息。 header 含义 Request URL 请求的URL Request Method 请求的方法 Status Code HTTP 状态码 Remote Address 远程IP地址 Referrer Policy 记录了是从哪个链接跳来的 响应头(Response Headers) header 含义 示例 Accept-Ranges 表明服务器是否支持指定范围请求及哪种类型的分段请求 Accept-Ranges: bytes Age 从原始服务器到代理缓存形成的估算时间（以秒计，非负） Age: 12 Allow 对某网络资源的有效的请求行为，不允许则返回405 Allow: GET, HEAD Cache-Control 告诉所有的缓存机制是否可以缓存及哪种类型 Cache-Control: no-cache Content-Encoding web服务器支持的返回内容压缩编码类型。 Content-Encoding: gzip Content-Language 响应体的语言 Content-Language: en,zh Content-Length 响应体的长度 Content-Length: 348 Content-Location 请求资源可替代的备用的另一地址 Content-Location: /index.htm Content-MD5 返回资源的MD5校验值 Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ== Content-Range 在整个返回体中本部分的字节位置 Content-Range: bytes 21010-47021/47022 Content-Type 返回内容的MIME类型 Content-Type: text/html; charset=utf-8 Date 原始服务器消息发出的时间 Date: Tue, 15 Nov 2010 08:12:31 GMT ETag 请求变量的实体标签的当前值 ETag: “737060cd8c284d8af7ad3082f209582d” Expires 响应过期的日期和时间 Expires: Thu, 01 Dec 2010 16:00:00 GMT Last-Modified 请求资源的最后修改时间 Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT Location 用来重定向接收方到非请求URL的位置来完成请求或标识新的资源 Location: http://www.zcmhi.com/archives/94.html Pragma 包括实现特定的指令，它可应用到响应链上的任何接收方 Pragma: no-cache Proxy-Authenticate 它指出认证方案和可应用到代理的该URL上的参数 Proxy-Authenticate: Basic refresh 应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持） Refresh: 5; url=http://www.zcmhi.com/archives/94.html Retry-After 如果实体暂时不可取，通知客户端在指定时间之后再次尝试 Retry-After: 120 Server web服务器软件名称 Server: Apache/1.3.27 (Unix) (Red-Hat/Linux) Set-Cookie 设置Http Cookie Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 Trailer 指出头域在分块传输编码的尾部存在 Trailer: Max-Forwards Transfer-Encoding 文件传输编码 Transfer-Encoding:chunked Vary 告诉下游代理是使用缓存响应还是从原始服务器请求 Vary: * Via 告知代理客户端响应是通过哪里发送的 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 警告实体可能存在的问题 Warning: 199 Miscellaneous warning WWW-Authenticate 表明客户端请求实体应该使用的授权方案 WWW-Authenticate: Basic 请求头(Request Headers) header 含义 示例 Accept 指定客户端能够接收的内容类型 Accept: text/plain, text/html Accept-Charset 浏览器可以接受的字符编码集。 Accept-Charset: iso-8859-5 Accept-Encoding 指定浏览器可以支持的web服务器返回内容压缩编码类型。 Accept-Encoding: compress, gzip Accept-Language 浏览器可接受的语言 Accept-Language: en,zh Accept-Ranges 可以请求网页实体的一个或者多个子范围字段 Accept-Ranges: bytes Authorization HTTP授权的授权证书 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Cache-Control 指定请求和响应遵循的缓存机制 Cache-Control: no-cache Connection 表示是否需要持久连接。（HTTP 1.1默认进行持久连接） Connection: close Cookie HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。 Cookie: $Version=1; Skin=new; Content-Length 请求的内容长度 Content-Length: 348 Content-Type 请求的与实体对应的MIME信息 Content-Type: application/x-www-form-urlencoded Date 请求发送的日期和时间 Date: Tue, 15 Nov 2010 08:12:31 GMT Expect 请求的特定的服务器行为 Expect: 100-continue From 发出请求的用户的Email From: user@email.com Host 指定请求的服务器的域名和端口号 Host: www.zcmhi.com If-Match 只有请求内容与实体相匹配才有效 If-Match: “737060cd8c284d8af7ad3082f209582d” If-Modified-Since 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码 If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT If-None-Match 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 If-None-Match: “737060cd8c284d8af7ad3082f209582d” If-Range 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag If-Range: “737060cd8c284d8af7ad3082f209582d” If-Unmodified-Since 只在实体在指定时间之后未被修改才请求成功 If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT Max-Forwards 限制信息通过代理和网关传送的时间 Max-Forwards: 10 Pragma 用来包含实现特定的指令 Pragma: no-cache Proxy-Authorization 连接到代理的授权证书 Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Range 只请求实体的一部分，指定范围 Range: bytes=500-999 Referer 先前网页的地址，当前请求网页紧随其后,即来路 Referer: http://www.zcmhi.com/archives/71.html TE 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息 TE: trailers,deflate;q=0.5 Upgrade 向服务器指定某种传输协议以便服务器进行转换（如果支持） Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 User-Agent User-Agent的内容包含发出请求的用户信息 User-Agent: Mozilla/5.0 (Linux; X11) Via 通知中间网关或代理服务器地址，通信协议 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 关于消息实体的警告信息 Warn: 199 Miscellaneous warning]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：把十六进制的ip地址转换为十进制的]]></title>
    <url>%2F2019%2F04%2F10%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E6%8A%8A%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%9A%84ip%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E8%BF%9B%E5%88%B6%E7%9A%84%2F</url>
    <content type="text"><![CDATA[12345678910function change(ip)&#123; var temp = []; for(var i=0;i&lt;ip.length;i+=2)&#123; temp.push(ip.substr(i,2)) &#125; return temp.map(function(value)&#123; return parseInt(value,16); &#125;).join(&quot;.&quot;);&#125;console.log(change(&quot;C0A80000&quot;)); //&quot;192.168.0.0&quot; 拓展 12345在ip地址中，8位二进制取一个.且二进制的4位对应十六进制的1位因此8位二进制对应一个十进制整数2位十六进制对应一个十进制整数]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：快速排序]]></title>
    <url>%2F2019%2F04%2F09%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序分为交换排序、选择排序、插入排序、归并排序、基数排序快速排序和冒泡排序数据交换排序 首先，定义一个quickSort函数，它的参数是一个数组。 123function quickSort(arr)&#123; &#125; 然后，检查数组的元素个数，如果小于等于1，就返回。 12345function quickSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr; &#125;&#125; 接着，选择”基准”（pivot），并将其与原数组分离，再定义两个空数组，用来存放一左一右的两个子集。 123456789function quickSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr; &#125; var pivotIndex = Math.floor(arr.length/2); var pivot = arr.splice(pivotIndex,1)[0]; var left = []; var right = [];&#125; 然后，开始遍历数组，小于”基准”的元素放入左边的子集，大于等于基准的元素放入右边的子集。 12345678910111213141516function quickSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr; &#125; var pivotIndex = Math.floor(arr.length/2); var pivot = arr.splice(pivotIndex,1)[0]; var left = []; var right = []; for(var i in arr)&#123; if(arr[i] &lt; pivot)&#123; left.push(arr[i]); &#125;else&#123; right.push(arr[i]); &#125; &#125;&#125; 最后，使用递归不断重复这个过程，就可以得到排序后的数组。1234567891011121314151617function quickSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr; &#125; var pivotIndex = Math.floor(arr.length/2); var pivot = arr.splice(pivotIndex,1)[0]; var left = []; var right = []; for(var i in arr)&#123; if(arr[i] &lt; pivot)&#123; left.push(arr[i]); &#125;else&#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot],quickSort(right));&#125; 优化：选一个好的基准：随机选取三个数，排序取中 时间复杂度：nlogn]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6：let和const]]></title>
    <url>%2F2019%2F04%2F02%2FES6%2FES6%EF%BC%9Alet%E5%92%8Cconst%2F</url>
    <content type="text"><![CDATA[let是定义变量 const是定义常量。若定义基本数据类型，则不能再次改变；若定义复杂数据类型，如对象，则可以修改或者添加属性，但指针是不会变的。 let和const都不会变量提升，在声明之前使用会形成死区。 使用babel工具将es6转换为es5]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：立即执行函数]]></title>
    <url>%2F2019%2F04%2F01%2FJS%2FJS%EF%BC%9A%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[立即执行函数12345//一个匿名函数包裹在一个括号运算符中，后面再跟一个小括号( function()&#123;…&#125; )() //等价于( function ()&#123;…&#125; () )//一个匿名函数后面跟一个小括号，然后整个包裹在一个括号运算符中 注意： 函数体后面要有小括号()，函数体必须是函数表达式而不能是函数声明。 （）运算符将匿名函数或函数声明转换为函数表达式。 好处通过定义一个匿名函数，创建了一个新的函数作用域，相当于创建了一个“私有”的命名空间，该命名空间的变量和方法，不会破坏污染全局的命名空间。 此时若是想访问全局对象，将全局对象以参数形式传进去即可 123(function(window)&#123; ...&#125;)(window); 拓展123456789101112131415161718192021222324252627282930313233343536for(var i = 0; i&lt;10; i++)&#123; setTimeout(function()&#123; console.log(i) &#125;);&#125;改写：使打印 0-10//第一种：letfor(let i = 0; i&lt;10; i++)&#123; setTimeout(function()&#123; console.log(i) &#125;);&#125;//第二种：闭包 + 立即执行函数for(var i = 0; i&lt;10; i++)&#123; (function(a)&#123; setTimeout(function()&#123; console.log(a) &#125;); &#125;)(i);&#125;上面的代码即可实现依次打印出0,1,2,3...此处利用闭包每次将i的值传入进去，里面使用参数a接受传过来的值然后setTimeout异步调用，进入异步队列，循环代码很快执行完然后从异步队列里返回执行后的结果，依次打印出0，1,2,3...//实现隔1秒依次打印一个结果for(var i = 0; i&lt;10; i++)&#123; (function(a)&#123; setTimeout(function()&#123; console.log(a) &#125;); &#125;,1000*a)(i);&#125;上面代码在延迟执行时间那块加了一个参数aa的值每次都会增加1，使时间每次扩大比上次大一倍从而实现了每隔一秒就打印出一个结果 异步调用：异步代码执行完后结果存放在队列中，等同步代码执行完，再输出结果]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6：apply、call和bind]]></title>
    <url>%2F2019%2F03%2F29%2FES6%2FES6%EF%BC%9Aapply%E3%80%81call%E5%92%8Cbind%2F</url>
    <content type="text"><![CDATA[都是为了改变某个函数运行时的上下文，即改变函数里的this的指向。将一个函数应用在其他对象上。 第一个参数要绑定给this的值，为nul或undefined时指向window。 apply、call绑定后会立即调用，bind绑定后不会立即调用。 apply第二个参数为数组，call后面为参数列表。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型：json和xml]]></title>
    <url>%2F2019%2F03%2F29%2F%E5%85%B6%E4%BB%96%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9Ajson%E5%92%8Cxml%2F</url>
    <content type="text"><![CDATA[json json是一种轻量级的数据交换格式。 兼容性高。 格式简单，易读写。 易于解析。 xml xml是一种扩展标记语言。 可用来标记数据，定义数据类型。 格式统一。 文件庞大，格式复杂。 客户端和服务器端都需要大量代码来解析，导致代码复杂难以维护。]]></content>
      <categories>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM和DOM]]></title>
    <url>%2F2019%2F03%2F28%2F%E5%89%8D%E7%AB%AF%2FBOM%E5%92%8CDOM%2F</url>
    <content type="text"><![CDATA[BOM和DOM DOM（文档对象模型）是 HTML 和 XML 的应用程序接口。 DOM可以将任何HTML或XML文档描绘成一个由多层次节点构成的结构。 BOM （浏览器对象模型）主要处理浏览器窗口和框架。 javacsript是通过访问BOM对象来访问、控制、修改客户端浏览器。 由于BOM的window包含了document，document对象又是DOM的根节点。可以说，BOM包含了DOM。 浏览器提供出来给予访问的是BOM对象，从BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档。 拓展：遍历dom树]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：二分查找]]></title>
    <url>%2F2019%2F03%2F28%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[二分法查找，也称折半查找，是一种在有序数组中查找特定元素的搜索算法。 首先，从有序数组的中间的元素开始搜索， 如果该元素正好是目标元素（即要查找的元素），则搜索过程结束，否则进行下一步。 如果目标元素大于或者小于中间元素， 则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作。 如果某一步数组为空，则表示找不到目标元素。 12345678910111213141516171819function search(arr,key)&#123; var low = 0; var high = arr.length-1; while(low &lt;= high)&#123; var mid = parseInt((low+high)/2); if(key == arr[mid])&#123; return mid; &#125;else if(key &lt; arr[mid])&#123; high = mid-1; &#125;else if(key &gt; arr[mid])&#123; low = mid+1; &#125;else&#123; return -1; &#125; &#125;&#125;console.log(search([0,1,2,3,5,6,7],5));//4console.log(search([0,1,2,3,5,6,7],4));//undefined]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：时间复杂度]]></title>
    <url>%2F2019%2F03%2F27%2FJS%2FJS%EF%BC%9A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[时间复杂度原则 如果运行时间是常数量级，用常数1表示； 只保留时间函数中的最高阶项； 如果最高阶项存在，则省去最高阶项前面的系数。 场景一给小灰一条长n寸的面包，小灰每3天吃掉1寸，那么吃掉整个面包需要几天？ 12345678//T（n） = 3n，执行次数是线性的。void eat1(int n)&#123; for(int i=0; i&lt;n; i++)&#123;; System.out.println(&quot;等待一天&quot;); System.out.println(&quot;等待一天&quot;); System.out.println(&quot;吃一寸面包&quot;); &#125;&#125; 时间复杂度为：T（n） = O（n） 场景二给小灰一条长16寸的面包，小灰每5天吃掉面包剩余长度的一半，第一次吃掉8寸，第二次吃掉4寸，第三次吃掉2寸……那么小灰把面包吃得只剩下1寸，需要多少天呢？ 这个问题翻译一下，就是数字16不断地除以2，除几次以后的结果等于1？这里要涉及到数学当中的对数，以2位底，16的对数，可以简写为log16。因此，把面包吃得只剩下1寸，需要 5 X log16 = 5 X 4 = 20 天。 如果面包的长度是 N 寸呢？需要 5 X logn = 5logn天，记作 T（n） = 5logn。12345678910//T（n） = 5logn，执行次数是对数的。void eat2(int n)&#123; for(int i=1; i&lt;n; i*=2)&#123; System.out.println(&quot;等待一天&quot;); System.out.println(&quot;等待一天&quot;); System.out.println(&quot;等待一天&quot;); System.out.println(&quot;等待一天&quot;); System.out.println(&quot;吃一半面包&quot;); &#125;&#125; 时间复杂度为：T（n） = O（logn） 场景三给小灰一条长10寸的面包和一个鸡腿，小灰每2天吃掉一个鸡腿。那么小灰吃掉整个鸡腿需要多少天呢？ 12345//T（n） = 2，执行次数是常量的。void eat3(int n)&#123; System.out.println(&quot;等待一天&quot;); System.out.println(&quot;吃一个鸡腿&quot;);&#125; 时间复杂度为：T（n） = O（1） 场景四给小灰一条长10寸的面包，小灰吃掉第一个一寸需要1天时间，吃掉第二个一寸需要2天时间，吃掉第三个一寸需要3天时间…..每多吃一寸，所花的时间也多一天。那么小灰吃掉整个面包需要多少天呢？ 答案是从1累加到10的总和，也就是55天。 如果面包的长度是 N 寸呢？此时吃掉整个面包，需要 1+2+3+……+ n-1 + n = (1+n)*n/2 = 0.5n^2 + 0.5n。123456789//T（n） = 0.5n^2 + 0.5n，执行次数是一个多项式。void eat4(int n)&#123; for(int i=0; i&lt;n; i++)&#123; for(int j=0; j&lt;i; j++)&#123; System.out.println(&quot;等待一天&quot;); &#125; System.out.println(&quot;吃一寸面包&quot;); &#125;&#125; 时间复杂度为：T（n） = O（n^2） 总结四种时间复杂度究竟谁用时更长，谁节省时间呢？ 1O（1）&lt; O（logn）&lt; O（n）&lt; O（n^2） 除了上述的四个场景，还有许多不同形式的时间复杂度，比如： 1O（nlogn）, O（n^3）, O（m*n），O（2^n），O（n！）]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：flex布局]]></title>
    <url>%2F2019%2F03%2F21%2FCSS%2FCSS%EF%BC%9Aflex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[前言flex布局称为弹性布局。任何一个容器都可以指定为 Flex 布局。 设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效 基本概念采用 Flex 布局的元素，称为 Flex 容器，简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目，简称”项目”。 水平的主轴（main axis） 垂直的交叉轴（cross axis） 主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end 交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性flex-directionflex-direction属性决定主轴的方向（即项目的排列方向）。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿 flex-wrap默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 123.box &#123; flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;;&#125; justify-contentjustify-content属性定义了项目在主轴上的对齐方式。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-itemsalign-items属性定义项目在交叉轴上如何对齐。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-contentalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目的属性orderorder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow flex-grow属性定义项目的放大比例，默认为0。 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。 如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。（即把剩余空间划分为四份，属性为2的占两份，属性为1的占一份）。 flex-shrink flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。数值大的缩小得多。 如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 flex-basisflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flexflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 123.item &#123; flex: &lt;flex-grow&gt; &lt;flex-shrink&gt; &lt;flex-basis&gt;; &#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 align-selfalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto。 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 auto：表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟dom]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%89%8D%E7%AB%AF%2F%E8%99%9A%E6%8B%9Fdom%2F</url>
    <content type="text"><![CDATA[是什么可以看作是一个使用javascript模拟了DOM结构的树形结构，这个树结构包含整个DOM结构的信息。 为什么之前使用原生js或者jquery写页面的时候会发现操作DOM是一件非常麻烦的一件事情，且在浏览器里一遍又一遍的渲染DOM是非常非常消耗性能的。在js做dom对比，减少对dom的操作，而不是每一次都要渲染，这样效率会提高。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种算法（二）]]></title>
    <url>%2F2019%2F03%2F19%2F%E7%AE%97%E6%B3%95%2F%E5%90%84%E7%A7%8D%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[求“123456789876543212345678987654321…”中的第n位123456789function index(n)&#123; if(n%16&lt;10)&#123; return n%16; &#125;else&#123; return 9-(n%16-9); &#125;&#125;console.log(index(26));//8 实现add(1);//1add(1)(2); //3add(1)(2)(3); //6 12345678910111213141516171819var add = function(a) &#123; var sum = a; var s = function(b) &#123; sum += b; //s，继续累加后面的执行参数。 return s; &#125;; //当要打印一个对象时，会自动调用 valueOf()或 toString方法 s.toString = function() &#123; return sum; &#125;; //获取第一个参数赋值给sum后，s。 return s;&#125;;add(1)(2)(3);//6//第一次调用add(),初始化了s，并将a保存在s的作用链中。//然后返回s保证了第二次调用的是s函数。//第二次之后的调用也是调用s，而在s中将传入的参数与保存在作用链中a相加并付给sum。 给定一个数组，返回所有的数字。如[1,’3’,false,null,100]=&gt;[1,3,100] 123456789101112131415function search(arr)&#123; var temp = []; for(var i in arr)&#123; if(typeof arr[i] == &quot;string&quot; || typeof arr[i] == &quot;number&quot;)&#123; temp.push(arr[i]); &#125; &#125; temp = temp.map(function(val)&#123; if（typeof parseInt（val） == &quot;number&quot;） return parseInt(val); &#125;) return temp;&#125;console.log(search([1,&apos;3&apos;,false,null,100])); //[1,3,100]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种算法（三）]]></title>
    <url>%2F2019%2F03%2F19%2F%E7%AE%97%E6%B3%95%2F%E5%90%84%E7%A7%8D%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[有一个字符串有很多is，写一个方法只保留一个is？ 123456789function deleteIs(str)&#123; var index = str.search(&quot;is&quot;); var left = str.slice(0,index+2); var right = str.slice(index+2,str.length); right = right.split(&quot;is&quot;).join(&quot;&quot;); return left.concat(right); &#125;console.log(deleteIs(&quot;thisismybook&quot;));//thismybook 有3个-10-10之间的整数，写一个方法这三个数一共有多少可能相加等于10。 改写数组的push方法，保持原有逻辑，添加一个console.log(arguments)，即push什么打印什么。 12345Array.prototype.push = function(val)&#123; console.log(val);&#125;var temp = [1,2,5];temp.push(7);//打印7 传入一个无序数组，要求n数相加，获取特定的sum 12345678910111213141516 function getResult(arr,n,sum)&#123; if(n==0&amp;&amp;sum==0)&#123; return true; &#125; if(n&lt;0)&#123; return false; &#125; if(n&gt;0)&#123; for(var i in arr)&#123; var temp = arr.slice(i+1,arr.length); return getResult(temp,n-1,sum-arr[i]) || getResult(temp,n,sum); &#125; &#125;&#125;console.log(getResult([1,2,3,4],2,7)); //true 用正则表达式去掉两边的空格 123456function remove(str)&#123; var reg = /(^\s+)|(\s+?)/g; return str.replace(reg,&quot;&quot;);&#125;console.log(remove(&quot;this is book&quot;));//&quot;thisisbook&quot; 给定一个非空的数字数组，数组有且只有一个非重复项，实现一个方法获取落单项 12345678910111213function getSingleNumber(arr)&#123; var temp = []; for(var i in arr)&#123; if(temp.indexOf(arr[i]) == -1)&#123; temp.push(arr[i]); &#125;else&#123; temp.splice(temp.indexOf(arr[i]),1); &#125; &#125; return temp[0];&#125;console.log(getSingleNumber([0,1,0,0])); //1 请实现一个函数merge，传入一个数组，合并数组中【相邻且重复】的元素 123456789101112function merge(arr)&#123; var reg = /(.)\1*/g; var str = arr.join(&quot;&quot;); str = str.replace(reg,&quot;$1&quot;); arr = str.split(&quot;&quot;); arr = arr.map(function(val)&#123; return parseInt(val); &#125;) return arr;&#125;console.log(merge([3,2,2,4,5,5,6,2,1]));//[3,2,4,5,6,2,1]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：瀑布流布局]]></title>
    <url>%2F2019%2F03%2F18%2FJS%2FJS%EF%BC%9A%E7%80%91%E5%B8%83%E6%B5%81%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[瀑布流布局的要求要进行布置的元素等宽； 然后计算元素的宽度， 与浏览器宽度之比，得到需要布置的列数； 创建一个数组，长度为列数， 里面的值为以已布置元素的总高度（最开始为0）； 然后将未布置的元素的依次布置到高度最小的那一列， 就得到了瀑布流布局； 滚动加载，scroll事件得到scrollTop， 与最后盒子的offsetTop对比， 符合条件就不断滚动加载。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种算法（一）]]></title>
    <url>%2F2019%2F03%2F17%2F%E7%AE%97%E6%B3%95%2F%E5%90%84%E7%A7%8D%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[求1+2+3+…+n1234567function Sum_Solution(n) &#123; var result = n; if(n &gt; 0) result += Sum_Solution(n-1); return result;&#125;console.log(Sum_Solution(3)); //6 统计一个数字在无序数组中出现的次数123456789101112131415function count(arr,num)&#123; arr.sort(function(a,b)&#123; return a-b; &#125;); var result; var left = arr.indexOf(num); var right = arr.lastIndexOf(num,arr.length-1); if(arr.indexOf(num) == -1)&#123; result = 0; &#125;else&#123; result = right-left+1; &#125; return result;&#125;console.log(count([5,5,5,5,5,2,3],5)); //5 找出数组中任意一个重复的数字12345678910111213141516function duplicate(numbers, duplication)&#123; // write code here //这里要特别注意~找到任意重复的一个值并赋值到duplication[0] //函数返回True/False var temp = []; for(var i in numbers)&#123; if(temp.indexOf(numbers[i])==-1)&#123; temp.push(numbers[i]); &#125;else&#123; duplication[0] = numbers[i]; return true; &#125; &#125; return false;&#125;console.log(duplicate([5,5,5,5,5,2,3],[]));//true 快速排序 1234567891011121314151617function quickSort(arr)&#123; if(arr.length &lt;= 1)&#123; return arr; &#125; var pivotIndex = Math.floor(arr.length/2); var pivot = splice(pivotIndex,1)[0]; var left = []; var right = []; for(var i in arr)&#123; if(arr[i] &lt; pivot)&#123; left.push(arr[i]); &#125;else&#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot],quickSort(right));&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[引用类型]]></title>
    <url>%2F2019%2F03%2F16%2FJS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[概述在学习引用类型之前，先弄清楚一些概念性的问题可能会比较好。接下来我就以已经学习过的类型来简单说明一下几个概念之间的关系：首先，JavaScript包含数据类型和引用类型 数据类型 复杂数据类型：Object 简单数据类型：Boolean、Number、String、Undefined、Null 12可用typeof运算符检测给定变量的数据类型如：alert(typeof 95);//&quot;number&quot; 引用类型这是一个最大的概念，也称为本地对象或者类 内置对象：Global、Math 基本包装类型（特殊的引用类型）：Boolean、Number、String 与其他引用类型相似：具有与各自的基本类型相应的特殊行为。不同：自动创建的基本包装类型的对象，只存在于一行代码的执行瞬间，然后立即被销毁。当然，可以使用new操作符显示创建对象，虽说绝对必要的情况才这样，但我觉得好像大多是这样做的（我的错觉？） 其他：Object、Array、Date、RegExp、Function 每一个引用类型都有相应的属性和方法，其中又分为静态和实例 静态属性、方法：无需创建对象实例，可直接通过引用类型调用（内置对象中的都为静态属性和方法） 实例属性、方法：每个对象实例都具有的（其他引用类型中常用的方法均为实例方法） 123由于无论引用的是什么类型的对象，typeof运算符都返回&quot;object&quot;可用instanceof运算符识别正在处理的对象的具体类型如：alert(95 instanceof Number);//true 数据类型和引用类型的不同在内存中的存储方式不同 原始数据类型在内存中是栈存储。是自动分配的内存，由系统自动释放。 引用类型在内存中是堆存储。是动态分配的内存，大小不定也不会自动释放。 引用类型内置对象 （不必实例化） Global对象 用法1window.属性(方法)/属性(方法) 小结1、这是最特别的一个对象，不管从什么角度看，它都是不存在的2、不属于任何其他对象的属性和方法，最终都是它的属性和方法3、在全局作用域中定义的属性和函数，都是Global对象的属性4、Web浏览器将这个全局对象作为window对象的一部分加以实现，因此，在全局作用域中声明的所有变量和函数，都成为window对象的属性 相关属性与方法详见书中131 Math对象 用法1Math.属性(方法) 为保存数学公式和信息提供了一个公共位置 相关属性与方法详见书中134 基本包装类型（使用new操作符） Boolean类型 用法调用Boolean构造函数并传入true或false值 1var booleanObject=new Boolean(true); 相关属性与方法详见书中120 Number类型 用法调用Number构造函数时向其传递相应的数值 1var numberObject=new Number(10); 相关属性与方法详见书中120 String类型 用法1var stringObject=new String(&quot;hello&quot;); 相关属性与方法详见书中122 其他引用类型（使用new操作符） Object类型用法1、使用Object构造函数 123var person=new Object();person.name=&quot;greg&quot;;person.age=27; 2、使用字面量表示法 1234var person=&#123; name:&quot;greg&quot;, age:27&#125;; 相关属性与方法详见书中83 Array类型用法1、使用Array构造函数 1234若知道数组要保存的项目数量，可传参，为length属性的值var colors=new Array();可省略new操作符var colors= Array(); 2、使用数组字面量表示法 12var colors=[&quot;red&quot;,&quot;yellow&quot;];var names=[];//空数组 相关属性与方法详见书中86 Date类型用法 12345678不传参，即获得当前日期和时间var now=new Date();传入表示某日期的毫秒数，返回该日期和时间其中有相应的方法可获取某日期的毫秒数Date.parse()和Date.UTC()var someDate=new Date(Date.parse(&quot;July 14,2017&quot;));等价于var someDate=new Date(&quot;July 14,2017&quot;);var someDate=new Date(Date.UTC(2017,6,14));等价于var someDate=new Date(2017,6,14);//UTC时间 相关属性与方法详见书中98 RegExp类型用法1、使用RegExp构造函数 1var pattern=new RegExp(&quot;pattern&quot;,&quot;gim&quot;); 2、使用字面量表达式（常用） 1234var pattern =/pattern/gim;g:全局模式i:不区分大小写m:多行模式 相关元字符、实例属性、实例方法、静态属性详见书中103 Function类型用法1、使用函数声明语法定义（常用） 1234解析器会率先读取函数声明，并使其在执行任何代码前可用function sum(num1,num2)&#123; return num1+num2;&#125; 2、使用函数表达式定义 123456必须等解析器执行到函数表达式所在的代码行，才会真正被解释执行var sum=function(num1,num2)&#123; return num1+num2;&#125;;无需函数名，通过变量即可引用函数PS：函数末尾有一个分号，同声明其他变量一样 3、使用Function构造函数（不推荐使用） 1var sum=new Function(&quot;num1&quot;,&quot;num2&quot;,&quot;return num1+num2&quot;); 小结 没有重载：当声明了两个同名函数时，后面的将覆盖前面的函数 作为值的函数：像传参一样把函数传递，即访问函数的指针，而不是执行函数 内部属性：（有点绕有点难懂，我觉得很少用）arguments.callee：指针，指向拥有 arguments对象的函数；arguments.callee.caller：指向（调用了（拥有arguments对象）的函数）的函数 相关属性与方法详见书中110]]></content>
      <categories>
        <category>红宝书</category>
      </categories>
      <tags>
        <tag>红宝书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：实现给数字添加千分位符的方法]]></title>
    <url>%2F2019%2F03%2F16%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%AE%9E%E7%8E%B0%E7%BB%99%E6%95%B0%E5%AD%97%E6%B7%BB%E5%8A%A0%E5%8D%83%E5%88%86%E4%BD%8D%E7%AC%A6%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[toLocaleString方法12const num = 12345678;num.toLocaleString(); toLacalString：返回这个数字在特定语言环境下的表示字符串。 在没有指定区域的基本使用时，返回使用默认的语言环境和默认选项格式化的字符串。 正则表达式1234567const num = 12345678;var reg=/\d&#123;1,3&#125;(?=(\d&#123;3&#125;)+$)/g;num.replace(reg,&quot;$&amp;,&quot;);1. 正则表达式 \d&#123;1,3&#125;(?=(\d&#123;3&#125;)+$) 表示前面有1~3个数字，后面的至少由一组3个数字结尾。2. ?=表示正向引用，可以作为匹配的条件，但匹配到的内容不获取，并且作为下一次查询的开始。3. $&amp; 表示与正则表达式相匹配的内容。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：发布-订阅和观察者]]></title>
    <url>%2F2019%2F03%2F15%2FJS%2FJS%EF%BC%9A%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%2F</url>
    <content type="text"><![CDATA[观察者模式（自定义事件）目标和观察者是基类，目标提供维护观察者的一系列方法，观察者提供更新接口。具体观察者和具体目标继承各自的基类，然后具体观察者把自己注册到具体目标里，在具体目标发生变化时候，调度观察者的更新方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 观察者(订阅者)function Observer(name) &#123; this.name = name;&#125;Observer.prototype = &#123; update: function(context) &#123; console.log(this.name + &quot;：&quot; + context); &#125;&#125;// 观察者(订阅者)列表function ObserverList() &#123; this.observerList = [];&#125;ObserverList.prototype = &#123; add: function(obj) &#123; return this.observerList.push(obj); &#125;, count: function() &#123; return this.observerList.length; &#125;, get: function(index) &#123; if (index &gt; -1 &amp;&amp; index &lt; this.observerList.length) &#123; return this.observerList[index]; &#125; &#125;, removeAt: function(index) &#123; this.observerList.splice(index, 1); &#125;&#125;// 目标(发布者)function Subject() &#123; this.observers = new ObserverList();&#125;Subject.prototype = &#123; addObsever: function(observer) &#123; this.observers.add(observer); &#125;, removeObsever: function(observer) &#123; this.observers.removeAt(this.observers.indexOf(observer, 0)); &#125;, notify: function(context) &#123; var observerCount = this.observers.count(); for (var i = 0; i &lt; observerCount; i++) &#123; this.observers.get(i).update(context); &#125; &#125;&#125;var mySubject = new Subject();mySubject.addObsever(new Observer(&quot;小明&quot;));mySubject.addObsever(new Observer(&quot;小红&quot;));mySubject.notify(&quot;hello world&quot;); 发布-订阅理解发布-订阅模式，用个对象作为调度中心，绑定事件名为属性。订阅者把自己想订阅的事件注册到调度中心，发布者发布事件到调度中心时，即触发这个事件，由调度中心统一调度订阅者注册到调度中心的处理代码。 优点 支持简单的广播通信，当对象状态发生改变时，会自动通知已经订阅过的对象。 发布者与订阅者耦合性降低，发布者只管发布一条消息出去，它不关心这条消息如何被订阅者使用，同时，订阅者只监听发布者的事件名，只要发布者的事件名不变，它不管发布者如何改变。 缺点 创建订阅者需要消耗一定的时间和内存。 虽然可以弱化对象之间的联系，如果过度使用的话，反而使代码不好理解及代码不好维护等等。 一个简单的发布订阅123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var event = &#123; clientList: &#123;&#125;, listen: function( key, fn )&#123; //添加订阅对象 if( !this.clientList[ key ] )&#123; this.clientList[ key ] = []; &#125; this.clientList[ key ].push( fn ); &#125;, trigger: function()&#123; //绑定发布事件 var key = Array.prototype.shift.apply( arguments ), fns = this.clientList[ key ]; for( var i = 0, fn; fn = fns[ i++]; )&#123; fn.apply( this, arguments ); &#125; &#125;, remove: function( key, fn )&#123; //取消订阅的事件 var fns = this.clientList[ key ]; if( !fns )&#123; //如果key对应的消息没有被人订阅，则直接返回 return false; &#125;; if( !fn )&#123; //如果没有传入具体的回调函数，标示取消key对应消息的所有订阅 fns = []; &#125;else&#123; for( var i = fns.length - 1; i &gt;= 0 ; i-- )&#123; //取消key对应的订阅消息 if( fn === fns[ i ] )&#123; fns.splice( i, 1 ); &#125; &#125; &#125; &#125;&#125;;var saleOffices = &#123;&#125;;//给对象绑定一个调度中心var installEvent = function( obj )&#123; for( i in event )&#123; obj[ i ] = event[ i ]; &#125;&#125;;installEvent( saleOffices );saleOffices.listen( &quot;squareMeter88&quot;, fn1 = function( price )&#123; console.log( &quot;价格&quot; + price );&#125; );saleOffices.listen( &quot;squareMeter88&quot;, function( price )&#123; console.log( &quot;价格&quot; + price );&#125; );saleOffices.remove( &quot;squareMeter88&quot;, fn1 );saleOffices.trigger( &quot;squareMeter88&quot;, 200000 ); 不同观察者模式的订阅者和发布者之间是存在依赖的，发布订阅模式的不会。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue：其他]]></title>
    <url>%2F2019%2F03%2F15%2FVue%2FVue%EF%BC%9A%E5%85%B6%E4%BB%96%2F</url>
    <content type="text"><![CDATA[如何理解vuevue是一套用于构建用户界面的渐进式框架，采用MVVM架构。其核心库只关注视图层，采用自底向上增量开发的设计。vue的目标是通过尽可能简单的API实现响应的数据绑定和组合的视图组件。 优势： 低耦合。视图可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。 简单的语法及项目创建，提供vue-cli脚手架，能非常容易地构建项目。 更快的渲染速度和更小的体积。 缺点：不支持IE8。 vuex(可以在vue1.0使用)vue框架中状态管理。在main.js引入store，注入。新建一个目录store，….. export 。 场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车 vue1.0和vue2.0的区别生命周期不一样vue1.0：init、created、beforeCompile、compiled、ready、beforeDestroy、destroyed vue2.0：beforeCreate、created、beforeMount、mounted、beforeUpload、uploaded、beforeDestroy、destroyed 绑定一次12vue1.0：&#123;&#123;*msg&#125;&#125;vue2.0：v-once，上述已废除 绑定html代码12vue1.0：&#123;&#123;&#123;msg&#125;&#125;&#125;vue2.0：v-html，上述已废除]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS：Math的常用方法]]></title>
    <url>%2F2019%2F03%2F13%2FJS%2FJS%EF%BC%9AMath%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[12345678910111. Math.sqrt()：计算平方根2. Math.cbrt()：计算立方根3. Math.pow(a, b)：计算a的b次方4. Math.max(a,b,c...)：计算最大值5. Math.min(a,b,c...)：计算最小值6. Math.abs()：求绝对值 7. Math.ceil()：向上取整8. Math.floor()：向下取整9. Math.random()：取得一个[0.0,1.0)的随机数 10. Math.rint()： 四舍五入，返回double值。注意.5的时候会取偶数11. Math.round()： 四舍五入，float时返回int值，double时返回long值]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：清除浮动]]></title>
    <url>%2F2019%2F03%2F07%2FCSS%2FCSS%EF%BC%9A%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[浮动产生影响 给父元素设置高度。 给父元素设置overflow:hidden; 父元素也设置浮动。 在结尾处添加空div标签clear:both 父元素定义伪类::after 12345::after&#123; clear: both; content: &quot;&quot;; display: block; &#125; 父元素定义display:table]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[h5和css3的新特性]]></title>
    <url>%2F2019%2F03%2F06%2F%E5%89%8D%E7%AB%AF%2Fh5%E5%92%8Ccss3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[HTML5绘画标签canvas用于媒介回放的video、audio本地离线存储localStorage长期存储数据，浏览器关闭后数据不丢失 sessionStorage数据在浏览器关闭后自动删除； 语义化更好的内容元素比如article、footer、header、nav、section； 表单控件calendar、data、time、email、url、search； webworker、websocket、Geolocation； 移除的元素： 纯表现的元素：basefont、big、center、font、s、strike、tt 对可用性产生负面影响的元素：frame、frameset、noframes CSS3RGBA和透明度word-wrap（对长的不可分割单词换行）1word-wrap: normal|break-word; 文字阴影12text-shadow：5px 5px 5px #FF0000;//水平阴影，垂直阴影，模糊距离，阴影颜色 @font-face规则定义自己的字体 圆角（边框半径）border-radius 属性用于创建圆角 边框图片border-image box-sizing盒阴影1box-shadow:10px 10px 5px #88888 媒体查询定义两套css，当浏览器的尺寸变化时会采用不同的属性]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地存储方式]]></title>
    <url>%2F2019%2F03%2F05%2F%E5%89%8D%E7%AB%AF%2F%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[cookie、localStorage、sessionStorage相同：在本地（浏览器端）存储数据。 不同 localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。 sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下。 localStorage是永久存储，除非手动删除。 sessionStorage当会话结束（当前页面关闭的时候，自动销毁） cookie的数据会在每一次发送http请求的时候，同时发送给服务器，而localStorage、sessionStorage不会。 每个cookie存放的内容大小有限制，一般为4kb。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue基础知识（一）]]></title>
    <url>%2F2019%2F02%2F25%2FVue%2FVue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[概述 Vue.js 是一个构建数据驱动的 web 界面的渐进式框架，一个mvvm框架（库），和angular相似。 注意MVC、MVP、MVVM的区别 Vue.js通过尽可能简单的api实现响应的数据绑定和组合的视图组件。 Vue 的核心库只关注视图层，它不仅小巧、易于上手，还便于与第三方库或既有项目整合。 vue: 简单、易学 指令以 v-xxx 一片html代码配合上json，在new出来vue实例 个人维护项目 适合: 移动端项目,小巧 vue的发展势头很猛，github上star数量已经超越angular angular: 上手难 指令以 ng-xxx 所有属性和方法都挂到$scope身上angular由google维护 合适: pc端项目 vue与angular共同点: 不兼容低版本IE步 起步第一个vue123&lt;div id=&quot;box&quot;&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt; 123456789&lt;script type=&quot;text/javascript&quot; src=&quot;../vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var app=new Vue(&#123; el: &apos;#box&apos;, //el的值可以为选择器class/id 可以tagName data: &#123; message:&apos;Hello,vue.js!&apos; &#125; &#125;);&lt;/script&gt; 常用指令属性绑定：v-bind条件渲染：v-if、v-else、v-else-if、v-show列表渲染：v-for事件处理：v-on表单输入绑定：v-model防止闪烁 v-cloak 防止花括号闪烁, 比较大段落 （在html标签上作为属性加入） v-text=”msg” 1&lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt; -&gt; v-text=&quot;msg&quot; v-html=”msg” 1&#123;&#123;&#123;msg&#125;&#125;&#125;(过滤标签) -&gt; v-html=&quot;msg&quot; vue实例]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C：冒泡法和选择法]]></title>
    <url>%2F2018%2F12%2F05%2F%E7%AE%97%E6%B3%95%2FC%EF%BC%9A%E5%86%92%E6%B3%A1%E6%B3%95%E5%92%8C%E9%80%89%E6%8B%A9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[冒泡法算法示例用起泡法对10个整数按升序排序。 算法分析如果有n个数，则要进行n-1趟比较。在第1趟比较中要进行n-1次相邻元素的两两比较，在第j趟比较中要进行n-j次两两比较。比较的顺序从前往后，经过一趟比较后，将最值沉底（换到最后一个元素位置），最大值沉底为升序，最小值沉底为降序。 算法源代码12345678910111213141516171819202122232425#include &lt;stdio.h&gt; int main() &#123; int a[10],i,j,t; printf(&quot;Please input 10 numbers: &quot;); /*输入源数据*/ for(i=0;i&lt;10;i++) scanf(&quot;%d&quot;,&amp;a[i]); /*排序*/ for(j=0;j&lt;9;j++) /*外循环控制排序趟数，n个数排n-1趟*/ for(i=0;i&lt;9-j;i++) /*内循环每趟比较的次数，第j趟比较n-j次*/ if(a[i]&gt;a[i+1]) /*相邻元素比较，逆序则交换*/ &#123; t=a[i]; a[i]=a[i+1]; a[i+1]=t; &#125; /*输出排序结果*/ printf(&quot;The sorted numbers: &quot;); for(i=0;i&lt;10;i++) printf(&quot;%d &quot;,a[i]); printf(&quot;\n&quot;); return 0; &#125; 选择法算法示例要求用选择法对10个整数按降序排序。 算法分析每趟选出一个最值和无序序列的第一个数交换，n个数共选n-1趟。第i趟假设i为最值下标，然后将最值和i+1至最后一个数比较，找出最值的下标，若最值下标不为初设值，则将最值元素和下标为i的元素交换。 算法源代码12345678910111213141516171819202122#include &lt;stdio.h&gt; int main() &#123; int a[10],i,j,k,t,n=10; printf(&quot;Please input 10 numbers:&quot;); for(i=0;i&lt;10;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(i=0;i&lt;n-1;i++) /*外循环控制趟数，n个数选n-1趟*/ &#123; k=i; /*假设当前趟的第一个数为最值,记在k中 */ for(j=i+1;j&lt;n;j++) /*从下一个数到最后一个数之间找最值*/ if(a[k]&lt;a[j]) /*若其后有比最值更大的*/ k=j; /*则将其下标记在k中*/ if(k!=i) /*若k不为最初的i值，说明在其后找到比其更大的数*/ &#123; t=a[k]; a[k]=a[i]; a[i]=t; &#125; /*则交换最值和当前序列的第一 个数*/ &#125; printf(&quot;The sorted numbers: &quot;); for(i=0;i&lt;10;i++) printf(&quot;%d &quot;,a[i]); printf(&quot;\n&quot;); &#125; 区别：（个人见解） 冒泡法要进行对n个数进行n-1趟，第j趟要进行n-j次比较，每次比较相邻的数不符合则要交换，每趟最多需要n-j次数的交换 选择法也要进行n-1趟，每趟是选出最值，而选最值是把下标交换，直到选出最值的下标，把最值和第一位交换，每趟最多仅需1次数的交换 简单地说，冒泡法每次都是数的交换（各个下标对应的数是变化的），而选择法是通过下标交换（这时候各个下标对应的数是不变的）选出最值的下标，最后再进行数的交换]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron进阶：打开新窗口]]></title>
    <url>%2F2018%2F11%2F14%2F%E5%85%B6%E4%BB%96%2FElectron%E8%BF%9B%E9%98%B6%EF%BC%9A%E6%89%93%E5%BC%80%E6%96%B0%E7%AA%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[标签实现新窗口打开 增加 target=”_blank”属性 router-link标签只有tag=”a”模式下 target=”_blank” 属性才会生效（vue2） 编程式导航123456let routeData = this.$router.resolve(&#123; name: &quot;searchGoods&quot;, query: params, params:&#123;catId:params.catId&#125; &#125;); window.open(routeData.href, &apos;_blank&apos;);]]></content>
      <categories>
        <category>Electron</category>
      </categories>
      <tags>
        <tag>Electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron：结合vue创建桌面应用]]></title>
    <url>%2F2018%2F11%2F14%2F%E5%85%B6%E4%BB%96%2FElectron%EF%BC%9A%E7%BB%93%E5%90%88vue%E5%88%9B%E5%BB%BA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[首先创建项目并安装好依赖12345vue init webpack test-electroncd test-electronnpm installnpm install electron --save-devnpm install electron-packager --save-dev 其次将零基础中的main.js拷贝到新建项目的build目录下，并更名为electron.js 按照实际项目路径更改electron.js中的路径 12345mainWindow.loadURL(url.format(&#123; pathname: path.join(__dirname, &apos;../dist/index.html&apos;), protocol: &apos;file:&apos;, slashes: true &#125;)) 最后在新建项目package.json文件中增加一条指令 1234567&quot;scripts&quot;: &#123; ... &quot;lint&quot;: &quot;eslint --ext .js,.vue src test/unit/specs test/e2e/specs&quot;, &quot;build&quot;: &quot;node build/build.js&quot;, //增加这条,JSON文件不支持注释，引用时请清除 &quot;electron_dev&quot;: &quot;npm run build &amp;&amp; electron build/electron.js&quot; &#125;, 启动12npm run build //生成dist目录npm run electron_dev //启动electron PS 打包前：更改config/index.js中生产模式下（build）的assetsPublicPth, 原本为 /, 改为 ./ 。]]></content>
      <categories>
        <category>Electron</category>
      </categories>
      <tags>
        <tag>Electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron：从零到完成一个桌面应用]]></title>
    <url>%2F2018%2F10%2F20%2F%E5%85%B6%E4%BB%96%2FElectron%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%88%B0%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Electron 开发环境 安装node 安装cnpm（或者npm） 安装electron 安装打包工具 1npm install -g electron-packager 经典例子electron-quick-start一个简约的记事本12345678//克隆这仓库 git clone https://github.com/electron/electron-quick-start//进入仓库 cd electron-quick-start//安装依赖库 cnpm install//运行应用，也可以用： cnpm run start cnpm start electron-api-demos介绍了主要的一些功能及实现代码 1234git clone https://github.com/electron/electron-api-demoscd electron-api-demoscnpm installcnpm start 开始开发安装electron推荐的安装方法是把electron作为您 app 中的开发依赖项，使您可以在不同的 app 中使用不同的 Electron 版本 在根目录下运行 1npm install --save-dev electron 当然，也可以在 $PATH 中全局安装1npm install electron -g 创建Electron简单文件结构在根目录下创建package.json文件，内容如下 1234567891011&#123; &quot;name&quot;: &quot;test&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;electron .&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;electron&quot;: &quot;^3.0.4&quot; &#125;&#125; 在根目录下创建main.js，内容如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const &#123; app, BrowserWindow &#125; = require(&apos;electron&apos;) // Keep a global reference of the window object, if you don&apos;t, the window will // be closed automatically when the JavaScript object is garbage collected. let win function createWindow () &#123; // 创建浏览器窗口。 win = new BrowserWindow(&#123; width: 800, height: 600 &#125;) // 然后加载应用的 index.html。 win.loadFile(&apos;index.html&apos;) // 打开开发者工具 win.webContents.openDevTools() // 当 window 被关闭，这个事件会被触发。 win.on(&apos;closed&apos;, () =&gt; &#123; // 取消引用 window 对象，如果你的应用支持多窗口的话， // 通常会把多个 window 对象存放在一个数组里面， // 与此同时，你应该删除相应的元素。 win = null &#125;) &#125; // Electron 会在初始化后并准备 // 创建浏览器窗口时，调用这个函数。 // 部分 API 在 ready 事件触发后才能使用。 app.on(&apos;ready&apos;, createWindow) // 当全部窗口关闭时退出。 app.on(&apos;window-all-closed&apos;, () =&gt; &#123; // 在 macOS 上，除非用户用 Cmd + Q 确定地退出， // 否则绝大部分应用及其菜单栏会保持激活。 if (process.platform !== &apos;darwin&apos;) &#123; app.quit() &#125; &#125;) app.on(&apos;activate&apos;, () =&gt; &#123; // 在macOS上，当单击dock图标并且没有其他窗口打开时， // 通常在应用程序中重新创建一个窗口。 if (win === null) &#123; createWindow() &#125; &#125;) // 在这个文件中，你可以续写应用剩下主进程代码。 // 也可以拆分成几个文件，然后用 require 导入。 然后创建index.html文件，内容如下 12345678910&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;TEST&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;span style=&quot;color:#fff;&quot;&gt;Hello World&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 启动app1npm start 或者在package.json中配置1&quot;scripts&quot;: &#123;&quot;start&quot;: &quot;electron .&quot;&#125; 则可以输入一下命令启动1electron . 打包全局安装electron-packager]]></content>
      <categories>
        <category>Electron</category>
      </categories>
      <tags>
        <tag>Electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue+Axios解决文件上传问题]]></title>
    <url>%2F2018%2F09%2F01%2FVue%2FVue%2BAxios%E8%A7%A3%E5%86%B3%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前因关于文件上传，可以使用element-ui中的组件，也可以直接使用input，最近做的一个项目中有用到，查了挺多资料研究了一下，最终就实用性来说还是后者bug少。 现在就这两个介绍一下，如果有错误请提出纠正，或者有更好的可以来分享一下。 Element-UI直接action这个方法很简单，文档中有一一详细列出，重点是下一个 可参考官方文档 利用before-upload属性直接action很方便简单，但是总会有各种难以解决的错误出现如：后台要求请求方式为multipart/form-data时，不能使用data传参数，这时候就要使用formdata对象了。 使用new一个formdata对象，然后对这个对象追加key和value 12345678910//网上给出的例子beforeUpload (file,id) &#123; let fd = new FormData() fd.append(&apos;file&apos;, file) fd.append(&apos;id&apos;,id) axios.post(url, fd, &#123; &#125;) return false // false就是不自动上传&#125;, 改进后我的例子 12345678910111213141516171819202122232425&lt;el-dialog title=&quot;导入报表&quot; :visible.sync=&quot;dialogVisible&quot; width=&quot;30%&quot; :before-close=&quot;handleClose&quot; :append-to-body=&apos;true&apos;&gt; &lt;el-upload class=&quot;upload-demo&quot; ref=&quot;upload&quot; action=&quot;/super_admin/factory/device/import&quot; :limit=&quot;1&quot; :on-exceed=&quot;handleExceed&quot; :file-list=&quot;fileList&quot; :auto-upload=&quot;false&quot; :before-upload=&quot;beforeAvatarUpload&quot; :on-error=&quot;error&quot; :before-remove=&quot;beforeRemove&quot;&gt; &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt; &lt;/el-upload&gt; &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button type=&quot;primary&quot; @click.native=&quot;importTable()&quot;&gt;确 定&lt;/el-button&gt; &lt;/span&gt; &lt;/el-dialog&gt; ``` data() { return { dialogVisible: false, // 所上传的文件 fileList: [] } }, 12 methods: { // 限制上传文件为一个 handleExceed() { this.$message.warning(‘当前限制上传 1 个文件’); }, // 对文件类型进行判断并上传（重点！） beforeAvatarUpload(file) { const isXLSX = file.type === “application/vnd.openxmlformats-officedocument.spreadsheetml.sheet”; if (!isXLSX) { this.$message.error(“上传的文件只能是 xlsx 格式!”); this.fileList = []; }else { let factoryId = this.factoryId; let fd = new FormData(); fd.append(‘file’, file); fd.append(‘factoryId’, factoryId); api.importTable((err, res) =&gt; { if (err || res.status !== 200) { this.$message.error(“出错了，刷新一下吧”); return; } if (res.data.code == 403) { this.$message.error(“该账号没有此操作权限”); } else if (res.data.code == 200) { this.$message({ message: ‘文件上传成功！’, type: ‘success’ }); } else { this.$message.error(“出错了，刷新一下吧”); } },fd); return true } }, // 文件上传失败 error(err) { this.$message({ message: ‘文件上传失败！’, type: ‘warning’ }); }, // 移除已上传的文件 beforeRemove(file) { return this.$confirm(‘确定移除 ‘+file.name+’ ？’); }, // 导入报表至后台 importTable() { this.$refs.upload.submit(); this.dialogVisible = false; }, }12 // 引用instanceimport instance from ‘./instance.js’ function importTable(fn,data) { return instance({ method: “post”, url: ‘/super_admin/factory/device/import’, data: data, headers: { “Content-Type”: “multipart/form-data” } })} export{ importTable} 12345678910### 注意1. 这种方法也有弊端，action作为必填参数，无论是填任意数或者填写重复地址，控制台总会报404。2. FormData对象是不可以通过console.log在控制台直接打印出来的，但可以通过FormData.get()获取值。## input上传这个是重点，就实用来说，掌握一种方法就可以了，这个是目前最成功的（结合后台）。### 使用 12 data() { return { // 上传文件所需的参数 upload: { CurrentfactoryId: “” }, }} 12 methods: { // 打开上传文件的弹出框 handleUpload(index, row) { this.upload.CurrentfactoryId = row.factoryId; this.$refs.importFile.click(); }, // 确认导入列表 confirmUpload() { this.$confirm(‘此操作将上传 ‘+this.$refs.importFile.files[0].name+’ , 是否继续?’, ‘提示’, { confirmButtonText: ‘确定’, cancelButtonText: ‘取消’, type: ‘warning’ }).then(() =&gt; { this.$message.info(‘该过程耗时较长，请耐心等待’); this.importTable(); }).catch(() =&gt; { this.$message({ type: ‘info’, message: ‘已取消上传’ }); this.$refs.importFile.value = null; }); }, // 导入报表至后台 importTable() { let fd = new FormData(document.getElementById(“uploadform”)); // fd.append(“file”, this.upload.importFile); // fd.append(“factoryId”, this.upload.CurrentfactoryId); // console.log(fd.get(‘importFile’)); api.importTable((err, res) =&gt; { if (err) { if (err.response.status === 403 &amp;&amp; err.response.data.code==-2) { this.$message.error(“请登录”); session.clear(); this.$router.push({ path: “/login” }); } else if ( err.response.status === 500) { this.$message.error(“系统出错，请稍后再试”); } else if (err.response.status == 403) { this.$message.error(“该账号没有此操作权限”); } return; } if (res.data.code == 200) { this.$message({ message: “文件上传成功！”, type: “success” }); this.visible = false; } else { this.$message.error(“出错了，刷新一下吧”); } },fd); },} 12 // 引用instanceimport instance from ‘./instance.js’ function importTable(fn,data) { instance.post(‘/super_admin/factory/device/import’, data) .then(function (res) { fn(false, res); }).catch(function (err) { fn(err); });} export{ importTable} ` 注意 如果对于input的样式不满意，可以使用opacity把原来的input透明化来进行美化。 依然是使用formdata对象，虽然使用vue，但不知道为什么用append无法把文件传到后台，因此通过操作节点来新建，如果有人知道可以分享一下。 headers可以不手动添加，浏览器会判定界限，也可以加上。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm：install 出错]]></title>
    <url>%2F2018%2F08%2F22%2FGit%2Fnpm%EF%BC%9Ainstall%20%E5%87%BA%E9%94%99%2F</url>
    <content type="text"><![CDATA[第一种问题123$ npm installnpm WARN registry Unexpected warning for or http://registry.cnpmjs.org/: Mis Miscellaneous Warning ECONNRESET: request to to https://cnpmjs.oss-ap-southeast-1.aliyuncs.com/acorn/-/acorn-5.7.1.tgz fai failed, reason: read ECONNRESETnpm WARN registry Using stale package data from om http://registry.cnpmjs.org/ du/ due to a request error during revalidation. 解决方法12$ npm config set registry ry http://registry.cnpmjs.org$ npm install 第二种问题1234567891011$ npm installnpm ERR! code ECONNRESETnpm ERR! errno ECONNRESETnpm ERR! network request to to https://cnpmjs.oss-ap-southeast-1.aliyuncs.com/arrify/-/arrify-1.0.1.tgz fai failed, reason: read ECONNRESETnpm ERR! network This is a problem related to network connectivity.npm ERR! network In most cases you are behind a proxy or have bad network settings.npm ERR! networknpm ERR! network If you are behind a proxy, please make sure that thenpm ERR! network &apos;proxy&apos; config is set properly. See: &apos;npm help config&apos;npm ERR! A complete log of this run can be found in: 解决方法12$ npm config delete proxy$ npm install 第三种问题12$ npm installnpm ERR! write after end 解决方法降低版本 1npm i -g npm@5.6.0]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github 搭建属于自己的博客（进阶）NexT主题]]></title>
    <url>%2F2018%2F05%2F04%2F%E5%85%B6%E4%BB%96%2FHexo%2BGithub%20%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89NexT%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[主题安装安装NexT在站点目录下（hexo），输入命令： 1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题在站点目录中（blog），打开配置文件_config.yml，修改1theme：next 验证主题1$ hexo s 主题设定以下所有设置注意格式 NexT主题设定可以在next主题目录下的_config.yml文件中修改 12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 基础设置在站点目录下的配置文件_cofig.yml中修改 12345678# Sitetitle: your blog titlesubtitle:description: describe yourselfkeywords:author: yournamelanguage: zh-Hans //简体中文timezone: 修改菜单项在主题目录下修改配置文件_cofig.yml中的menu 123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 这些配置都要与你主题目录下的languages文件中对应的yml文档里配置相关联 12345678910menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 限定主页文章高度修改主题目录下的值 123auto_excerpt: enable: true length: 150 设置头像修改主题目录下Sidebar Avatar的avatar值1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /images/avatar.jpg 地址可以是网络地址，也可以是本地地址（放置在source/images/ 目录下） 添加标签页面点击标签，跳转的页面会显示page not found 此时需要在站点目录的source文件夹里新建tags文件夹，并新建index.md，添加： 12345---title: tagsdate: type: &quot;tags&quot;--- 当要为某一篇文章添加标签，只需在blog/source/_post目录下的具体文章的tags中添加标签即可 实现点击出现桃心效果将代码copy到/themes/next/source/js/src里面新建的love.js中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950! function(e, t, a) &#123; function n() &#123; c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;), o(), r() &#125; function r() &#123; for (var e = 0; e &lt; d.length; e++) d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = &quot;left:&quot; + d[e].x + &quot;px;top:&quot; + d[e].y + &quot;px;opacity:&quot; + d[e].alpha + &quot;;transform:scale(&quot; + d[e].scale + &quot;,&quot; + d[e].scale + &quot;) rotate(45deg);background:&quot; + d[e].color + &quot;;z-index:99999&quot;); requestAnimationFrame(r) &#125; function o() &#123; var t = &quot;function&quot; == typeof e.onclick &amp;&amp; e.onclick; e.onclick = function(e) &#123; t &amp;&amp; t(), i(e) &#125; &#125; function i(e) &#123; var a = t.createElement(&quot;div&quot;); a.className = &quot;heart&quot;, d.push(&#123; el: a, x: e.clientX - 5, y: e.clientY - 5, scale: 1, alpha: 1, color: s() &#125;), t.body.appendChild(a) &#125; function c(e) &#123; var a = t.createElement(&quot;style&quot;); a.type = &quot;text/css&quot;; try &#123; a.appendChild(t.createTextNode(e)) &#125; catch (t) &#123; a.styleSheet.cssText = e &#125; t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a) &#125; function s() &#123; return &quot;rgb(&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;)&quot; &#125; var d = []; e.requestAnimationFrame = function() &#123; return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function(e) &#123; setTimeout(e, 1e3 / 60) &#125; &#125;(), n()&#125;(window, document); 打开\themes\next\layout_layout.swig文件,在末尾（在前面引用会出现找不到的bug） ，引用love.js 1&lt;script src=&quot;/js/src/love.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 添加动态背景打开\themes\next\layout_layout.swig文件，在 之前添加代码(注意不要放在&lt; /head&gt;的后面) 123&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 打开开\themes\next_config.yml,在里面修改为如下代码 1canvas_nest: true 在网站底部加上访问量打开 \themes\next\layout_partials\footer.swig 文件,在开头加上这段代码： 123&#123;% if theme.footer.counter %&#125; &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 在 \themes\next_config.yml 中进行配置 12345678910111213141516171819footer: counter: truebusuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 访客数 site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; 总访问量 site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; 阅读数 page_pv_footer: 在每篇文章末尾添加“本文结束”标记在路径 \themes\next\layout_macro 中新建 passage-end-tag.swig 文件,并添加以下内容 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout_macro\post.swig文件，在post-body 之后， post-footer 之前添加如下代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 打开主题配置文件,在末尾添加 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 侧边栏社交链接在主题配置文件中修改： 12345678910111213# Social linkssocial: GitHub: https://github.com/your-user-name Twitter: https://twitter.com/your-user-name 微博: http://weibo.com/your-user-name# Social Iconssocial_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter 微博: weibo 添加小图标在主题配置文件中修改： 123favicon: #small: /images/favicon.ico medium: /images/favicon.ico 添加评论使用系统：==gitment==，它是基于 github 开发的，是依靠于 GitHub Issues 的评论系统，Next &gt;= 5.1.2 进入 developer settings 申请 oAuth Apps Homepage URL 和 Authorization callback URL 填写博客地址 获取 client_id 和 client_secret 新建github项目存放comment 配置 \themes\next_config.yml 12345678910111213gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide &apos;Powered by ...&apos; on footer, and more language: # Force language, or auto switch by theme github_user: [] # MUST HAVE, Your Github ID github_repo: [comment github url] # MUST HAVE, The repo you use to store Gitment comments client_id: [client id] # MUST HAVE, Github client id for the Gitment client_secret: [client secret] # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 生成部署，有时候预览没有效果 每篇文章都需要初始化评论页面才能开始使用评论功能 部署之后，有可能碰到 Not Found Error，再等待一会儿就可以了 其他 NexT主题美化 除了NexT还有很多其他好看的主题，百度会有很多方法的]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM]]></title>
    <url>%2F2018%2F05%2F03%2FJS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2FDOM%2F</url>
    <content type="text"><![CDATA[节点层次小结 DOM可以将任何HTML或XML文档描绘成一个由多层次节点构成的结构。 节点之间的关系构成层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构 文档节点是每个文档的根节点，通过文档节点表示的元素称之为文档元素 文档元素是文档的最外层元素，文档中的其他元素都包含在文档元素中 每个文档只能有一个文档元素，在HTML页面中，文档元素始终都是元素 HTML元素通过元素节点表示，特性(属性）通过特性节点表示，注释通过注释节点表示…… 以下类型属性和方法的详细内容可参考红宝书，也可参考第19章DOM基础的pdf，在这里就不一一列出了 Node类型JavaScript中的所有节点类型都继承自Node类型 节点属性（所有节点都有） 属性 用途 nodeName 获取元素的标签名 nodeValue 返回节点的节点值 childNodes 获取当前元素节点的所有子节点 firstChild 获取当前元素节点的第一个子节点 lastChild 获取当前元素节点的最后一个子节点 ownerDocument 获取该文档的文档根节点 parentNode 获取当前节点的父节点 previousSibling 获取当前节点的前一个同级节点 nextSibling 获取当前节点的后一个同级节点 childNodes属性保存着一个NodeList对象，是一种类数组对象，用于保存一组有序的节点 操作节点（所有节点都可用） 方法 用途 appendChild() 将新节点追加到子节点列表的末尾 insertBefore() 将新节点插入到参考节点的前面 replaceChild() 将新节点替换掉旧节点 removeChild() 移除节点 cloneNode() 复制节点 Document类型JavaScript通过Document类型表示文档 查找元素 方法 作用 getElementsByTagName() 获取相同元素的节点列表 getElementByName() 获取相同名称的节点列表 getElementById() 获取特定id元素的节点 文档写入 方法 用途 write() 原样写入 writeln() 在字符串末尾添加换行符（\n） open() 打开网页的输出流 close() 关闭网页的输出流 Element类型 在HTML中，标签名始终都以全部大写表示 1alert(div.tagname);//DIV title特性：鼠标移动到该元素之上时显示的内容 操作特性 方法 用途 getAttribute() 获取特定元素节点属性的值 setAttribute() 设置特定元素节点属性的值 removeAttribute() 移除特定元素节点属性 attributes属性Element类型是使用attributes属性的唯一一个DOM节点类型。attributes属性中包含一个NameNodeMap，是一个“动态”的集合，里面每一项为元素的特性 创建元素 1document.createElement(要创建元素的标签名); 创建的新元素尚未被添加在文档树中，因此浏览器无法显示可以用appendChild()等方法把其添加到文档树中 Text类型文本节点由Text类型表示，包含的是可以照字面解释的纯文本内容 创建文本节点 1document.createTextNode(要插入节点中的文本); 同样，除非把新节点添加到文档树中已经存在的节点中，否则不会在浏览器看到新节点 规范文本节点normalize() 将所有文本节点合并成一个节点 分割文本节点splitText()将一个文本节点分为两个文本节点 Comment类型表示注释 CDATASection类型表示CDATA区域，只针对基于XML的文档 DocumentType类型包含着与文档的doctype有关的所有信息，不常用 DocumentFragment类型表示文档片段 Attr类型表示元素的特性 DOM操作技术以下两种技术均建议插入外部文件 动态脚本 使用script元素包含js代码直接插入head元素中 插入外部文件（建议）可添加到head元素中，也可添加到页面中 1&lt;scripr type=&quot;text/javascript&quot; src=&quot;URL&quot;&gt;&lt;/script&gt; 动态样式 使用style元素包含指定嵌入的样式插入head元素中 插入外部文件（建议）必须将link元素添加到head元素中 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;URL&quot;/&gt;]]></content>
      <categories>
        <category>红宝书</category>
      </categories>
      <tags>
        <tag>红宝书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数表达式]]></title>
    <url>%2F2018%2F05%2F03%2FJS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[函数表达式定义函数的方式使用函数声明12345function 函数名(参数)&#123; //函数体&#125;可通过name属性访问函数名（即标识符）（有何意义？）alert(函数名.name);//函数名 使用函数表达式这种情况下创建的函数叫匿名函数顾名思义，因为 function关键字后面没有函数名（即标识符）123var 变量=function()&#123; //函数体&#125;; 两者的主要区别（1） 函数声明无论置于调用语句前后，解析器都会先读取函数声明 后面不能跟圆括号 由于函数声明的一个重要特征—函数声明提升（在执行代码之前会先读取函数声明）这意味着可以把函数声明放在调用它的语句后面 （2）函数表达式则要等到解析器执行到它所在代码行才被真正执行 后面可以跟圆括号，表示立即自我执行 则函数表达式需要先把函数赋值给变量，再调用函数 递归递归函数是在一个函数通过名字调用自身的情况下构成的 1234567function factorial(num)&#123; if(num&lt;=1)&#123; return 1; &#125;else&#123; return num*factorial(num-1); &#125;&#125; 缺点：把该函数保存在另一个变量中，且将factorial变量设置为null时（即当函数名改变了时），导致错误 改进arguments.callee是一个指向正在执行的函数的指针，通俗一点讲就是指向拥有arguments对象的函数 1234567function factorial(num)&#123; if(num&lt;=1)&#123; return 1; &#125;else&#123; //arguments.callee代替函数名 return num*arguments.callee(num-1); &#125;&#125; 闭包概念在讲述闭包之前必须先引入几个概念：函数的执行环境(excution context)、活动对象(call object)、作用域(scope)、作用域链(scope chain)以函数a从定义到执行的过程为例阐述： ① 当定义函数a的时候，js解释器会将函数a的作用域链设置为定义a时a所在的“环境”，如果a是一个全局函数，则作用域链中只有全局变量对象。 ② 当执行函数a的时候，a会进入相应的执行环境。 ③ 在创建执行环境的过程中，首先会为a添加一个scope属性，即a的作用域，其值就为第1步中作用域链。 ④ 然后执行环境会创建一个活动对象（活动对象也是一个拥有属性的对象，但它不具有原型而且不能通过JavaScript代码直接访问）。创建完活动对象后，把活动对象添加到a的作用域链的最顶端。 ⑤下一步是在活动对象上添加一个arguments属性，它保存着调用函数a时所传递的参数。 ⑥ 最后把所有函数a的形参和内部的函数b的引用也添加到a的活动对象上。在这一步中，完成了函数b的的定义，因此如同第3步，函数b的作用域链被设置为b所被定义的环境，即a的作用域。 a的作用域链（本质上是一个指向变量对象的指针列表）包含 本地活动对象：arguments属性，a的变量，函数 全局变量对象 小结 闭包是指有权访问另一个函数作用域中的变量的函数，通过模拟全局作用域，使局部变量变为全局变量闭包就是将函数内部和函数外部连接起来的一座桥梁 创建闭包的常用方式：在一个函数内部创建另一个函数 JavaScript中所有的function都是一个闭包。 不过一般来说，嵌套的function所产生的闭包更为强大，也是大部分时候我们所谓的“闭包”。 闭包的用途 1、使其可以访问其外部函数作用域中的变量2、可以实现局部变量驻留在内存中从而累加通常函数的作用域及其所有变量会在函数执行结束后被销毁。 但由于闭包（内部函数）的作用域链包含外部函数（非全局）的活动对象。当函数返回一个闭包时，函数的作用域将会一直在内存中保存到闭包不存在为止 关于this对象 闭包运行时this指向window 12345678910var name=&quot;The window&quot;;var object=&#123; name:&quot;The Object&quot;, getNameFunc:function()&#123; return function()&#123; return this.name; //这里的作用域，this指向window &#125;; &#125;&#125;;alert(object.getNameFunc()()); //&quot;The window&quot; 改进1 可适用对象冒充的方式使this指向object 1alert(object.getNameFunc().call(object)); //对象冒充 改进2 访问作用域中的this/arguments对象，必须将对该对象的引用（this）保存到另一个闭包能够访问的变量中 12345678910111213var name=&quot;The window&quot;;var object=&#123; name:&quot;The Object&quot;, getNameFunc:function()&#123; var that=this; //这里的作用域，this指向object return function()&#123; return that.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); //&quot;The Object&quot;不过这个不会常用，太绕了！！！理解思路即可 改进3 这不是闭包，也不算改进，只是通常是用这种来表示 12345678var name=&quot;The window&quot;;var object=&#123; name:&quot;The Object&quot;, getNameFunc:function()&#123; return this.name; &#125;&#125;;alert(object.getNameFunc()); //&quot;The Object&quot; 模仿块级作用域在JavaScript中，从变量有定义开始，就可以在函数内部随处访问它，即使错误地重新声明同一个变量，也不会改变它的值，当然，重新赋值是会改变的 1234567(function()&#123; //这里是块级作用域&#125;)();JavaScript将function关键字当作一个函数声明的开始，而函数声明后面不能跟圆括号，给函数声明加上一对圆括号即转换成函数表达式，后面就可以跟圆括号了 使用块级作用域，匿名函数中定义的任何变量，都会在执行结束时被销毁这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数，能有效防止命名冲突 私有变量严格来讲，JavaScript中没有私有成员的概念，所有对象属性都是公有的，不过有一个私有变量的概念私有变量包括函数的参数、局部变量和在函数内部定义的其他函数 特权方法有权访问私有变量的公有方法，在公共域可见，不可被修改，只能替换/删除 在这里提出一个问题：在函数外部私有变量不可访问，又为什么用特权方法使之可以访问呢？为什么不直接舍弃而用公有方法呢？（个人理解）私有变量除了不可访问还不可修改，可隐藏那些不该被直接修改的数据，但私有变量在函数外部不可见，因此通过特权方法访问它们但也仅仅是访问而已 创建特权方法的方式方法1在构造函数中定义特权方法 123456789101112function MyObject()&#123; //私有变量和私有函数 var privateVariable=10; function privateFunction()&#123; return true; &#125; //特权方法 this.publicMethod=function()&#123; privateVariable++; return privateFunction(); &#125;;&#125; 方法2在私有作用域中定义私有变量和函数，通过构造函数的原型定义特权方法 1234567891011121314(function()&#123; //私有变量和私有函数 var privateVariable=10; function privateFunction()&#123; return true; &#125; //构造函数,在函数中不带var的变量为全局变量 MyObject=function()&#123; &#125;; //有点像原型模式创建对象 //公有/特权方法 MyObject.prototype.publicMethod=function()&#123; privateVariable++; return privateFunction(); &#125;;&#125;)(); //匿名函数的自我执行 方法3模块模式前两种方法是用于以构造函数的方式创建私有变量和特权方法的这种是用于以对象字面量的方式为单例创建私有变量和特权方法的 单例：只有一个实例的对象，其实为对象字面量声明方式，永远实例化一次 1234567891011121314151617181920212223//以对象字面量的方式创建单例对象var singleton=&#123; name:value, method:function()&#123; //这里是方法的代码 &#125;&#125;//为单例对象添加私有变量和特权方法使其增强var singleton=function()&#123; //私有变量和私有函数 var privateVariable=10; function privateFunction()&#123; return true; &#125; //公有/特权方法和属性 return&#123; publicProperty:true, publicMethod:function()&#123; privateVariable++; return privateFunction(); &#125; &#125;;&#125;(); //匿名函数的自我执行 方法4增强的模块模式在返回对象之前加入对其增强的代码适合那些单例必须是某种类型的实例，同时还必须添加某些属性或方法对其加以增强的情况 1234567891011121314151617var singleton=function()&#123; //私有变量和私有函数 var privateVariable=10; function privateFunction()&#123; return true; &#125; //创建对象 var object=new CustomType(); //公有/特权方法和属 object.publicProperty:true, object.publicMethod=function()&#123; privateVariable++; return privateFunction(); &#125;; //返回这个对象 return object;&#125;(); //匿名函数的自我执行]]></content>
      <categories>
        <category>红宝书</category>
      </categories>
      <tags>
        <tag>红宝书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON与Ajax]]></title>
    <url>%2F2018%2F05%2F03%2FJS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2FJSON%E4%B8%8EAjax%2F</url>
    <content type="text"><![CDATA[JSON语法 简单值字符串、数值、布尔值、null，但不支持undefined JSON字符串必须使用双引号 对象 12345678910JavaScript: var object=&#123; name:&quot;Greg&quot;, age:27 &#125;;JSON: &#123; &quot;name&quot;:&quot;Greg&quot;, &quot;age&quot;:27 &#125; 1、JSON对象没有声明变量（JSON没有变量）2、JSON对象没有末尾的分号 PS：JSON对象的属性必须加双引号 数组 12JavaScript： var values=[25,&quot;hi&quot;,true];JSON: [25,&quot;hi&quot;,true] JSON数组没有变量和分号 解析与序列化全局对象JSON有两个方法：stringify() 把JavaScript对象序列化成JSON字符串parse() 把JSON字符串解析为原生JavaScript值 序列化选项 stringify()参数：第一个是过滤器数组过滤器：JSON.stringify()的结果中只包含数组中列出的属性函数过滤器：函数接收属性（键）名和属性值，返回结果为相应值第二个是一个选项表示是否在JSON字符串中保留缩进第三个控制结果中的缩进和空白符 toJSON()方法可以给对象定义toJSON()方法，返回其自身的JSON数据格式 解析选项JSON.parse()接收一个参数：还原函数与JSON.stringify()接收的替换（过滤）函数，两者签名相同 JSON小结 JSON是JavaScript的一个严格的子集，利用了JavaScript中的一些模式来表示结构化数据 JSON是一个轻量级的数据格式，可以简化表示复杂数据结构的工作量 JSON不支持变量、函数或对象实例，它就是一种表示结构化数据的格式 JSON字符串和JSON对象属性必须加双引号 Ajax还没学JQ，暂用原生JS 123456789101112131415161718192021兼容function createXHR()&#123; if(typeof XMLHttpRequest !=&quot;undefined&quot;)&#123; return new XMLHttpRequest(); &#125;else if(typeof ActiveXObject !=&quot;undefined&quot;)&#123; var version=[ &quot;MSXML2.XMLHttp6.0&quot;, &quot;MSXML2.XMLHttp3.0&quot;, &quot;MSXML2.XMLHttp&quot; ]; for(var i=0;i&lt;version.length;i++)&#123; try&#123; return new ActiveXObject(version[i]); &#125;catch(e)&#123; //跳过 &#125; &#125; &#125;else&#123; throw new Error(&quot;您的系统浏览器不支持XHR对象!&quot;) &#125;&#125; XMLHttpRequest 属性 说明 responseText 作为响应主体被返回的文本 responseXML …… status 响应HTTP状态（200为成功） statusText HTTP状态的说明 HTTP状态码2字头：成功3字头：重定向4字头：请求错误5、6字头：服务器错误 HTTP两种头部信息响应头部信息：服务器返回的信息，客户端可以获取但不可以设置请求头部信息：客户端发送的信息，客户端可以设置但不可以获取 同步与异步 同步 12345678910addEvent(document,&quot;click&quot;,function()&#123; var xhr=createXHR(); xhr.open(&quot;get&quot;,demo.txt,false); xhr.send(null); if(xhr.status==200)&#123; alert(xhr.respenseText); &#125;else&#123; alert(&quot;获取数据错误 错误代号：&quot;+xhr.status+&quot;,错误信息：&quot;+xhr.statusText); &#125;&#125;); 异步 123456789101112131415addEvent(document,&quot;click&quot;,function()&#123; var xhr=createXHR(); xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; if(xhr.status==200)&#123; alert(xhr.respenseText); &#125;else&#123; alert(&quot;获取数据错误 错误代号：&quot;+xhr.status+&quot;,错误信息：&quot;+xhr.statusText); &#125; &#125; &#125;; xhr.open(&quot;get&quot;,demo.txt,true); //xhr.abort(); 取消异步请求，在接收到响应之前使用 xhr.send(null);&#125;); GET与POST在Web程序上，GET一般是URL提交请求，如demo.php?nme=Lee&amp;age=27POST一般是Web表单提交 GET请求 12345678demo1.php&lt;?php$username = $_GET[&apos;username&apos;];$age = $_GET[&apos;age&apos;];echo &quot;你的名字：&#123;$username&#125;，年龄：&#123;$age&#125;&quot;;?&gt; 1234567891011121314addEvent(document,&quot;click&quot;,function()&#123; var xhr=createXHR(); xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; if(xhr.status==200)&#123; alert(xhr.respenseText); &#125;else&#123; alert(&quot;获取数据错误 错误代号：&quot;+xhr.status+&quot;,错误信息：&quot;+xhr.statusText); &#125; &#125; &#125;; xhr.open(&quot;get&quot;,&quot;demo1.php?username=Lee&amp;age=27&quot;,true); xhr.send(null);&#125;); POST请求 12345678demo2.php&lt;?php$username = $_POST[&apos;username&apos;];$age = $_POST[&apos;age&apos;];echo &quot;你的名字：&#123;$username&#125;，年龄：&#123;$age&#125;&quot;;?&gt; 123456789101112131415161718addEvent(document,&quot;click&quot;,function()&#123; var xhr=createXHR(); xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; if(xhr.status==200)&#123; alert(xhr.respenseText); &#125;else&#123; alert(&quot;获取数据错误 错误代号：&quot;+xhr.status+&quot;,错误信息：&quot;+xhr.statusText); &#125; &#125; &#125;; //第一步：改为post xhr.open(&quot;post&quot;,&quot;demo2.php&quot;,true); //第三步：模拟表单提交，申明发送的数据类型 xhr.setRequestHeader(&apos;content-type&apos;, &apos;application/x-www-form-urlencoded&apos;); //第二步：将名值对放入send()方法里 xhr.send(&quot;username=Lee&amp;age=27&quot;);&#125;); Ajax步骤 创建对象 调用open()启动一个请求以备发送 调用send()发送请求 接收响应]]></content>
      <categories>
        <category>红宝书</category>
      </categories>
      <tags>
        <tag>红宝书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件]]></title>
    <url>%2F2018%2F05%2F03%2FJS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[事件流 事件冒泡事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档） 事件捕获不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件事件捕获用意在于在事件到达预定目标之前捕获它 DOM事件流（事件流描述的是从页面中接收事件的顺序） 事件捕获阶段（从document开始） 处于目标阶段 事件冒泡阶段 事件处理程序HTMl事件处理程序某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML特性来指定 特性的值 可以是能够执行的js代码 1&lt;input type=&quot;button&quot; value=&quot;按钮&quot; onclick=&quot;alert(&apos;Clicked&apos;)&quot;/&gt; 也可以调用在页面其他地方定义的脚本 123456&lt;input id=&quot;btn&quot; value=&quot;click me&quot; onclick=&quot;showMessage()&quot; /&gt;&lt;script type=&quot;text/javascript&quot;&gt; function showMessage()&#123; alert(&quot;clicked&quot;); &#125;&lt;/script&gt; 扩展作用域 12345678function()&#123; with(document)&#123; eith(this)&#123; //元素属性值 &#125; &#125;&#125; 在这个函数内部，可以像访问局部变量一样访问document 及该元素本身的成员 DOM0级事件处理程序（主要）通过JavaScript指定处理程序的传统方式，将一个函数赋值给一个事件处理程序属性。每个元素（包括document和window）都有自己的事件处理程序属性以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理 123456789var btn = document.getElementById(&quot;btn&quot;);btn.onclick = function()&#123; alert(&quot;Clicked&quot;); //指定事件处理程序&#125;;btn.onclick=function()&#123; alert(this.id);//btn //其作用域为元素的作用域&#125;//想要取消事件处理程序的话，只需将事件处理程序属性设为null即可btn.onclick = null; DOM2级事件处理程序用于处理指定和删除事件处理程序的操作：addEventListener()和removeEventListener() 12345678//指定事件处理程序 btn.addEventListener(&quot;click&quot;,fucntion()&#123;alert(&quot;clicked&quot;);&#125;,false);//取消事件处理程序btn.removeEventListener(&quot;click&quot;,function()&#123;alert(&quot;clicked&quot;);&#125;,false);//无效//指定和取消的参数必须完全相同才有效//而匿名函数是两个不同的函数，所以无效 为了能够取消，最好函数采用函数表达式 1234567var handler = function()&#123; alert(&quot;clicked&quot;); &#125;;//添加事件处理程序btn.addEventListener(&quot;click&quot;,handler,false);//取消事件处理程序btn.removeEventListener(&quot;click&quot;,handler,false);//有效 IE事件处理程序用于处理指定和删除事件处理程序的操作：attachEvent()和detachEvent() IE事件处理程序与DOM事件处理程序的最大区别：DOM0/2级事件处理程序的作用域是元素作用域；而IE事件处理程序是全局作用域，即this等于widow 123456789var handler = function()&#123; alert(&quot;clicked&quot;); &#125;;//指定事件处理程序btn.attachEvent(&quot;onclick&quot;,handler);//取消事件处理程序btn.detachEvent(&quot;onclick&quot;,handler);//取消参数必须与添加完全相同所以事件处理程序函数(同DOM2级事件中的分析一样)不要是匿名函数。 跨浏览器的事件处理程序用于处理指定和删除事件处理程序的操作：addHandler()和removeHandler()这两个方法属于一个名叫EventUtil的对象 1234567var handler = function()&#123; alert(&quot;Clicked&quot;);&#125;;//指定事件处理程序EventUtil.addHandler(btn,&quot;click&quot;,handler);//移除事件处理程序EventUtil.removeHandler(btn,&quot;click&quot;,handler); 事件对象在触发DOM上的某个事件时，会产生一个事件对象event。这个对象中包含着所有与事件有关的信息。包括导致事件的元素，事件的类型以及其他与特定事件相关的信息所有浏览器都支持event对象，event对象会传入DOM0级，DOM2级，HTML指定的事件处理程序中，但支持的方式不同，所以也会涉及跨浏览器的部分 DOM中的事件对象 相关属性方法详见书355 两个有点难区分的属性： currentTarget：this对象始终是指向它的值，为其事件处理程序当前正在处理事件的那个元素 target：只包含事件的目标 IE中的事件对象 相关属性方法详见书359 跨浏览器的事件对象对前面介绍到的EventUtil对象加以增强添加如下方法 ，写一个通用的事件侦听函数即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546听说面试会问到，这样写就可以了var EventUtil=&#123;getEvent:function(event)&#123; return event||window.event;&#125;,getTarget:function(event)&#123; return event.target||event.srcElement;&#125;,preventDefault:function()&#123; if(event.preventDefault)&#123; event.preventDefault(); &#125;else&#123; event.returnValue=false; &#125;&#125;,stopPropagation:function()&#123; if(event.stopPropagation)&#123; event.stopPropagation(); &#125;else&#123; event.cancelBubble=true; &#125;&#125;,addHandler:function(element,type,handler)&#123; if(element.addEventListener)&#123; element.addEventListener(type,handler,false); &#125;else if(element.attachEvent)&#123; element[&quot;e&quot;+type]=function()&#123; handler.call(element) &#125; element.attachEvent(&quot;on&quot;+type,element[&quot;e&quot;+type]); &#125;else&#123; element[&quot;on&quot;+type]=handler; &#125;&#125;,removeHandler:function(element,type,handler)&#123; if(element.removeEventListener)&#123; element.removeEventListener(type,handler,false); &#125;else if(element.detachEvent)&#123; element.detachEvent(&quot;on&quot;+type,element[&quot;e&quot;+type]); element[&quot;e&quot;+type]=null; &#125;else&#123; element[&quot;on&quot;+type]=null; &#125;&#125; &#125;; 事件类型 好像没什么必要一一列出来了，详见书中362 内存和性能事件委托 利用冒泡的原理，把事件加到父级上，触发执行效果 通俗的讲，就是这个事件本来是加在某些元素上的，然而你却加到别人身上来做，完成这个事件 使用事件委托，只需在DOM树中尽量最高的层次上添加一个事件处理程序 移除事件处理程序 从文档中移除带有事件处理程序的元素时 卸载页面时 模拟事件DOM中的事件模拟 调用document.createEvent()方法创建event对象 初始化对象，为对象添加相关信息 调用dispatchEvent()方法触发事件 IE中的事件模拟 调用document.createEventObject()方法创建event对象 初始化对象，为对象添加相关信息 调用fireEvent()方法触发事件]]></content>
      <categories>
        <category>红宝书</category>
      </categories>
      <tags>
        <tag>红宝书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github 搭建属于自己的博客（基础）]]></title>
    <url>%2F2018%2F05%2F03%2F%E5%85%B6%E4%BB%96%2FHexo%2BGithub%20%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[搭建环境准备Node.js 的安装和准备12$ node -v$ npm -v git的安装和准备1$ git --version github账户的配置 github账户注册 创建新仓库 注意：仓库名称一定为 github用户名.github.io 仓库设置 接下来开启github pages功能 ，点击界面右侧的 Settings，你将会打开这个库的settings页面，向下拖动，直到看见GitHub Pages 安装hexo在任意一个地方创建文件夹hexo，进入到该目录输入： 1$ npm install hexo-cli -g 然后可能会看到一个WARN，并不会影响操作，继续输入： 1$ npm install hexo --save 1$ hexo -v hexo的相关配置 初始化hexo 12$ hexo init &lt;新文件夹&gt; $ cd &lt;新文件夹&gt; 首次体验hexo 123$ hexo g$ hexo s //若一直无法跳转，则是端口被占用$ hexo server -p 5000 //改变端口号 配置Git个人信息如果之前已经配置好git个人信息，请跳过这一个步骤 设置Git的user name和email 12$ git config --global user.name &quot;yourusername&quot;$ git config --global user.email &quot;youremail&quot; 生成密钥 1$ ssh-keygen -t rsa -C &quot;youremail&quot; 配置Deployment在_config.yml文件中，找到Deployment，然后按照如下修改： 1234deploy: type: git repo: https://github.com/yourname/yourname.github.io.git branch: master 写博客、发布新文章 新建一篇博客 1$ hexo new post &quot;article title&quot; 用MarDown编辑器打开就可以编辑文章了 生成、部署 123$ hexo g // 生成$ hexo s // 本地预览$ hexo d // 部署 1$ hexo d -g //在部署前先生成 踩坑提醒 注意需要提前安装一个扩展 1npm install hexo-deployer-git --save 如果没有执行这行命令，将会提醒 deloyer not found:git]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F03%2F%E5%85%B6%E4%BB%96%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>demo</category>
      </categories>
      <tags>
        <tag>demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm：清理缓存]]></title>
    <url>%2F2018%2F03%2F28%2FGit%2Fnpm%EF%BC%9A%E6%B8%85%E7%90%86%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[旧版本（4及以下）1$ npm cache clean 新版本（5）先尝试1$ npm cache clean --force 若不行则使用下面的命令 1$ npm cache clear --force &amp;&amp; npm install --no-shrinkwrap --update-binary]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习路线规划]]></title>
    <url>%2F2018%2F01%2F23%2F%E5%89%8D%E7%AB%AF%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[前端学习路线规划一、代码编写工具sublime Text 3: sublime text编辑器单从界面看非常简洁，可以说让人一见倾心的感觉。完全符合码农的口味~~。功能上也不复杂，就跟记事本似的，很容易上手。 可以自由扩展，sublime提供了安装插件的方式，可以任意安装你想要的插件. 二、学习路线规划1. 熟练使用 HTML、CSSHTML 是标签语言，可以构建前端页面的骨架；CSS是层叠样式控制表，可以构建前端页面的外貌 这部分比较简单，到网上搜资料，书籍视频非常多。css中盒子模型，流动，block，inline，层叠，样式优先级等这些比较重要。最后再深入了解下浏览器差异性，ie9以下兼容简单了解就行了，ie9以下浏览器被淘汰掉是趋势，低版本没必要浪费大量时间去学习兼容主流浏览器，google chrome浏览器、firefox浏览器、safari浏览器、opera浏览器即可。浏览器差异内容很多，建议在实践中多多积累。 12推荐书籍：《Head First HTML 与 CSS (第2版)》 《CSS 禅意花园(修订版)》 2.javascript部分（最重要的部分）难点，也是重点，要学的内容实在很多，如果没有其他编程语言的基础的话，学起来可能要费些力，有很多比较抽象的概念，必须要深入理解，比如闭包、原型、面向对象、封装等，要理解透彻。看书是必不可少的，找一本优秀的js书从头到尾深入学习了。另外，js面向对象编程必须要学习，非常重要，个人推荐一本书《javascript高级程序设计》。边学边练，实践出真知。 1234推荐教程：网易云课堂上 李炎恢老师的视频，讲得很详细，讲的是和那本红宝书一样的内容 多动手写demo推荐书籍：《Javascript 权威指南》 《JavaScript 高级程序设计(第3版)》 3.jQuery学习（这不是一个框架，是一个类库）这些基础知识掌握好之后，还需要学jQuery，这是一个非常优秀的Javascript库，大型开发必备。它简化了Javascript的复杂操作，消除了Javascript跨平台兼容问题，提供了大量实用方法，有良好的文档和帮助手册，是一个非常成熟的Javascript库。 12推荐教程：网易云课堂上 李炎恢老师的视频，多动手写demo推荐书籍：《锋利的jquery》 4.ajax的学习通过在后台与服务器进行数据交换，AJAX可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新，ajax是现在前端后台交互的主要方式。 12掌握的知识点：js原生的发送ajax的方法 jq的简便的发送ajax的方法 5.gitGit是目前世界上最先进的分布式版本控制系统，适合于在团队合作时进行版本控制，提高开发效率 1推荐教程：廖雪峰老师的关于git的教程博客 6.理解前端语言新标准 HTML5、CSS3、ES6 及其特性熟练使用 HTML、CSS、JavaScript 还需要我们理解其语言最新相关标准：HTML5、CSS3 和 ES6(ECMAScript6)。 HTML 5 里新增了许多特性：语义化和新的音频、视频支持等； CSS 3 被划分为模块，解决了 CSS2 为等待各个标准统一而耗费大量时间才能推进的不足之处，同时也提供了 2D、3D、动画效果等新特性； ECMAScript6 等于 JavaScript - DOM - BOM，是 JavaScript 在 2015 年的最新标准，因为 ES6 对标准改动较大，前端开发者常常将一个前端项目是否支持 ES6 作为推进前端新技术的重要桥梁之一。ES6 将箭头函数、let 变量声明命令、Promise 编程、模块化编程等新特性纳入其标准中，得到了各大浏览器最新版本的支持。 12扩展阅读：《ES6 标准入门(第2版)》 《深入理解ES6》 7.掌握浏览器兼容、响应式布局相关解决方案早期占据浏览器半壁江山的IE浏览器上存在的众多浏览器兼容问题，耗费了当时前端开发者的大量开发时间。虽然说现在的前端开发者已经不需要考虑太多的浏览器兼容问题，对其概念的了解有利于了解前端历史包袱或在未来足以应对一些面向特殊群体(早期 IE 浏览器使用者)的前端项目。关于IE浏览器的兼容性问题在李炎恢老师的那个视频有详细的讲解 响应式布局和单页面应用是当代前端开发者的必备技能。从 Web Pages 到 Web App 时代，我们开发的前端项目有越来越多的可能需要同时在电脑端和手机端进行访问，一个有良好响应式布局的前端项目可以一个代码运行在多种不同分辨率的平台之上。 三、现在前端主流的框架1. vuejs :2016年最火的前端框架（MVVC框架）是一套用于构建用户界面的渐进式框架Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 常用于单页面应用的开发 12345678掌握的要点：(vue全家桶) 1.vue-router 2.vuex 3.vue-resource 4.vue-cli 5.Element-ui 推荐教程：详细阅读官网教程，中国人自己研发的，有中文版，不难 2. ReactjsReact 是一个用于构建用户界面的 javascript 库。 React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。 React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。 React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。 React特点： 1234561.声明式设计 −React采用声明范式，可以轻松描述应用。2.高效 −React通过对DOM的模拟，最大限度地减少与DOM的交互。3.灵活 −React可以与已知的库或框架很好地配合。4.JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。5.组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。6.单向响应的数据流 − React实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。 123456掌握的知识点：（React全家桶技术） 1.Reactjs 2.React生命周期 3.React Router 4.Redux 5.React Native(主要用于移动端的开发) 3.AngularJS（国外开发大型项目常用框架）AngularJS的四大功能： MVC 将后台的MVC模式写入了前端语言中。我总觉得前端语言将来会很叼，从node.js开始我就又一种这样的感觉。可能在很久之后取代后端语言不是没有可能的。 模块化 就是一系列函数的集合，当应用被启动时，这些函数就会被执行。主要利用angular.module来定义模块。也是Angular.js的亮点。 指令属性 我自己的理解就是比html标签更加具有属性和方法的指令标签 双向数据绑定 传统的数据绑定是单向绑定，数据只能从model和controller生成需要的html，但是不能返过来使用。只是单方向的。双向数据绑定:也就是说我在前面填写，后面直接生成代码，将填写的显示出来。双向的意思就是如果view修改了属性值，那么model机会看到这个改变。相反也是一样的。 4. 小程序（类似一个前端开发框架）1推荐教程：官网上的小程序开发文档，尝试动手写一下小程序 5.nodejs(前端用来写后台的工具)简单的说 Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。 Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。1推荐教程：官网的教程 四、一些常用的ui框架1. Bootstrape：最好的响应式css框架2. Element-ui：完美适应vuejs的ui框架3. Amazeui：Amaze UI 是一个轻量级、 Mobile first 的前端框架, 基于开源社区流行前端框架编写的。4. Aliceui5.Echart：最好的图表制作框架·····六、前端最好掌握的一些常用技能 Markdown笔记的使用，程序员专用笔记本 github的使用：全球最大的开源代码网站，在上面你可以找到全世界所有出名项目的源代码，被称为人类的知识宝库。 用github page搭建个人博客，上传个人项目到github上，面试加分必备项 移动端的开发 前端web开发命名规范，谷歌、百度命名标准 等等·······]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
