<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vite]]></title>
    <url>%2F2022%2F04%2F26%2F%E5%89%8D%E7%AB%AF%2Fvite%2F</url>
    <content type="text"><![CDATA[1.概述 项目基本是基于webpack进行打包的，随着模块的增多及需求的迭代，启动、发布等都会越来越慢，为了对此进行优化，开展对vite的调研。 调研 Vite 打包工具 与AN业务的适用性，与 Webpack 相比的差异。 2.调研方法 使用webiste进行调研。 修改配置及处理启动时的报错。 使用vite进行打包，修改打包时的报错。 打包后执行命令进行预览，修改预览时的报错。3.调研过程 以下是webpack迁移vite会遇到的一些问题 12345&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vite&quot;, &quot;build&quot;: &quot;vite build --debug&quot;, &quot;serve&quot;: &quot;vite preview&quot;,&#125; 3.1 启动3.1.1 环境变量引入 新建本地文件 .env.local ，该文件需添加进 .gitignore 中。 变量名需要以 VITE_xxx 的方式命名。 在配置文件中使用： 123456789101112131415//.env.localVITE_COUNTRY = vnVITE_ENVIRONMENT = test// vite.config.jsimport &#123; defineConfig, loadEnv &#125; from &apos;vite&apos;;export default (&#123; mode &#125;) =&gt; &#123; const env = loadEnv(mode, process.cwd()); const environment = env.VITE_ENV || env.VITE_ENVIRONMENT || &apos;test&apos; const country = env.VITE_CID || env.VITE_COUNTRY || &apos;my&apos; return defineConfig(&#123; //... &#125;)&#125; 3.1.2 别名12345678910// vite.config.jsexport default (&#123; mode &#125;) =&gt; &#123; // ... return defineConfig(&#123; resolve: &#123; alias: [&#123; find: &apos;@/&apos;, replacement: &apos;/src/&apos; &#125;], &#125; &#125;)&#125; 3.1.3 样式问题1: [vite] Internal server error: Preprocessor dependency “sass” not found. Did you install it? 安装sass 问题2: [vite] Internal server error: Inline JavaScript is not enabled. Is it set in your options? 12345678910return defineConfig(&#123; css: &#123; preprocessorOptions: &#123; less: &#123; javascriptEnabled: true, modifyVars: theme &#125; &#125; &#125;&#125;) 问题3: [vite] Internal server error: ‘~antd/dist/antd.less’ wasn’t found. Tried - /Users/xinweiwang/Desktop/affiliate/web-affiliate/src/~antd/dist/antd.less,node_modules/~antd/dist/antd.less,npm://~antd/dist/antd.less,~antd/dist/antd.less 把theme.js中的 @import “~antd/dist/antd.less”; 注释。 添加插件vite-plugin-imp按需加载antd 123456789101112return defineConfig(&#123; plugins: [ vitePluginImp(&#123; libList: [ &#123; libName: &quot;antd&quot;, style: (name) =&gt; `antd/es/$&#123;name&#125;/style/`, &#125;, ], &#125;) ],&#125;) 问题4：不支持 ‘:export’ 问题5：Unknown theme type: undefined, name: undefined https://github.com/ant-design/ant-design/issues/19002 1234567return defineConfig(&#123; resolve: &#123; alias: &#123; &apos;@ant-design/icons/lib/dist&apos;: &apos;@ant-design/icons/lib/index.es.js&apos; &#125;, &#125;, &#125;) 3.1.4 配置代理123456789101112return defineConfig(&#123; server: &#123; port: 8888, host: &apos;0.0.0.0&apos;, proxy: &#123; &apos;/api&apos;: &#123; target: `https://affiliate.$&#123;environment&#125;.$&#123;BASE_DOMAIN_ALL[country]&#125;/`, changeOrigin: true &#125; &#125; &#125;&#125;) 3.1.5 引入入口文件12// index.html &lt;script type=&quot;module&quot; src=&quot;/src/index.tsx&quot;&gt;&lt;/script&gt; 3.1.6 启动时各种408，请求超时 ，可以删除node_modules，重新install 3.1.7 Uncaught SyntaxError: The requested module ‘/global.config.js?t=1647918620356’ does not provide an export named ‘default’vite不支持cjs，https://github.com/vitejs/vite/issues/3024 方案一：可以通过预捆绑的方式处理，但那代表着需要捆绑很多个文件 方案二：把global.config.js中的module.exports改为export default，所有文件的module.exports及require都需要更改 3.1.8 Uncaught ReferenceError: global is not defined方案一 1234// index.html&lt;script&gt; global = globalThis;&lt;/script&gt; 方案二：缺点是打包时会把同名文件的文件名修改掉 123456// vite.config.js return defineConfig(&#123; define: &#123; global: JSON.stringify(&#123;&#125;) &#125;&#125;) 3.1.9 babel使用插件@vitejs/plugin-react 12345678910// vite.config.jsreturn defineConfig(&#123; plugins: [ react(&#123; babel: &#123; plugins: [], &#125;, &#125;), ]&#125;) 3.1.10 未解之谜（后来没有再出现了）https://github.com/vitejs/vite/issues/6241 vite@2.5.10没有出现此问题，但评论说还有，所以也暂时不算是解决了。 3.1.11 全局变量define中对应的值是一个常量，需要使用JSON.stringify()来表示是一个常量。 1234567// vite.config.js const country = env.VITE_COUNTRY;return defineConfig(&#123; define: &#123; COUNTRY: JSON.stringify(country) &#125;&#125;) 3.1.12 Uncaught Error: Dynamic require of “/Users/xinweiwang/Desktop/affiliate/web-affiliate/node_modules/@mkt/common-component/dist/LazyImage/default-image.svg” is not supported方案一： 类似问题及解决方案：https://github.com/vitejs/vite/issues/5308 使用插件@originjs/vite-plugin-commonjs处理了： 1234567// vite.config.js const country = env.VITE_COUNTRY;return defineConfig(&#123; plugins: [ viteCommonjs() ]&#125;) 3.1.13 [vite] Internal server error: Failed to resolve import “‘ + name + ‘“ from “node_modules/.vite/react-app-polyfill_stable.js?v=f714c2ed”. Does the file exist?找到一个类似问题 方案：使用@vitejs/plugin-legacy取代react-app-polyfill，具体配置根据实际情况而定。 1234567891011// vite.config.js import legacy from &apos;@vitejs/plugin-legacy&apos;;return defineConfig(&#123; plugins: [ legacy(&#123; targets: [&apos;ie &gt;= 11&apos;], additionalLegacyPolyfills: [&apos;regenerator-runtime/runtime&apos;] &#125;), ]&#125;) 3.1.14 regeneratorRuntime is not definedimport “regenerator-runtime” 3.1.15 Uncaught TypeError: Unknown theme type: undefined, name: undefined解决方案：https://github.com/ant-design/ant-design/issues/19002#issuecomment-965958565 3.2 打包3.2.1 重名问题打包时不允许有重名现象，即使一个是类型名，一个是变量名，会报 Identifier ‘xxx’ has already been declared. 有两处地方存在此问题： /src/components/Payment/BillingDetail/PaymentDetail/index.tsx：PaymentConfirmation /src/components/Payment/Setting/ZipCodeAddress/index.tsx：ZipCodeAddress 3.2.2 压缩后大于500k的文件与业务相关，需要优化具体模块 3.3 打包后预览3.3.1 Uncaught TypeError: Failed to resolve module specifier “indexof”. Relative references must start with either “/“, “./“, or “../“.解决方案：https://github.com/vitejs/vite/issues/2670#issuecomment-905495115 3.3.2 Uncaught ReferenceError: require is not defined// vite.config.js 1234567return defineConfig(&#123; build: &#123; commonjsOptions: &#123; transformMixedEsModules: true &#125; &#125;, &#125;) 3.3.3 Uncaught ReferenceError: exports is not defined未解决：https://github.com/rollup/plugins/issues/1014 临时解决方案：https://github.com/rollup/plugins/issues/1014#issuecomment-1049512712 3.4 Jenkins部署3.5 业务相关以下是业务相关的补充，由于不影响编译打包等，所以并不保证是包含全部的。 3.5.1 svg使用插件vite-plugin-svg-icons生成svg sprite map 1234567891011121314151617// vite.config.js import &#123; createSvgIconsPlugin &#125; from &apos;vite-plugin-svg-icons&apos;;return defineConfig(&#123; plugins: [ createSvgIconsPlugin(&#123; iconDirs: [ path.resolve(process.cwd(), &apos;src/assets/icons&apos;), path.resolve(process.cwd(), &apos;src/assets/svg&apos;) ], symbolId: &apos;[name]&apos; &#125;) ]&#125;)// src/index.tsximport &apos;virtual:svg-icons-register&apos;; 3.5.2 其余基于webpack的插件vite插件合集 webpack插件 类似的vite插 svg-sprite-loader vite-plugin-svg-icons workbox-webpack-plugin vite-plugin-pwa realtime-translation-webpack-plugin babel-plugin-istanbul-shopee 3.5.3 业务相关报错Uncaught (in promise) ReferenceError: require is not defined：类似的require都需要修改 如 src/components/common/Empty 12345// 原来的写法&lt;img src=&#123;require(&apos;@/assets/images/empty.png&apos;)&#125;/&gt;// 改为&lt;img src=&#123;new URL(&apos;../../../assets/images/empty.png&apos;, import.meta.url).href&#125;/&gt; 如 src/translate/index.ts 12345678// 原来的写法const message = require(&apos;./messages/&apos; + language + &apos;.json&apos;);result[language] = regExpEditLanguage(message);// 改为const messages = import.meta.globEager(&apos;./messages/*.json&apos;);const path = `./messages/$&#123;language&#125;.json`;result[language] = regExpEditLanguage(messages[path]); 4.调研结果4.1 原理官网有给出与传统打包工具的对比 4.2 Webpack vs Vite action webpack vite 首次启动 90s~120s 0.4s ~ 1s 首次首屏 很快 约40s 第二次启动首屏 很快 约9s HMR 8s～10s 0.05s ～ 0.2s 打包构建 2min~3min 2min ~ 3min vite的启动比webpack快很多，但首次启动的首屏展示并不快，该加载的包还是要等加载完才展示。 第二次启动时，vite由于缓存，首屏展示速度变快。 官方表示，Vite HMR 更新反映到浏览器的时间小于 50ms。 两者打包速度差不多。 5.结论 在开发上，特别是启动项目时，速度是有一定提升的。 vite还不算很成熟，有很多隐藏问题，甚至有一些问题无法从根本解决，如3.1.10。 并不是所有webpack插件都有对应的vite插件，自定义的更是需要重写，工作量也许很大。 一个庞大的项目，从webpack迁移vite，工作量很大，业务代码也有需要兼容的，例如各种require]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[whistle：利用whistle操作WebSocket请求]]></title>
    <url>%2F2022%2F04%2F26%2F%E5%89%8D%E7%AB%AF%2Fwhistle%EF%BC%9A%E5%88%A9%E7%94%A8whistle%E6%93%8D%E4%BD%9CWebSocket%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[一、安装123npm install -g whistle.script# Mac、Linux用户可能需要加sudosudo npm install -g whistle.script 安装插件后要重启whistle 二、使用打开script插件的界面，创建一个名字为 test 的脚本: 可以通过 Plugins-&gt;Home-&gt;script打开或右键并选择 在新标签页中打开 或者直接访问 http://local.whistlejs.com/plugin.script 三、操作请求1、操作HTTP或HTTPs请求(操作HTTPs需要开启HTTPs拦截)脚本中输入： 12345678910111213141516171819202122232425262728293031exports.handleRequest = function* (ctx, next) &#123; // ctx.fullUrl 可以获取请求url // ctx.headers 可以获取请求头 // ctx.options 里面包含一些特殊的请求头字段，分别可以获取一些额外信息，如请设置的规则等 // ctx.method 获取和设置请求方法 // const reqBody = yield ctx.getReqBody(); 获取请求body的Buffer数据，如果没有数据返回null // const reqText = yield ctx.getReqText(); 获取请求body的文本，如果没有返回&apos;&apos; // const formData = yield ctx.getReqForm(); 获取表单对象，如果不是表单，返回空对象&#123;&#125; // console.log(ctx.method, ctx.headers, reqBody); // ctx.req.body = String| Buffer | Stream | null，修改请求的内容 // 只有执行next方法后才可以把正常的请求发送出去 // 如果需要自定义请求，可以通过全局的request方法操作 // console.log(request); // next方法可以设置next(&#123; host, port &#125;); const &#123; statusCode, headers &#125; = yield next(); console.log(ctx.fullUrl, statusCode, headers); // const resBody = yield ctx.getResBody(); // const resText = yield ctx.getResText(); // ctx.status = 404; 修改响应状态码 // ctx.set(headers); 批量修改响应头 // ctx.set(&apos;x-test&apos;, &apos;abc&apos;); 修改响应头 // ctx.body = String| Buffer | Stream | null; 修改响应内容&#125;; // 如果Node &gt;= 7.6，可以采用async await的方式exports.handleRequest = async (ctx, next) =&gt; &#123; // do sth // next方法可以设置next(&#123; host, port &#125;); const &#123; statusCode, headers &#125; = await next(); // do sth&#125;; 在whistle的Rules配置界面上输入规则（需要放在最前面）: 123script://test games.*.shopee.**# 如果需要通过配置给脚本传递一些额外参数，可以如下配置script://test(a,b,c) games.*.shopee.** 可以在脚本中通过 process.args 获取: 123exports.handleRequest = (ctx, next) =&gt; &#123; console.log(process.args); // output: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#125;; 2、操作WebSocket请求(需要开启HTTPs拦截)脚本中输入： 1234567891011121314151617// Node &lt; 7.6可以改用genrator和yieldexports.handleWebSocket = async (req, connect) =&gt; &#123; // connect方法可以设置connect(&#123; host, port &#125;); const res = await connect(); res.on(&apos;message&apos;, (data) =&gt; &#123; // 在script的Console打印出服务端发送的数据 console.log(&apos;Received: &apos;, data); // 可以修改后再发送到Server req.send(data); &#125;); req.on(&apos;message&apos;, (data) =&gt; &#123; // 在script的Console打印出客户端发送的数据 console.log(&apos;Sent: &apos;, data); // 可以修改后再发送到Server res.send(data); &#125;);&#125;; whistle规则配置同上 更多关于whistle.script的使用详见官网：https://github.com/whistle-plugins/whistle.script]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器内核、渲染引擎、JS引擎]]></title>
    <url>%2F2022%2F04%2F26%2F%E5%89%8D%E7%AB%AF%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95%E2%80%94%E2%80%94Xcode%2F</url>
    <content type="text"><![CDATA[一、下载安装 App Store可以进行下载 安装 1234$ xcode-select --install$ xcode-select -p// 显示以下信息即是成功安装 /Applications/Xcode.app/Contents/Developer 注意安装时出现错误 12345xcode-select -pxcode-select: error: command line tools are already installed, use &quot;Software Update&quot; to install updates// 解决$ rm -rf /Library/Developer/CommandLineTools$ xcode-select --install// 如果还是报错，加上sudo 二、ios模拟器 列出可用的 iOS 模拟器 1$ xcrun instruments -s 安装更多版本模拟器 Simulator 默认只有最新的 iOS 版本的模拟器，如果你需要在老版本的 iOS 上调试，可以这样安装更多版本。 运行Xcode Window -&gt; Devices and Simulator -&gt; Simulator 点击左下角的 + 可以添加其它型号的机器 OS version -&gt; Download more simulator runtime 可以下载其他版本的iOS系统 启动模拟器 12$ xcrun instruments -w XXX// 如 xcrun instruments -w &quot;iPhone 11 (13.6)&quot; 三、安装shopee app 下载需要安装的app压缩包 解压后直接拖入模拟器即可安装 登录时不要打开proxifier，不然会一直pending 四、安装proxifier，配置代理 下载proxifier 安装whistle，运行w2 start启动 运行proxifier，配置 点击Proxies，添加一条 Action 规则代理到本地8899端口 然后点击Rules，新建一个规则，把以下内容添加到 Applications 1Simulator; &quot;Xcode Server Builder”; &quot;MobileSafari”; “com.apple.WebKit.Networking”;k12;vpn;ShopeeSG; 五、安装并信任证书我们开发的都是https页面，需要在配置好代理后，下载安装证书 iphone模拟器里用safari访问127.0.0.1:8899，然后在https那里下载安装证书 模拟器Settings -&gt; General -&gt; Profile, 点击证书进入下载 模拟器Settings -&gt; General -&gt; About -&gt; Certificate Trust Settings, 打开whistle证书信任按钮进行信任 相应安装包和代理配置可参考：whistle代理xcode iphone模拟器调试]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Css：stylelint]]></title>
    <url>%2F2022%2F04%2F26%2FCSS%2FCSS%EF%BC%9Astylelint%2F</url>
    <content type="text"><![CDATA[安装1npm install -D stylelint 官方推荐基本配置1npm install -D stylelint-config-standard stylelint-config-prettier 共享配置扩展 1npm install -D stylelint-config-standard-scss stylelint-config-prettier-scss 配置文件.stylelintrc.js123456789module.exports = &#123; extends: [ &quot;stylelint-config-standard-scss&quot;, &quot;stylelint-config-prettier-scss&quot; ], rules: &#123; &#125;&#125; vscode插件 安装插件stylelint 修改setting.json 12345&quot;stylelint.enable&quot;: true,&quot;css.validate&quot;: false,&quot;less.validate&quot;: false,&quot;scss.validate&quot;: false,&quot;stylelint.validate&quot;: [&quot;css&quot;, &quot;scss&quot;, &quot;less&quot;] ==修改完成后需要重启编辑器== webpack插件安装1npm i -D stylelint-webpack-plugin 使用 123456const StyleLintPlugin = require(&apos;stylelint-webpack-plugin&apos;);new StyleLintPlugin(&#123; context: &quot;src&quot;, configFile: path.resolve(__dirname, &apos;.stylelintrc.js&apos;), // 指定 stylelint 配置的文件 quiet: true&#125;), 问题 TypeError: Class extends value undefined is not a constructor or null 1npm i -D postcss@8 2.]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[E2E测试]]></title>
    <url>%2F2022%2F02%2F15%2F%E5%89%8D%E7%AB%AF%2FE2E%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[E2E (end-to-end) E2E测试就是end to end testing，即端到端测试。 它模仿用户，从某个入口开始，逐步执行操作，直到完成某项工作。 E2E 测试并没有那么强调要覆盖全部使用场景，它关注的是一个完整的操作链是否能够完成。对于 Web 前端来说，还关注 界面布局、内容信息是否符合预期。 不管逻辑使用什么框架什么逻辑写的，只想知道浏览器上我要的交互效果，ui展示效果是不是正确的，功能使用上是不是正确的，那么这就叫E2E测试。 cypresscypress是一款开箱即用,可以跑在Chrome浏览器上的测试工具。可以利用Cypress来模拟用户操作了，一方面可以测试代码是否正确，并且还能看到ui相应变化是否符合预期。 安装1$ npm install cypress --save-dev --registry=https://registry.npm.taobao.org 使用可以只写cypress需要访问的服务地址。123456789101112// cypress.json&#123; &quot;baseUrl&quot;: &quot;http://localhost:8000&quot;, #测试访问的路由地址 &quot;reporter&quot;: &quot;junit&quot;, #报告类型 &quot;reporterOptions&quot;: &#123; &quot;mochaFile&quot;: &quot;results/test-[hash].xml&quot;, #输出的文件 &quot;toConsole&quot;: true #是否输出的命令行 &#125;, &quot;viewportHeight&quot;: 800, # viewPort也就是预览窗的高度 &quot;viewportWidth&quot;: 1600 # viewPort也就是预览窗的宽度&#125; 通过cypress open本地打开测试窗口 1$ cypress open 点击右上角的运行所有集成化测试，或是点击单个测试用例单独测试 目录结构123456789101112├── fixtures # mock数据的存储目录，这里存放了所有mock的json文件│ ├── orders.json│ ├── panicBuyings.json│ └── routers.json├── integration # 测试用例代码目录│ ├── orderManagement.spec.js│ └── panicBuyingManagement.spec.js├── plugins # 插件目录│ └── index.js└── support ├── commands.js └── index.js 代码编写模拟用户操作123456789101112131415161718describe(&apos;测试抢购订单管理&apos;, () =&gt; &#123; beforeEach(() =&gt; &#123; #每个测试用例调用之前的操作 const mock = Cypress.env(&apos;MOCK&apos;) || &apos;false&apos;; # 自定义环境变量，运行时传递的话需要指定CYPRESS_前缀，这里使用是CYPRESS_MOCK=true cypress open cy.server(); # 如果需要mock接口的话，必须要运行server if (mock === true) &#123; cy.intercept(&apos;GET&apos;, &apos;/panic-buying/manager/orders*&apos;, &#123; fixture: &apos;orders.json&apos; &#125;).as( &apos;getOrders&apos;, ); # 拦截/panic-buying/manager/order*路由，并指定返回数据使用orders.json，定义这个接口是getOrders函数，用于后面测试使用。 &#125; else &#123; cy.intercept(&apos;GET&apos;, &apos;/panic-buying/manager/orders*&apos;).as(&apos;getOrders&apos;); &#125; &#125;); it(&apos;测试订单列表搜索&apos;, () =&gt; &#123; cy.visit(&apos;/#/rush-order/list&apos;); #访问页面路径 cy.wait(&apos;@getOrders&apos;).its(&apos;response.statusCode&apos;).should(&apos;be.oneOf&apos;, [200, 304]); # 等待getOrders函数，也就是接口返回并判断返回状态是200或是304中的一个。 cy.wait(1000); # 显示的等待1秒 &#125;);&#125;); API更多api操作参考：Commands 测试套件和用例 describe(): 代表测试套件，里面可以设定，一个测试套件可以不包括任何钩子函数（Hook），但必须包含至少一条测试用例 it() ，能嵌套子测试套件。 context(): 是 describe() 的别名，其行为方式是一致的，可以直接用 context() 代替 describe()。 it(): 代表一条测试用例。 …… 钩子函数 before(): 运行 cypress via cypress open 时，打开项目时将触发该事件。每次 cypress run 执行时都会触发该事件，会在第一个用例之前运行。 after()：会在跑完所有的用例之后运行。 beforeEach()：会在每一个用例前运行。 afterEach()：会在每一个用例结束后运行。 …… dom节点 get(): 用来在 DOM 树中查找 DOM 元素，get方法可以像jquery一样通过selector查找到对应的dom。 children()：获取一组 DOM 元素中每个 DOM 元素的子元素。 parent()：获取一组 DOM 元素的父 DOM 元素。 siblings()：获取兄弟 DOM 元素等。 trigger(): 在 DOM 元素上触发事件。 …… 123456789101112131415161718192021// 触发dom的mouseover事件dom.trigger(&apos;mouseover&apos;)// 语法使用示例// eventName（string）event 在DOM元素上要触发的的名称。.trigger(eventName)// position（string）// 应该触发事件的位置。该center位置是默认位置。// 有效的位置topLeft，top，topRight，left，center，right，bottomLeft，bottom，和bottomRight。.trigger(eventName, position)// options: 传递选项对象以更改的默认行为.trigger(eventName, options)// x（number）: 从元素左侧到触发事件的距离（单位px）。// y（number）: 从元素顶部到触发事件的距离（单位px）。.trigger(eventName, x, y).trigger(eventName, position, options).trigger(eventName, x, y, options) 网络接口 intercept: 在网络层管理 HTTP 请求的行为 1234cy.intercept(url, staticResponse)cy.intercept(method, url, staticResponse)cy.intercept(routeMatcher, staticResponse)cy.intercept(url, routeMatcher, staticResponse) Actions行为事件ui自动化操作页面上的元素，常用的方法输入如文本，点击元素，清空文本，点击按钮。还有一些特殊的checkbox,radio,滚动条等。cypress都可以api操作： type(): 往输入框输入文本元素。 focus(): 聚焦DOM元素。 clear(): 清空DOM元素。 rightclick(): 右击 DOM 元素 click()：点击 DOM 元素 select(): select 选项框 进阶有时候一个项目往往十分庞大，并不是所有组件都需要进行E2E测试，因此可以把需要进行测试的组件单独拿出来，本地部署一下，进行测试。 123456├── cypress # cypress目录│ ├── fixtures│ ├── integration│ ├── ...│ └── plugins├── e2e # 需要进行测试的组件代码 单独设置一个小项目，把需要进行测试的组件引进来，组成一个页面，对此页面进行测试。因此在开始测试前，需要先把这个页面跑起来，再开始测试。 参考 前端E2E测试框架 cypress了解一下 UI自动化测试框架Cypress介绍和使用 Cypress自动化测试入门使用]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocos：Cocos接入react组件]]></title>
    <url>%2F2021%2F09%2F17%2FCocos%2FCocos%EF%BC%9ACocos%E6%8E%A5%E5%85%A5react%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[接入redeem store，react组件，cocos不支持tsx ts把tsx编译成js引入 有引入别的文件使用，ts无法把两个文件打成一个文件 使用rolllup编译成js 引入文件过大，导致ts文件崩溃 把js改为插件脚本 把js导出项改为全局变量，直接引用 分包 需要把依赖一起打包到js进行分包 window不适用，继续使用引入的方式 load成功后引入redeem store process is not defined，打包时替换js里的process 部署时，无法获取process，无法替换，直接插入html，全局使用，production不替换 需求基于cocos的游戏接入基于react的兑换商店，即cocos接入react组件 tsx由于兑换商店暴露的是react组件，所以封装成一个tsx文件，接入cocos，html中增加一个节点，把兑换商店插入该节点 问题：cocos不支持接入tsx ts编译通过typescript把tsx编译成js 使用命令行参数–project（或-p）指定一个包含tsconfig.json文件的目录1$ tsc -p redeemStore/tsconfig.json 12345678910111213// tsconfig.json&#123; &quot;compilerOptions&quot;: &#123; &quot;allowSyntheticDefaultImports&quot;: true, &quot;jsx&quot;: &quot;react&quot;, &quot;module&quot;:&quot;esnext&quot;, &quot;target&quot;: &quot;es5&quot;, &quot;rootDir&quot;: &quot;./redeemStore.tsx&quot;, // 用来指定编译文件的根目录，编译器会在根目录查找入口文件 &quot;outDir&quot;: &quot;../assets&quot;, // 用来指定输出文件夹 &quot;baseUrl&quot;: &quot;../&quot;, // 用于设置解析非相对模块名称的基本目录，相对模块不会受到baseUrl的影响 &#125;&#125; 由于有引入别的文件，希望可以全部编译成一个文件 12// 指定输出文件合并为一个文件，只有设置module的值为amd和system模块时才支持这个配置&quot;outFile&quot;: &quot;./&quot;, 问题：无法多个文件编译成一个文件输出 rollup打包123456789101112131415161718192021222324252627// rollup.config.jsimport typescript from &apos;rollup-plugin-typescript2&apos;;import resolve from &apos;rollup-plugin-node-resolve&apos;;import commonjs from &apos;rollup-plugin-commonjs&apos;;export default &#123; input: &apos;redeemStore/redeemStore.tsx&apos;, // 源文件入口 output: &#123; file: &apos;assets/script/page/ui/redeemStore/redeemStore.js&apos;, format: &apos;cjs&apos;, sourcemap: true, compact: true &#125;, plugins: [ resolve(), commonjs(), replace(&#123; &apos;process.env.NODE_ENV&apos;: JSON.stringify(process.env.NODE_ENV), &apos;process.env.country&apos;: JSON.stringify(process.env.cid || process.env.country), &apos;process.env.environment&apos;: JSON.stringify(process.env.env || process.env.environment), &#125;), typescript(), uglify() ],&#125; plugins是有顺序的 rollup-plugin-typescript2使rollup可作用于typescript rollup-plugin-node-resolve / @rollup/plugin-node-resolve rollup 不会去寻找从npm安装到你的node_modules文件夹中的软件包 该插件可以告诉 Rollup 如何查找外部模块 解析 node_modules 中的模块，将所有依赖编译进同一个文件 rollup-plugin-commonjs / @rollup/plugin-commonjs 将 CommonJS 模块转换为 ES6 npm中的大多数包都是以 CommonJS 模块的形式出现的。 在它们更改之前，我们需要将CommonJS模块转换为 ES2015 供 Rollup 处理 该插件应该用在其他插件转换你的模块之前 - 这是为了防止其他插件的改变破坏CommonJS的检测 rollup-plugin-commonjs 会有以下问题123[!] Error: &apos;createElement&apos; is not exported by node_modules/react/index.js, imported by node_modules/@gameplatform-fe-component/redeem-store/dist/es/index.mjshttps://rollupjs.org/guide/en/#error-name-is-not-exported-by-modulenode_modules/@gameplatform-fe-component/redeem-store/dist/es/index.mjs (1:25) 12345commonjs(&#123; namedExports: &#123; &apos;react&apos;: Object.keys(React), &#125;&#125;) rollup-plugin-replace / @rollup/plugin-replace编译过程中可以进行字符串替换 @rollup/plugin-replace 会含有如下警告，仅仅是警告⚠️，不会影响编译1(!) Plugin replace: @rollup/plugin-replace: &apos;preventAssignment&apos; currently defaults to false. It is recommended to set this option to `true`, as the next major version will default this option to `true`. rollup-plugin-uglify代码压缩，使编译后的包更小 全局变量 打包后直接import会导致脚本崩溃，失效。 把其设置为插件脚本。 用window，redeem store设为全局变量去调用。 以上，在分包后都不是问题，因此，这里只是一个小插曲，分包后依然是直接import 分包Asset Bundle 中的脚本 构建cocos可以把一个文件夹设置为bundle，其下的文件都会在构建时单独打包成一个子包，仅仅构建时生效，开发预览依然是一个整包。 加载12345678910111213141516171819enterRedeemPage() &#123; let bundle = assetManager.getBundle(&apos;redeemStore&apos;); if (!bundle) &#123; assetManager.loadBundle(&apos;redeemStore&apos;, err =&gt; &#123; if (err) &#123; return console.error(err); &#125; this.loadRedeemStore(); &#125;); &#125; else &#123; this.loadRedeemStore(); &#125;&#125;async loadRedeemStore() &#123; const store = await import(&apos;./redeemStore/redeemStore.js&apos;); store.default.openStore(app.data.gameConfig, app.data.player.uid, () =&gt; app.ui.open(UIDef.UILandingPage)); this.close();&#125; development vs productiondevelopment 开发环境，分包策略不生效，依然是整包。 直接通过特定的命令编译redeemStore，编译过程某些参数通过特定的命令注入。 若切换地区需要重新编译 1rollup:test:id&quot;: &quot;cross-env NODE_ENV=development cid=id env=test rollup -c&quot; production 部署的同时，对redeemStore进行编译 由于参数无法注入，因此在部署时，通过脚本把参数设为全局变量，以供redeemStore直接读取 1234567window.process = &#123; env: &#123; NODE_ENV: &apos;production&apos;, country: &apos;$&#123;buildConfig.COUNTRY&#125;&apos;, environment: &apos;$&#123;buildConfig.ENVIRONMENT&#125;&apos; &#125;&#125;;]]></content>
      <categories>
        <category>Cocos</category>
      </categories>
      <tags>
        <tag>Cocos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git：一些常用的命令]]></title>
    <url>%2F2021%2F08%2F02%2FGit%2FGit%EF%BC%9A%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[忽略eslint 1git commit --no-verify -m &quot;&quot; 删除本地分支 1git branch -d &lt;branch&gt; 删除远程分支1git push origin --delete &lt;branch&gt;]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm：更换源]]></title>
    <url>%2F2021%2F07%2F19%2FGit%2Fnpm%EF%BC%9A%E6%9B%B4%E6%8D%A2%E6%BA%90%2F</url>
    <content type="text"><![CDATA[原始源安装完node之后，默认的原始源是： 1https://registry.npmjs.org/ 使用淘宝镜像临时使用1npm --registry https://registry.npm.taobao.org install express 持久使用1npm config set registry https://registry.npm.taobao.org 通过cnpm1npm install -g cnpm --registry=https://registry.npm.taobao.org 使用官方镜像1npm config set registry https://registry.npmjs.org/ 查看npm源地址1npm config get registry]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocos Creator踩坑记]]></title>
    <url>%2F2021%2F07%2F07%2FCocos%2FCocos%20Creator%E8%B8%A9%E5%9D%91%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[动画编辑 动画在普通模式下是不允许编辑的，只有在动画编辑模式下才可以编辑动画文件。 但是在动画编辑模式下，无法对节点进行添加/删除/重命名操作，并且没有记录在动画关键帧内的属性修改，在退出动画编辑器后也会被还原]]></content>
      <categories>
        <category>Cocos</category>
      </categories>
      <tags>
        <tag>Cocos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocos：事件机制]]></title>
    <url>%2F2021%2F07%2F05%2FCocos%2FCocos%EF%BC%9A%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[事件监听事件处理大多数是在节点（Node）中完成的。对于组件，可以通过访问节点 this.node 来注册和监听事件。监听事件可以通过 this.node.on() 函数来注册，方法如下： 12345// 该事件监听每次都会触发，需要手动取消注册xxx.on(type, func, target?);// 该事件监听在监听函数响应后就会关闭监听事件。xxx.once(type, func, target?); type 为事件注册字符串 func 为执行事件监听的回调 target 为事件接收对象 如果 target 没有设置，则回调里的 this 指向的就是当前执行回调的对象。 值得一提的是，事件监听函数 on 第三个参数 target，主要是绑定响应函数的调用者。以下两种调用方式，效果上是相同的 123456789// 使用函数绑定this.node.on(Node.EventType.MOUSE_DOWN, function ( event ) &#123; this.enabled = false;&#125;.bind(this));// 使用第三个参数this.node.on(Node.EventType.MOUSE_DOWN, (event) =&gt; &#123; this.enabled = false;&#125;, this); 事件取消当我们不再关心某个事件时，我们可以使用 off 方法关闭对应的监听事件。 off 方法的使用方式有两种： 1234// 取消对象身上所有注册的该类型的事件xxx.off(type);// 取消对象身上该类型指定回调指定目标的事件xxx.off(type, func, target); 需要注意的是，off 方法的参数必须和 on 方法的参数一一对应，才能完成关闭。 我们推荐的书写方法如下： 1234567891011121314151617import &#123; _decorator, Component, Node &#125; from &apos;cc&apos;;const &#123; ccclass &#125; = _decorator;@ccclass(&quot;Example&quot;)export class Example extends Component &#123; onEnable () &#123; this.node.on(&apos;foobar&apos;, this._sayHello, this); &#125; onDisable () &#123; this.node.off(&apos;foobar&apos;, this._sayHello, this); &#125; _sayHello () &#123; console.log(&apos;Hello World&apos;); &#125;&#125; 事件派发触发事件有两种方式： emit dispatchEvent，可以做事件传递 emit12// 事件派发的时候可以指定派发参数，参数最多只支持 5 个事件参数xxx.emit(type, ...args); 在触发事件时，我们可以在 emit 函数的第二个参数开始传递我们的事件参数。同时，在 on 注册的回调里，可以获取到对应的事件参数。 1234567891011121314151617import &#123; _decorator, Component, Node &#125; from &apos;cc&apos;;const &#123; ccclass &#125; = _decorator;@ccclass(&quot;Example&quot;)export class Example extends Component &#123; onLoad () &#123; this.node.on(&apos;foo&apos;, (arg1, arg2, arg3) =&gt; &#123; console.log(arg1, arg2, arg3); // print 1, 2, 3 &#125;); &#125; start () &#123; let arg1 = 1, arg2 = 2, arg3 = 3; // At most 5 args could be emit. this.node.emit(&apos;foo&apos;, arg1, arg2, arg3); &#125;&#125; 需要说明的是，出于底层事件派发的性能考虑，这里最多只支持传递 5 个事件参数。所以在传参时需要注意控制参数的传递个数。 dispatchEvent 通过 dispatchEvent 方法派发的事件，会进入事件派发阶段。 在 Cocos Creator 的事件派发系统中，我们采用冒泡派发的方式。 冒泡派发会将事件从事件发起节点，不断地向上传递给它的父级节点，直到到达根节点或者在某个节点的响应函数中做了中断处理 event.propagationStopped = true。 在 v3.0 中，我们移除了 Event.EventCustom 类，如果要派发自定义事件，需要先实现一个自定义的事件类，该类继承自 Event 类。 12345678910// Event 由 cc 模块导入import &#123; Event &#125; from &apos;cc&apos;;class MyEvent extends Event &#123; constructor(name: string, bubbles?: boolean, detail?: any) &#123; super(name, bubbles); this.detail = detail; &#125; public detail: any = null; // 自定义的属性&#125; 以上图为例，当我们从节点 c 发送事件 “foobar”，倘若节点 a，b 均做了 “foobar” 事件的监听，则事件会经由 c 依次传递给 b，a 节点。如： 12// 节点 c 的组件脚本中this.node.dispatchEvent( new MyEvent(&apos;foobar&apos;, true, &apos;detail info&apos;) ); 如果我们希望在 b 节点截获事件后就不再传递事件，我们可以通过调用 event.propagationStopped = true 函数来完成。具体方法如下： 1234// 节点 b 的组件脚本中this.node.on(&apos;foobar&apos;, (event: MyEvent) =&gt; &#123; event.propagationStopped = true;&#125;); 注意：在发送用户自定义事件的时候，请不要直接创建 cc 内的 Event 对象，因为它是一个抽象类。 系统内置事件123456789// 使用枚举类型来注册，推荐node.on(Node.EventType.MOUSE_DOWN, (event) =&gt; &#123; console.log(&apos;Mouse down&apos;);&#125;, this);// 使用事件名来注册node.on(&apos;mouse-down&apos;, (event) =&gt; &#123; console.log(&apos;Mouse down&apos;);&#125;, this); 触摸事件触摸事件冒泡触摸事件支持节点树的事件冒泡，以下图为例：在图中的场景里，假设 A 节点拥有一个子节点 B，B 拥有一个子节点 C。开发者对 A、B、C 都监听了触摸事件（以下的举例都默认节点监听了触摸事件）。 当鼠标或手指在 C 节点区域内按下时，事件将首先在 C 节点触发，C 节点监听器接收到事件。 接着 C 节点会将事件向其父节点传递这个事件，B 节点的监听器将会接收到事件。 同理 B 节点会将事件传递给 A 父节点。这就是最基本的事件冒泡过程。 需要强调的是，在触摸事件冒泡的过程中不会有触摸检测，这意味着即使触点不在 A B 节点区域内，A B 节点也会通过触摸事件冒泡的机制接收到这个事件。 触摸事件的冒泡过程与普通事件的冒泡过程并没有区别。所以，调用 event.propagationStopped = true; 可以主动停止冒泡过程。 同级节点间的触点归属问题 假设上图中 B、C 为同级节点，C 节点部分覆盖在 B 节点之上。 这时候如果 C 节点接收到触摸事件后，就宣布了触点归属于 C 节点，这意味着同级节点的 B 就不会再接收到触摸事件了， 即使触点同时也在 B 节点内。同级节点间，触点归属于处于顶层的节点。 此时如果 C 节点还存在父节点，则还可以通过事件冒泡的机制传递触摸事件给父节点。 不同 Canvas 的触点归属问题 不同 Canvas 之间的触点拦截是根据优先级决定的。 在下图中的场景里，节点树里的 Canvas 1-5 对应图片显示的 priority 1-5。 可以看出，即使 Canvas 节点 3、4、5 之间是按乱序排的，但是根据 Canvas 上的优先级（priority）关系，触点的响应先后顺序仍然是 Canvas5 -&gt; Canvas4 -&gt; Canvas3 -&gt; Canvas2 -&gt; Canvas1。 只有在优先级相同的情况下， Canvas 之间的排序是按节点树的先后顺序进行。 将触摸或鼠标事件注册在捕获阶段 有时候我们需要父节点的触摸或鼠标事件先于它的任何子节点派发，比如 ScrollView 组件就是这样设计的。 这时候事件冒泡已经不能满足我们的需求了，需要将父节点的事件注册在捕获阶段。 要实现这个需求，可以在给 node 注册触摸或鼠标事件时，传入第四个参数 true，表示 useCapture。 1this.node.on(Node.EventType.TOUCH_START, this.onTouchStartCallback, this, true); 当节点触发 touch-start 事件时，会先将 touch-start 事件派发给所有注册在捕获阶段的父节点监听器，然后派发给节点自身的监听器，最后才到了事件冒泡阶段。 只有触摸或鼠标事件可以注册在捕获阶段，其他事件不能注册在捕获阶段。 事件拦截 正常的事件是会按照以上说明的方式去派发。 但是如果节点身上带有 ==Button==,==Toggle== 或者 ==BlockInputEvents== 这几个组件的话，是会停止事件冒泡。 还是看下图。图中有两个按钮，Canvas0 下的 priority 1 和 Canvas1 下的 priority 2。 如果点击两个按钮的交汇处，也就是图中蓝色区域，会出现按钮 priority 2 成功接收到了触点事件，而按钮 priority 1 则没有。 那是因为按上述的事件接收规则，按钮 priority 2 优先接收到了触点事件，并且对事件进行了拦截（event.propagationStopped = true），防止事件穿透。 如果是非按钮节点，也可以通过添加 BlockInputEvents 组件来对事件进行拦截，防止穿透。 触摸事件举例以下图举例，总结下触摸事件的传递机制。图中有 A、B、C、D 四个节点，其中 A、B 为同级节点。具体层级关系如下： 若触点在 A、B 的重叠区域内，此时 B 接收不到触摸事件，事件的传递顺序是 A -&gt; C -&gt; D 若触点在 B 节点内（可见的绿色区域），则事件的传递顺序是 B -&gt; C -&gt; D 若触点在 C 节点内，则事件的传递顺序是 C -&gt; D 若以第 2 种情况为前提，同时 C D 节点的触摸事件注册在捕获阶段，则事件的传递顺序是 D -&gt; C -&gt; B]]></content>
      <categories>
        <category>Cocos</category>
      </categories>
      <tags>
        <tag>Cocos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocos：生命周期]]></title>
    <url>%2F2021%2F07%2F05%2FCocos%2FCocos%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[Cocos Creator 为组件脚本提供了生命周期的回调函数。开发者只需要定义特定的回调函数，Creator 就会在特定的时期自动执行相关脚本，开发者不需要手工调用它们。 目前提供给开发者的生命周期回调函数主要有（按生命周期触发先后排列）： onLoad onEnable start update lateUpdate onDisable onDestroy onLoad 组件脚本的初始化阶段，我们提供了 onLoad 回调函数。 onLoad 回调会在节点首次激活时触发，比如所在的场景被载入，或者所在节点被激活的情况下。 在 onLoad 阶段，保证了你可以获取到场景中的其他节点，以及节点关联的资源数据。 onLoad 总是会在任何 start 方法调用前执行，这能用于安排脚本的初始化顺序。 通常我们会在 onLoad 阶段去做一些初始化相关的操作。 1234567891011121314151617import &#123; _decorator, Component, Node, SpriteFrame, find &#125; from &apos;cc&apos;;const &#123; ccclass, property &#125; = _decorator;@ccclass(&quot;test&quot;)export class test extends Component &#123; @property(&#123;type:SpriteFrame&#125;) bulletSprite=null; @property(&#123;type:Node&#125;) gun=null; _bulletRect=null; onLoad()&#123; this._bulletRect=this.bulletSprite.getRect(); this.gun = find(&apos;hand/weapon&apos;, this.node); &#125;&#125; onEnable 当组件的 enabled 属性从 false 变为 true 时，或者所在节点的 active 属性从 false 变为 true 时，会激活 onEnable 回调。 倘若节点第一次被创建且 enabled 为 true，则会在 onLoad 之后，start 之前被调用。 start start 回调函数会在组件第一次激活前，也就是第一次执行 update 之前触发。 start 通常用于初始化一些中间状态的数据，这些数据可能在 update 时会发生改变，并且被频繁的 enable 和 disable。 1234567891011121314151617181920import &#123; _decorator, Component, Node &#125; from &apos;cc&apos;;const &#123; ccclass, property &#125; = _decorator;@ccclass(&quot;starttest&quot;)export class starttest extends Component &#123; private _timer: number = 0.0; start () &#123; this._timer = 1.0; &#125; update (deltaTime: number) &#123; this._timer += deltaTime; if(this._timer &gt;= 10.0)&#123; console.log(&apos;I am done!&apos;); this.enabled = false; &#125; &#125;&#125; update游戏开发的一个关键点是在每一帧渲染前更新物体的行为，状态和方位。这些更新操作通常都放在 update 回调中。 12345678910import &#123; _decorator, Component, Node &#125; from &apos;cc&apos;;const &#123; ccclass, property &#125; = _decorator;@ccclass(&quot;updatetest&quot;)export class updatetest extends Component &#123; update (deltaTime: number) &#123; this.node.setPosition(0.0,40.0*deltaTime,0.0); &#125;&#125; lateUpdateupdate 会在所有动画更新前执行，但如果我们要在动效（如动画、粒子、物理等）更新之后才进行一些额外操作，或者希望在所有组件的 update 都执行完之后才进行其它操作，那就需要用到 lateUpdate 回调。 12345678910import &#123; _decorator, Component, Node &#125; from &apos;cc&apos;;const &#123; ccclass, property &#125; = _decorator;@ccclass(&quot;lateupdatetest&quot;)export class lateupdatetest extends Component &#123; lateUpdate (deltaTime: number) &#123; this.node.setPosition(0.0,50,0.0); &#125;&#125; onDisable当组件的 enabled 属性从 true 变为 false 时，或者所在节点的 active 属性从 true 变为 false 时，会激活 onDisable 回调。 onDestroy当组件或者所在节点调用了 destroy()，则会调用 onDestroy 回调，并在当帧结束时统一回收组件。]]></content>
      <categories>
        <category>Cocos</category>
      </categories>
      <tags>
        <tag>Cocos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocos：计时器]]></title>
    <url>%2F2021%2F07%2F05%2FCocos%2FCocos%EF%BC%9A%E8%AE%A1%E6%97%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[下面是 Component 中所有关于计时器的函数： schedule：开始一个计时器 scheduleOnce：开始一个只执行一次的计时器 unschedule：取消一个计时器 unscheduleAllCallbacks：取消这个组件的所有计时器 schedule开始一个计时器 1234this.schedule(function() &#123; // 这里的 this 指向 component this.doSomething(); &#125;, 5); 上面这个计时器将每隔 5s 执行一次。 更灵活的计时器 12345678910// 以秒为单位的时间间隔 let interval = 5; // 重复次数 let repeat = 3; // 开始延时 let delay = 10; this.schedule(function() &#123; // 这里的 this 指向 component this.doSomething(); &#125;, interval, repeat, delay); 上面的计时器将在 10 秒后开始计时，每 5 秒执行一次回调，重复 3 次。 scheduleOnce只执行一次的计时器（快捷方式） 1234this.scheduleOnce(function() &#123; // 这里的 this 指向 component this.doSomething(); &#125;, 2); 上面的计时器将在两秒后执行一次回调函数，之后就停止计时。 unschedule取消计时器 开发者可以使用回调函数本身来取消计时器： 12345678910this.count = 0; this.callback = function () &#123; if (this.count == 5) &#123; // 在第六次执行回调时取消这个计时器 this.unschedule(this.callback); &#125; this.doSomething(); this.count++; &#125; this.schedule(this.callback, 1); 注意：组件的计时器调用回调时，会将回调的 this 指定为组件本身，因此回调中可以直接使用 this。]]></content>
      <categories>
        <category>Cocos</category>
      </categories>
      <tags>
        <tag>Cocos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[whistle插件：whistle.script]]></title>
    <url>%2F2021%2F02%2F20%2F%E5%89%8D%E7%AB%AF%2Fwhistle%E6%8F%92%E4%BB%B6%EF%BC%9Awhistle.script%2F</url>
    <content type="text"><![CDATA[whistle.scriptwhistle.script为whistle的一个扩展脚本插件，可以直接在界面上引用全局安装的Node模块及Node的内容模块编写脚本操作请求及其响应，所有正常Node程序可以实现的功能，都可以通过该插件实现，包括： HTTP[s]: 动态设置whistle规则 拦截请求响应 控制请求响应速度 修改请求url、请求方法、请求头、请求内容 修改响应状态码、响应头、响应内容 在插件界面的Console上显示脚本程序 console.xxx 的内容，如果可以打印响应的内容或调试信息等 WebSocket: 动态设置whistle规则 拦截请求响应 修改发送或收到的数据 直接向WebSocket客户端或服务端发送数据 在插件界面的Console上显示脚本程序 console.xxx 的内容，如果可以打印发送和接收到的数据或调试信息等，从而通过该插件可以直接查看WebSocket的数据 Tunnel: 基本功能同WebSocket，可以用来直接操作Socket请求，如Protobuf协议的请求等 安装123npm install -g whistle.script# Mac、Linux用户可能需要加sudosudo npm install -g whistle.script 安装插件后要重启whistle才可以打开插件，否则unknown 使用打开script插件的界面，创建一个名字为 test 的脚本: 可以通过 Plugins-&gt;Home-&gt;script打开或右键并选择 在新标签页中打开 或者直接访问 http://local.whistlejs.com/plugin.script 设置规则 设置HTTP或HTTPs请求的whistle规则(操作HTTPs需要开启HTTPs拦截) 在界面中的test 脚本输入 1234567exports.handleRequestRules = (ctx) =&gt; &#123; // ctx.fullUrl 可以获取请求url // ctx.headers 可以获取请求头 // ctx.options 里面包含一些特殊的请求头字段，分别可以获取一些额外信息，如请求方法、设置的规则等 ctx.rules = [&apos;www.qq.com file://&#123;test.html&#125;&apos;]; ctx.values = &#123; &apos;test.html&apos;: &apos;Hello world.&apos; &#125;;&#125;; 如果里面包含一些异步方法可以采用generator函数或async函数，即：exports.handleRequestRules = function* (ctx) {} 或 exports.handleRequestRules = async () =&gt; {} 在whistle的Rules配置界面上输入规则: 1whistle.script://test www.ifeng.com www.qq.com www.baidu.com echo.websocket.org 如果需要通过配置给脚本传递一些额外参数，可以如下配置(注意中间不能有空格): 1whistle.script://test(a,b,c) www.ifeng.com www.qq.com www.baidu.com echo.websocket.org 可以在脚本中通过 process.args 获取: 12345exports.handleRequestRules = (ctx) =&gt; &#123; console.log(process.args); // output: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] ctx.rules = [&apos;www.qq.com file://&#123;test.html&#125;&apos;]; ctx.values = &#123; &apos;test.html&apos;: &apos;Hello world.&apos; &#125;; &#125;; 设置WebSocket请求的规则(需要开启HTTPs拦截): 123456exports.handleWebSocketRules = (ctx) =&gt; &#123; // ctx.fullUrl 可以获取请求url // ctx.headers 可以获取请求头 // ctx.options 里面包含一些特殊的请求头字段，分别可以获取一些额外信息，如请求方法、设置的规则等 this.rules = &apos;127.0.0.1 echo.websocket.org&apos;; &#125;; 接下来的操作同上。 设置Tunnel请求的规则(要测试可以暂时关闭HTTPs拦截): 123456exports.handleTunnel = (ctx) =&gt; &#123; // ctx.fullUrl 可以获取请求url // ctx.headers 可以获取请求头 // ctx.options 里面包含一些特殊的请求头字段，分别可以获取一些额外信息，如请求方法、设置的规则等 this.rules = &apos;127.0.0.1 www.baidu.com&apos;; &#125;; 接下来的操作同上。 操作请求 操作HTTP或HTTPs请求(操作HTTPs需要开启HTTPs拦截) 12345678910111213141516171819202122232425262728293031exports.handleRequest = function* (ctx, next) &#123; // ctx.fullUrl 可以获取请求url // ctx.headers 可以获取请求头 // ctx.options 里面包含一些特殊的请求头字段，分别可以获取一些额外信息，如请设置的规则等 // ctx.method 获取和设置请求方法 // const reqBody = yield ctx.getReqBody(); 获取请求body的Buffer数据，如果没有数据返回null // const reqText = yield ctx.getReqText(); 获取请求body的文本，如果没有返回&apos;&apos; // const formData = yield ctx.getReqForm(); 获取表单对象，如果不是表单，返回空对象&#123;&#125; // console.log(ctx.method, ctx.headers, reqBody); // ctx.req.body = String| Buffer | Stream | null，修改请求的内容 // 只有执行next方法后才可以把正常的请求发送出去 // 如果需要自定义请求，可以通过全局的request方法操作 // console.log(request); // next方法可以设置next(&#123; host, port &#125;); const &#123; statusCode, headers &#125; = yield next(); console.log(ctx.fullUrl, statusCode, headers); // const resBody = yield ctx.getResBody(); // const resText = yield ctx.getResText(); // ctx.status = 404; 修改响应状态码 // ctx.set(headers); 批量修改响应头 // ctx.set(&apos;x-test&apos;, &apos;abc&apos;); 修改响应头 // ctx.body = String| Buffer | Stream | null; 修改响应内容 &#125;; // 如果Node &gt;= 7.6，可以采用async await的方式 exports.handleRequest = async (ctx, next) =&gt; &#123; // do sth // next方法可以设置next(&#123; host, port &#125;); const &#123; statusCode, headers &#125; = await next(); // do sth &#125;; 在whistle的Rules配置界面上输入规则: 12345# 这里不能用whistle.script，否则请求不会转发到handleRequest# whistle.script只会执行handleXxxRules# 你也可以通过在handleXxxRules里面设置 script://test(a,b,c)，实现转发script://test www.ifeng.com www.qq.com www.baidu.com echo.websocket.org 需要在配置中带上参数，可以参考上面的规则设置 操作WebSocket请求(需要开启HTTPs拦截) 12345678910111213// Node &lt; 7.6可以改用genrator和yield exports.handleWebSocket = async (req, connect) =&gt; &#123; // connect方法可以设置connect(&#123; host, port &#125;); const res = await connect(); res.on(&apos;message&apos;, (data) =&gt; &#123; console.log(&apos;Received: &apos;, data); req.send(data); &#125;); req.on(&apos;message&apos;, (data) =&gt; &#123; console.log(&apos;Sent: &apos;, data); res.send(data); &#125;); &#125;; whistle规则配置同上 操作Tunnel请求 1234567// Node &gt;= 7.6可以改用async和await exports.handleTunnel = function* (req, connect) &#123; // connect方法可以设置connect(&#123; host, port &#125;); const res = yield connect(); req.pipe(res).pipe(req); // 也可以参考上面操作WebSocket，自己监听data和write方法处理，这样就可以直接修改和打印内容 &#125;; whistle规则配置同上 参考链接whistle.script]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器内核、渲染引擎、JS引擎]]></title>
    <url>%2F2021%2F02%2F20%2F%E5%89%8D%E7%AB%AF%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E3%80%81%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E3%80%81JS%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[定义 浏览器内核分成两部分：渲染引擎和JS引擎。 由于JS引擎越来越独立，浏览器内核 就倾向于 单指 渲染引擎。 渲染引擎是一种对HTML文档进行解析并将其显示在页面上的工具。（说白了，就是按照HTML代码在界面上绘制各种控件图形） 常见引擎渲染引擎 firefox使用gecko引擎 IE使用Trident引擎 2015年微软推出自己新的浏览器，原名叫斯巴达，后改名edge,使用edge引擎 opera最早使用Presto引擎，后来弃用 chrome\safari\opera使用webkit引擎 13年chrome和opera开始使用Blink引擎 JS 引擎 老版本IE使用Jscript引擎 IE9之后使用Chakra引擎 edge浏览器仍然使用Chakra引擎 firefox使用monkey系列引擎 safari使用的SquirrelFish系列引擎 Opera使用Carakan引擎 chrome使用V8引擎。nodeJs其实就是封装了V8引擎 参考链接浏览器内核、渲染引擎、JS引擎简介]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调试神器whistle的安装使用]]></title>
    <url>%2F2021%2F02%2F20%2F%E5%89%8D%E7%AB%AF%2F%E8%B0%83%E8%AF%95%E7%A5%9E%E5%99%A8whistle%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[搭建环境准备安装nodewhistle支持v0.10.0以上版本的Node，为获取更好的性能，推荐安装最新版本的Node。 123// 未安装的去官网进行安装// 安装后通过命令行可查看版本$ node -v 安装whistle对于全局安装，Mac或Linux的非root用户需要在命令行前面加sudo。1$ npm install -g whistle whistle安装完成后，执行命令 whistle help 或 w2 help，查看whistle的帮助信息。 12// 如果能正常输出whistle的帮助信息，表示whistle已安装成功$ w2 help 使用whistle123// 启动whistle// 不设置端口，默认8899$ w2 start -p 8899 Note: 如果要防止其他人访问配置页面，可以在启动时加上登录用户名和密码 -n yourusername -w yourpassword。 12// 重启whsitle$ w2 restart 12// 停止whistle$ w2 stop 123// 调试模式启动whistle// 主要用于查看whistle的异常及插件开发$ w2 run 配置代理配置信息 代理服务器：127.0.0.1 默认端口：8899，若被占用，可启动时设置端口 配置方式一：pc端官网推荐配置浏览器代理，推荐安装浏览器代理插件SwitchyOmega，就按官网的来吧，其他配置方式可参考官网 由于常用chrome，以chrome为例 安装根证书 参考网站：安装根证书 安装证书后就可以抓取https的包了 SwitchyOmega配置进入SwitchyOmega，点击安装扩展后，页面会自动跳转到 SwitchyOmega 的配置页，随后便有新手教程 点击左侧“新建情景模式…”，弹框提示“情景模式名称”，你可以输入“whistle” 类型为代理服务器，点击创建 修改代理服务器参数，代理协议为HTTP，代理服务器为127.0.0.1，代理端口为8899 “不代理的地址列表” 的输入框里的所有文本都删掉，因为里面的 host 在本地开发很大概率会用到 点击左侧“应用选项” 点击chrmoe右上角的圆圈，切换为whistle（一定是切换后才可以抓包） 浏览器进入local.whistlejs.com，可以打开界面，证明配置成功，可以开始抓包了 配置方式二：移动端移动端需要在设置中配置当前Wi-Fi的代理，以 iOS 为例： 注意 安装插件后要重启whistle才可以打开插件，否则unknown 参考链接whistle]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git：git stash]]></title>
    <url>%2F2020%2F11%2F02%2FGit%2FGit%EF%BC%9Agit%20stash%2F</url>
    <content type="text"><![CDATA[参考：git stash的详细讲解 作用 git stash命令用于暂时保存没有提交的工作。运行该命令后，所有没有commit的代码，都会暂时从工作区移除，回到上次commit时的状态。 它处于git reset –hard（完全放弃还修改了一半的代码）与git commit（提交代码）命令之间，很类似于“暂停”按钮。 1234567891011121314151617181920212223242526# 暂时保存没有提交的工作，并且将当前代码切换到HEAD提交上# 可以多次运行，以“先进后出”的stack结构存储$ git stash // git stash save# 展示目前存在的stash$ git stash show -p# 列出所有暂时保存的工作$ git stash liststash@&#123;0&#125;: WIP on workbranch: 56cd5d4 Revert &quot;update old files&quot;stash@&#123;1&#125;: WIP on project1: 1dd87ea commit &quot;fix typos and grammar&quot;# 恢复某个暂时保存的工作$ git stash apply stash@&#123;1&#125;# 恢复最近一次stash的文件$ git stash pop# 丢弃最近一次stash的文件$ git stash drop# 丢弃某一个stash的文件$ git stash drop stash@&#123;1&#125;# 删除所有的stash$ git stash clear 实际应用开发到一半,同步远端代码当你的开发进行到一半,但是代码还不想进行提交 ,然后需要同步去关联远端代码时.如果你本地的代码和远端代码没有冲突时,可以直接通过git pull解决.但是如果可能发生冲突怎么办.直接git pull会拒绝覆盖当前的修改. 遇到这种情况,需要先保存本地的代码,进行git pull,然后再pop出本地代码 123git stashgit pullgit stash pop 工作流被打断,需要先做别的需求当开发进行到一半,老板过来跟你说”线上有个bug,你现在给我改好,不然扣你鸡腿”.当然,你可以开一个新的分支,把当前代码提交过去,回头再merge,具体代码如下 繁琐的工作流示例 1234567$ git checkout -b my_wip$ git commit -a -m &quot;WIP&quot;$ git checkout master// edit emergency fix$ git commit -a -m &quot;Fix in a hurry&quot;$ git checkout my_wip$ git reset --soft HEAD^ 我们可以通过git stash来简化这个流程 正确姿势 1234$ git stash // 保存开发到一半的代码// edit emergency fix$ git commit -a -m &quot;Fix in a hurry&quot;$ git stash pop // 将代码追加到最新的提交]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git：git reset和git revert]]></title>
    <url>%2F2020%2F10%2F23%2FGit%2FGit%EF%BC%9Agit%20reset%E5%92%8Cgit%20revert%2F</url>
    <content type="text"><![CDATA[参考：Git撤销&amp;回滚操作(git reset 和 get revert) git reset git reset ：回滚到某次提交。 git reset –soft：此次提交之后的修改会被退回到暂存区 git reset –hard：此次提交之后的修改不做任何保留，git status 查看工作区是没有记录的。 git reset的作用是修改HEAD的位置 即将HEAD指向的位置改变为之前存在的某个版本，且那个版本之后提交的版本都会不见 查看版本号 1$ git log 回退，版本号填写前六位即可 1234$ git reset --hard &lt;目标版本号&gt;$ git reset --hard HEAD //当前版本$ git reset --hard HEAD^ //回退到上一个版本$ git reset --hard HEAD^^ //回退到上上一个版本 提交 12// 直接push会报错，需要强制push$ git push origin &lt;分支名&gt; --force git revert git revert用于“反做”某一个版本，以达到撤销该版本的修改的目的 即新增一个版本，该版本与想要回退的版本一致 查看版本号 1$ git log 回退，版本号填写前六位即可 12// -n是--no-commit如果不带这个参数会自动提交一条commit$ git revert -n &lt;目标版本号&gt; 提交 123$ git add .$ git commit -m &quot;revert&quot;$ git push origin &lt;分支名&gt; 实际应用场景场景一 糟了，我刚把不想要的代码，commit到本地仓库中了，但是还没有做push操作！ 在未进行git push前的所有操作，都是在“本地仓库”中执行的。我们暂且将“本地仓库”的代码还原操作叫做“撤销” 情况一文件被修改了，但未执行git add操作(working tree内撤销) 12$ git checkout fileName$ git checkout . 情况二同时对多个文件执行了git add操作，但本次只想提交其中一部分文件 1234$ git add *$ git status// 取消暂存$ git reset HEAD &lt;filename&gt; 情况三文件执行了git add操作，但想撤销对其的修改（index内回滚） 1234// 取消暂存$ git reset HEAD fileName// 撤销修改$ git checkout fileName 情况四修改的文件已被git commit，但想再次修改不再产生新的Commit 123// 修改最后一次提交 $ git add sample.txt$ git commit --amend -m&quot;说明&quot; 情况五已在本地进行了多次git commit操作，现在想撤销到其中某次Commit 1$ git reset [--hard|soft|mixed|merge|keep] [commit|HEAD] 场景二 彻底完了，刚线上更新的代码出现问题了，需要还原这次提交的代码！ 已进行git push，即已推送到“远程仓库”中。我们将已被提交到“远程仓库”的代码还原操作叫做“回滚”！注意：对远程仓库做回滚操作是有风险的，需提前做好备份和通知其他团队成员！ 如果你每次更新线上，都会打tag，那恭喜你，你可以很快的处理上述场景二的情况 1$ git checkout &lt;tag&gt; 如果你回到当前HEAD指向 1$ git checkout &lt;branch_name&gt; 情况一撤销指定文件到指定版本 1234// 查看指定文件的历史版本$ git log &lt;filename&gt;// 回滚到指定commitID$ git checkout &lt;commitID&gt; &lt;filename&gt; 情况二删除最后一次远程提交 方式一：使用revert12$ git revert HEAD$ git push origin master 方式二：使用reset 12$ git reset --hard HEAD^$ git push origin master -f 二者区别： revert是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在； reset是指将HEAD指针指到指定提交，历史记录中不会出现放弃的提交记录。 情况三回滚某次提交 123// 找到要回滚的commitID$ git log$ git revert commitID 场景三刚才我发现之前的某次提交太愚蠢了，现在想要干掉它！ 123$ git log// ^号代表目标版本号的前一次提交$ git rebase -i &lt;目标版本号&gt;^ 进入编辑器 将对应版本号前的 pick 改为 d ，即drop = remove commit，然后保存退出 1$ git push origin &lt;分支名&gt; -f 通过上述操作，如果你想对历史多个commit进行处理或者，可以选择git rebase -i，只需删除对应的记录就好 rebase还可对 commit 消息进行编辑，以及合并多个commit]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode：阶乘后的零]]></title>
    <url>%2F2020%2F10%2F16%2F%E7%AE%97%E6%B3%95%2FLeetCode%EF%BC%9A%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[阶乘后的零给定一个整数 n，返回 n! 结果尾数中零的数量。 测试用例121. 3 // 02. 6 // 1 解法一思路 3! = 3 2 1 6! = 6 5 4 3 2 * 1 10! = （5 2） 8 7 6 5 4 3 2 * 1 每一个5都可以找到偶数配对，就相当于一个5可以产生一个0。 找出阶乘中含有多少个因子5就可以了 算法123456789101112131415/** * @param &#123;number&#125; n * @return &#123;number&#125; */var trailingZeroes = function(n) &#123; let count = 0; for(let i = 5; i &lt;= n; i++)&#123; let temp = i; while(temp % 5 === 0) &#123; count ++; temp /= 5 &#125; &#125; return count;&#125;; 解法二思路 5 的因子一定是每隔 5 个数出现一次 25 = 5 5, 125 = 5 5 * 5 每隔 5 个数，出现一个 5，每隔 25 个数，出现 2 个 5，每隔 125 个数，出现 3 个 5… 因此找出现了多少次五个数，当这个次数大于5时，证明n大于25，有多一个5，以此类推，125同理。 count = n / 5 + n / 25 + n / 125 … 算法123456789101112/** * @param &#123;number&#125; n * @return &#123;number&#125; */var trailingZeroes = function(n) &#123; let count = 0; while (n &gt; 0) &#123; n = Math.floor(n / 5); count += n; &#125; return count;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：n数之和]]></title>
    <url>%2F2020%2F08%2F10%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9An%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[两数之和为0题目给定一个不重复的数字数组，找出该数组中两个数之和等于0的所有情况。 测试用例121. [1,2,3,-1] // [[1,-1]]2. [1,2,3,-3,-1] // [[1,1],[3,-3]] 解法思路 数组长度少于2则直接返回 取数组首元素，与剩余元素比较是否相加为0，若为0取该值，拼接为数组，否则undefined 递归剩余元素，将得到的返回值拼接，对于undefined的值不拼接 算法123456789101112131415161718192021222324252627/** * @param &#123;array&#125; arr * @return &#123;array&#125; */var addUpToZero = function (arr) &#123; if(arr.length &lt; 2) &#123; return; &#125; var left = arr.splice(0,1)[0]; var right, res; for(let i in arr) &#123; if(left + arr[i] === 0) &#123; right = arr.splice(i,1)[0]; &#125; &#125; if(right) &#123; res = [left, right]; &#125; var next = test(arr); if(res &amp;&amp; next)&#123; return [res].concat(next); &#125; else if (res) &#123; return [res]; &#125; else if (next) &#123; return next; &#125;&#125; 两数之和为target题目给定一个已按照升序排列的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1必须小于index2。 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 测试用例11. [2,7,11,15],9 // [1,2] 解法思路 双指针法，一个指向头，一个指向尾 判断和是否为target，是则返回 否则，若sum小于target，则指向头的指针往前移动；若大于，则尾部移动 算法123456789101112131415161718/** * @param &#123;number[]&#125; numbers * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function(numbers, target) &#123; let i = 0, j = numbers.length -1; while(i &lt; j) &#123; const sum = numbers[i] + numbers[j]; if (sum === target) &#123; return [i + 1, j + 1]; &#125; else if (sum &lt; target) &#123; i++; &#125; else &#123; j--; &#125; &#125;&#125;; n数之和为target题目给定一个无序数组，判断该数组中能否实现n个数之和等于target的情况。 测试用例11. [1,2,3,4],2,7 // true 解法思路算法12345678910111213141516 function getResult(arr,n,target)&#123; if(n==0&amp;&amp;target==0)&#123; return true; &#125; if(n&lt;0)&#123; return false; &#125; if(n&gt;0)&#123; for(var i in arr)&#123; var temp = arr.slice(i+1,arr.length); return getResult(temp,n-1,target-arr[i]) || getResult(temp,n,target); &#125; &#125;&#125;console.log(getResult([1,2,3,4],2,7)); //true]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git：git branch -f]]></title>
    <url>%2F2020%2F08%2F07%2FGit%2FGit%EF%BC%9Agit%20branch%20-f%2F</url>
    <content type="text"><![CDATA[使用相对引用最多的就是移动分支，可以直接使用 -f 选项让分支指向另一个提交 1git branch -f &lt;分支名&gt; &lt;目的位置&gt; 将mater分支指向HEAD的父级提交，即HEAD后退1步后的那次提交12// 需要注意HEAD指向哪里git branch -f master HEAD^ 将mater分支指向HEAD的第3级父提交，即HEAD后退3步后的那次提交1git branch -f master HEAD~3 将mater分支指向代号为c1那次提交，可通过git log查找其哈希值来替换c11git branch -f master c1]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git：删除远程仓库文件但不删除本地]]></title>
    <url>%2F2020%2F07%2F24%2FGit%2FGit%EF%BC%9A%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%96%87%E4%BB%B6%E4%BD%86%E4%B8%8D%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%2F</url>
    <content type="text"><![CDATA[更新 1$ git pull origin master 删除 1$ git rm -r --cached &lt;文件相对路径&gt; 备注 1$ git commit -m &quot;delete&quot; 上传 1$ git push -u origin master]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git：查看克隆下来的代码的信息]]></title>
    <url>%2F2020%2F07%2F24%2FGit%2FGit%EF%BC%9A%E6%9F%A5%E7%9C%8B%E5%85%8B%E9%9A%86%E4%B8%8B%E6%9D%A5%E7%9A%84%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[列出已经存在的远程分支 1$ git remote 列出详细信息，在每一个名字后面列出其远程url地址 1$ git remote -v v: verbose，显示对应的克隆地址。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[whistle：利用whistle mock 数据]]></title>
    <url>%2F2020%2F07%2F17%2F%E5%89%8D%E7%AB%AF%2Fwhistle%EF%BC%9A%E5%88%A9%E7%94%A8whistle%20mock%20%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[vasevase 是 whistle 提供了一个强大的 mock 数据的插件，强大之处是可以结合 js 语句 + mock 语法去生成数据。 安装1$ npm i -g whistle.vase 使用在whistle界面的“Plugins”菜单中可以打开 vase 的界面 mock 语法在vase界面新建配置 “mock_json_demo”，并选择模板为 mock，输入 12345678910// mock 语法&#123; &quot;list|5&quot;: [ &#123; &quot;name&quot;: &quot;@string&quot;, &quot;avatar&quot;: &quot;http://lorempixel.com/100/100/&quot;, &quot;id|+1&quot;: 10000 &#125; ]&#125; 然后在“Rules”中配置一条规则 1http://mock.local/data.json vase://mock_json_demo 打开测试地址 http://mock.local/data.json ，即可看到模拟的数据。 js 语法在vase界面新建配置 “json_engine_script”，并选择模板为 script，输入 1234567891011121314// js 语法var json = merge(&#123; page: req.query.pi, // 取url查询参数的分页字段，加到要返回的数据里，达到模拟分页数据的效果 total: 60&#125;, render(&apos;mock_json_demo&apos;, null, &apos;mock&apos;)); // render 可以渲染上文提到名为“mock_json_demo”的数据模板，返回一个json if (req.query.callback) &#123; // 如果查询参数带了callback，则返回jsonp out(header(&apos;content-type&apos;, &apos;application/javascript; charset=utf8&apos;)); var json_text = join([req.query.callback + &apos;(&apos;, json, &apos;)&apos;]); // join是内置方法，可合并一组数据 out(json_text); // 向body输出数据&#125; else &#123; // 没有callback则返回json out(header(&apos;content-type&apos;, &apos;application/json; charset=utf8&apos;)); out(json);&#125; 然后在“Rules”中配置一条规则 1http://mock.local/data.json vase://json_engine_script 打开 http://mock.local/data.json?callback=cb&amp;pi=1 ，即可看到模拟的数据，可尝试改变、删除 callback、pi 参数，会发现返回的数据会随之改变。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全：XSS和CSRF]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%85%B6%E4%BB%96%2F%E5%AE%89%E5%85%A8%EF%BC%9AXSS%E5%92%8CCSRF%2F</url>
    <content type="text"><![CDATA[XSS攻击（跨站脚本攻击）原理恶意攻击者往web页面里插入恶意可执行网页脚本代码，当用户浏览该页面时，嵌入其中web里面的脚本代码会被执行，从而达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。 分类 存储型XSS恶意代码存储在数据库中 反射型XSS恶意代码存储在url中 DOM型XSS取出和执行恶意代码都是浏览器端完成防御开启CSP建立白名单，明确告诉浏览器哪些外部资源可以加载和执行。 设置http header中的Content-Security-Policy 设置meta标签1&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt; 输入输出过滤前端负责，后端也要做相同的过滤检查，因为攻击者完全可以绕过正常的输入流程，直接利用相关接口向服务器发送设置。 转义字符转义输入输出的内容，对于引号、尖括号、斜杠进行转义。 cookieweb应用程序在设置cookie时，将其属性设为HttpOnly，这样设置的cookie，js就无法进行读写，就可以预防XSS攻击窃取用户cookie，保护用户cookie信息。 CSRF攻击（跨站请求伪造）原理攻击者通过一些技术手段欺骗用户的浏览器去訪问一个自己以前认证过的站点并运行一些操作。 利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。可以这么理解：攻击者盗用了你的身份，以你的名义发送恶意请求。 一般发起攻击的是第三方网站。是利用用户的登录凭证，冒用用户信息，不能获取用户的数据。 CSRF攻击是源于WEB的隐式身份验证机制。WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的。 分类 get类型可以将get请求嵌入img标签，打开页面自动发送请求。 post类型可以利用自动提交的form表单，访问页面就会自动提交。 链接型需要用户点击链接才会触发。防御post尽量使用post请求，避免get请求。 cookie对cookie设置SameSite属性。该属性表示cookie不随跨域请求发送，可以很大程度减少csrf攻击。 token 用户访问某个表单页面。 服务端生成一个Token，放在用户的Session或者浏览器的Cookie中。 在页面表单附带上Token参数。 用户发送请求时以参数的形式带上本次页面中生成的token，服务端验证表单中的Token是否与用户Session（或Cookies）中的Token一致，一致为合法请求，不是则非法请求。 仅仅用来防御csrf攻击，当加上xss攻击时，无用 验证码xss和csrf 通常来说csrf是由xss引起的 xss是代码注入问题，csrf是http问题 同源策略同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。所以a.com下的js脚本采用ajax读取b.com里面的文件数据是会报错的。 不受同源策略限制的： 页面中的链接，重定向以及表单提交是不会受到同源策略限制的。 跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的script标签的src属性、img标签、link标签、iframe标签等。 通过标签的方式发起的请求不受同源策略的限制。且发送请求时浏览器会携带对应的cookie。 SQL注入原理通过传入一些特殊字符，从而达到欺骗服务器执行恶意的SQL命令的目的。 如输入特殊的用户名 123456//理想中的输入：admin passwordSELECT * FROM user WHERE username=&apos;admin&apos; AND psw=&apos;password&apos;//特殊用户名：admin&apos; --SELECT * FROM user WHERE username=&apos;admin&apos; --&apos; AND psw=&apos;xxxx&apos;//在SQL中，--是注释后面的内容的意思 防御 严格限制web应用的数据库的操作权限。 后端代码检查输入的数据是否符合预期。 对特殊字符进行转义处理。]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全：cookie和session]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%85%B6%E4%BB%96%2F%E5%AE%89%E5%85%A8%EF%BC%9Acookie%E5%92%8Csession%2F</url>
    <content type="text"><![CDATA[前言 会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。 Cookie通过在客户端记录信息确定用户身份。 Session通过在服务器端记录信息确定用户身份。 cookie在程序中，会话跟踪是很重要的事情。理论上，一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。 Web应用程序是使用HTTP协议传输数据的。==HTTP协议是无状态的协议==。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。 什么是cookiecookie其实是存储在浏览器中的纯文本，是服务器发送出来存储在浏览器上的一组组键值对，浏览器的安装目录下会专门有一个cookie文件夹来存放各个域下设置的cookie。 cookie怎么工作 存储cookie是浏览器提供的功能。 若客户端首次请求服务器，浏览器会添加请求头中的 cookie字段为{}，把请求的网址连同该Cookie一同提交给服务器。如果服务器需要记录该用户状态，就向客户端浏览器返回Cookie，客户端浏览器会把Cookie保存起来。 当网页要再次发http请求时，浏览器会先检查是否有相应的 cookie，有则自动把所有这个服务器Cookie添加在 request header中的 cookie字段中，把请求的网址连同该Cookie一同提交给服务器。这些是浏览器自动帮我们做的，而且每一次 http请求浏览器都会自动帮我们做。 服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容 cookie的存放有大小限制，不可以超过4kb, 每一个域名下的cookie数量最多是20个 获取cookiedocument.cookie，只能获取非HttpOnly类型的cookie。 打印出的结果是一个字符串类型，因为 cookie本身就是存储在浏览器中的字符串。但这个字符串是有格式的，由键值对 key=value构成，键值对之间由一个 分号和一个 空格隔开。 1key=value; key=value Cookie的不可跨域名性受同源策略限制，跨域的ajax请求默认不携带cookie，那为什么还会有csrf攻击呢？ 12由于script、img、iframe的src都不受同源策略影响，可以利用此来实现跨域请求，来实施攻击。浏览器会依据加载的域名附带上对应域名的cookie 例如，a.com是一个银行网站，用户在此网站登录且生成了授权的cookie，此时浏览器保存了这个cookie。随后访问 b.com，在这个网站中伪造一个请求a网站的请求，如转账、删除操作等，利用script、img、iframe来加载a网站的地址，浏览器就会携带上a网站此登陆用户的授权cookie信息，这样就构成了csrf攻击。 cookie的属性 属性名 数据类型 描述 name String 该Cookie的名称。Cookie一旦创建，名称便不可更改 value Object 该Cookie的值。如果值为Unicode字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码 maxAge int 该Cookie失效的时间，单位秒。如果为正数，则该Cookie在maxAge秒之后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。如果为0，表示删除该Cookie。默认为–1 secure boolean 该Cookie是否仅被使用安全协议传输。安全协议。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false path String 该Cookie的使用路径。如果设置为“/sessionWeb/”，则只有contextPath为“/sessionWeb”的程序可以访问该Cookie。如果设置为“/”，则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为“/” domain String 可以访问该Cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.” comment String 该Cookie的用处说明。浏览器显示Cookie信息的时候显示该说明 version int 该Cookie使用的版本号。0表示遵循Netscape的Cookie规范，1表示遵循W3C的RFC 2109规范 cookie的修改和删除 服务器可以对cookie进行操作，浏览器只能对非HttpOnly类型的cookie进行操作（为了预防xss攻击）。 Cookie并不提供修改、删除操作。 如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。 如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。注意是0而不是负数。负数代表其他的意义。 注意：修改、删除Cookie时，新建的Cookie除value、maxAge之外的所有属性，例如name、path、domain等，都要与原Cookie完全一样。否则，浏览器将视为两个不同的Cookie不予覆盖，导致修改、删除失败。 session除了使用Cookie，Web应用程序中还经常使用Session来记录客户端状态。Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。 session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。 什么是session 客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。 客户端浏览器再次访问时只需要从该session中查找该客户的状态就可以了。 session对象是在客户端第一次请求服务器的时候创建的。session也是一种key-value的属性对 如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。 session的生命周期session保存在服务器端。为了获得更高的存取速度，服务器一般把session放在内存里。每个用户都会有一个独立的session。如果session内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。因此，session里的信息应该尽量精简。 session在用户第一次访问服务器的时候自动创建。需要注意只有访问JSP、Servlet等程序时才会创建session，只访问HTML、IMAGE等静态资源并不会创建session。如果尚未生成session，也可以使用request.getSession(true)强制生成session。 session生成后，只要用户继续访问，服务器就会更新session的最后访问时间，并维护该session。用户每访问服务器一次，无论是否读写session，服务器都认为该用户的Session“活跃（active）”了一次。 为防止内存溢出，服务器会把长时间内没有活跃的session从内存删除。这个时间就是session的超时时间。如果超过了超时时间没访问过服务器，session就自动失效了。tomcat默认失效时间为20分钟。 session对浏览器的要求虽然session保存在服务器，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为session需要使用Cookie作为识别标志。HTTP协议是无状态的，session不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为JSESSIONID的Cookie，它的值为该session的id（也就是HttpSession.getId()的返回值）。session依据该Cookie来识别是否为同一用户。 如果客户端浏览器将Cookie功能禁用，或者不支持Cookie怎么办？例如，绝大多数的手机浏览器都不支持Cookie。Java Web提供了另一种解决方案：URL地址重写。 URL地址重写URL地址重写是对客户端不支持Cookie的解决方案。URL地址重写的原理是将该用户session的id信息重写到URL地址中。服务器能够解析重写后的URL获取session的id。这样即使客户端不支持Cookie，也可以使用session来记录用户状态。 两者区别 cookie数据存放在客户的浏览器上，session数据放在服务器上的，但名为JSESSIONID的Cookie（值为该Session的id）是放在客户端的。 cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。 设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话。 session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。(Session对象没有对存储的数据量的限制，其中可以保存更为复杂的数据类型) 两者最大的区别在于生存周期，session是IE启动到IE关闭.(浏览器页面一关 ,session就消失了)，cookie是预先设置的生存周期，或永久的保存于本地的文件。]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web页面性能优化]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%89%8D%E7%AB%AF%2Fweb%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[请求和响应减少http请求。一个完整的请求都需要经过 DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个 “漫长” 而复杂的过程。资源上由于每个请求都需要携带数据，因此每个请求都需要占用带宽。 使用CDN加速（缓存）。CDN（内容发布网络）是一组分布在多个不同地理位置的Web服务器，用于更加有效地向用户发布内容。其本质上是一个缓存，而且将数据（js、css、image等静态资源）缓存在离用户最近的地方，使用户以最快速度获取数据，即所谓网络访问第一跳。 使用内容传递网络(CDN)提供 JavaScript 文件,CDN 不仅可以提高性能,它还可以为你管理压缩和缓存。 当用户发起访问时，他的访问请求被只能dns定位到最近的缓存服务器，当服务器中没有缓存时，就会去请求最近的服务器中的资源。 利用浏览器缓存通过设置 HTTP 响应报文头使 JavaScript 文件可缓存,将网络资源存储到本地，下次请求资源时，如果命中可直接在本地获取，不需要重新向服务器请求资源 避免重定向。当页面发生了重定向，就会延迟整个HTML文档的传输。在HTML文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载。 重定向和404将浪费加载请求。 HTML合理使用内联。脚本和样式，应按需选择内联或者外链。对于访问少、样式和脚本复用少的页面，可以考虑使用内联样式从而减少 HTTP 请求。 但如果页面访问频繁，样式脚本在多个页面经常复用，使用外链则是最优选择。 这样浏览器可以缓存它们，下次加载时可以直接从缓存加载。 减少dom过多的DOM元素会影响渲染、加载、执行。除了精简页面结构外，还可以适时删除不必要的DOM元素（页面内已经不会再访问的元素），又或者可以懒加载（不一定会使用到的元素，如登录框）。 优化dom操作 使用事件委托来减少事件处理器的数量 减少重绘和回流 如果需要在 DOM操作时添加样式，尽量使用 增加 class 属性，而不是通过 style 一个一个地操作样式。 删除HTML的默认属性。js优化js。 将所有script标签放置在页面的底部,紧靠 body 关闭标签的上方。因为页面解析生成dom树时遇到script标签会停下去加载执行js。此法可以保证页面在脚本运行之前完成解析。 将脚本成组打包。页面的标签越少,页面的加载速度就越快,响应也更加迅速。不论外部脚本 文件还是内联代码都是如此。 由于浏览器渲染机制的设置，gui渲染线程和js引擎互斥，因此js的执行会阻塞dom的解析和渲染以及其他资源的加载。 css将样式表放在头部。css在head中通过link引入下载会阻塞页面的渲染，页面的渲染会等待css解析完生成cssom树，再结合dom树生成渲染树进行渲染。所以最好的做法是把css放在页面的最上面，让浏览器尽快下载css，减少首屏加载时间，避免白屏。 为了浏览器的渲染，能让页面显示的时候视觉上更好。避免某些情况，如：假设你放在页面最底部，则不会阻塞，用户打开页面时，有可能出现，页面先是显示一大堆文字或图片，自上而下，丝毫没有排版和样式可言。最后，页面又恢复所要的效果 由于gui渲染机制和js引擎互斥，因此css加载会阻塞js的加载，但是cssom和dom是并行的，css加载并不阻塞dom的解析，也不阻塞其他资源的加载，但两者需要互相配合生成渲染树，因此会阻塞dom的渲染。 优化css，避免css表达式。会导致效率低下。 资源延迟加载图片。不直接给src路径，而是在页面加载完成后用js操作src，减少了页面加载图片的时间。 懒加载在进入可视区域之后在进行请求资源 预加载在静态资源使用前先加载，在使用时可直接在缓存中获取]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器本地缓存]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%89%8D%E7%AB%AF%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[定义缓存是性能优化中简单高效的一种优化方式。 和本地存储不一样，浏览器缓存是浏览器请求网站留下的资源副本。 好处 减少带宽消耗 提升性能 缓解服务器压力 缓存位置 Service Worker Memory Cache Disk Cache Push Cache 缓存策略浏览器第一次向服务器发起请求拿到请求结果后，根据请求资源时返回的响应头来确定该不该缓存。 浏览器常见字段 Expires：告知客户端资源缓存失效的绝对时间。 Cache-Control：告知客户端或服务器如何处理缓存 max-age=xxx：表示缓存内容将在缓存时间的xxx秒后失效 no-cache：表示可以缓存，但每次用都要去向服务器验证缓存是否可用。 no-store：表示所有内容都不会缓存。 private：客户端可以缓存。 public：客户端和代理服务器都可以缓存。默认值。 Last-Modified：资源最后一次修改时间。 Etag：文件的特殊标识。用于文件内容对比，判断内容是否修改。 Cache-Control优先级高于Expires。 Etag优先级高于Last-Modified。 强缓存 根据本地缓存资源的header中的Expires和Cache-Control来判断是否命中强缓存。 如果命中强缓存则返回缓存的数据。 如果没有命中则进入协商缓存。 协商缓存 如果没有命中强缓存，浏览器会将本地缓存资源的header中的Last-Modified和Etag的值分别放入请求头的IF-Modified-Since和IF-None-Match字段中，向服务器发送请求，由服务器根据请求中的相关header信息来对比结果是否命中协商缓存。 若命中即资源未更新，则服务器返回新的响应header信息且返回的http状态为304，但是并不返回资源内容，它会显示一个Not Modified的字符串，来告知浏览器使用缓存。 否则返回最新的数据，并将新数据存入缓存。 总结当浏览器再次访问一个已经访问过的资源时，会 先判断是否存在缓存，再看是否命中强缓存，如果命中，就直接使用缓存了。 如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存。 如果命中协商缓存，服务器会返回 304。 告诉浏览器使用本地缓存。 否则，返回最新的资源。 拓展ctrl+F5和F5的区别F5只是刷新本地缓存，强缓存无效，协商缓存有效；ctrl+F5是强缓存与协商缓存均无效，重新向服务器请求。 禁止浏览器缓存方法 设置响应头 12//把Cache-Control设置为no-cache&lt;meta HTTP-EQUIV=&quot;Cache-Control&quot; CONTENT=&quot;no-cache&quot;&gt; 在访问的url后添加一个参数，可以是随机数或者时间戳。这样url时刻在变化，就要重新发送http请求]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器渲染机制]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%89%8D%E7%AB%AF%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[进程和线程 进程时cpu资源分配的最小单位，是能拥有资源和独立运行的最小的单位。 线程是cpu调度的最小单位，是建立在进程基础上的一次程序运行单位。 对于操作系统来说，一个任务就是一个进程，一个进程至少有一个线程 浏览器的多进程架构 主进程负责浏览器界面的显示与交互。各个页面的管理,创建和销毁其他进程。网络的资源管理、下载等。 第三方插件进程每种类型的插件对应一个进程,仅当使用该插件时才创建。 GPU 进程最多只有一个,用于 3D 绘制等 渲染进程称为浏览器渲染进程或浏览器内核,内部是多线程的。主要负责页面渲染,脚本执行,事件处理等。 渲染进程浏览器的渲染进程是多线程的 GUI 渲染线程 负责渲染浏览器界面，解析 HTML、CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。 注意，==GUI 渲染线程与 JS 引擎线程是互斥的==，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。 JS 引擎线程 Javascript 引擎，也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎） JS 引擎线程负责解析 Javascript 脚本，运行代码。 JS 引擎一直等待着任务队列中任务的到来,然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序。 注意，==GUI 渲染线程与 JS 引擎线程是互斥的==，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。 事件触发线程 归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解,JS 引擎自己都忙不过来，需要浏览器另开线程协助） 当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程，如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理 注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行） 定时触发器线程 传说中的 setInterval 与 setTimeout 所在线程 浏览器定时计数器并不是由 JavaScript 引擎计数的，（因为 JavaScript 引擎是单线程的， 如果处于阻塞线程状态就会影响记计时的准确） 因此通过单独线程来计时并触发定时（计时完毕后,添加到事件队列中，等待 JS 引擎空闲后执行） 注意，W3C 在 HTML 标准中规定,规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。 异步 http 请求线程 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求。 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。 题目1. 为什么 Javascript 要是单线程的 ? 如果 JavaScript 是多线程的方式来操作这些 UI DOM,则可能出现 UI 操作的冲突。 如果 Javascript 是多线程的话,在多线程的交互下,处于 UI 中的 DOM 节点就可能成为一个临界资源, 假设存在两个线程同时操作一个 DOM,一个负责修改一个负责删除,那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。 当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性,Javascript 在最初就选择了单线程执行。 2. 为什么 JS 阻塞页面加载 ? 由于 JavaScript 是可操纵 DOM 的,如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了。 因此为了防止渲染出现不可预期的结果,浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系。 3. css 加载会造成阻塞吗 ？ CSS 加载不会阻塞 DOM 的解析，会阻塞 Dom 的渲染 DOM 和 CSSOM 通常是并行构建的,所以 CSS 加载不会阻塞 DOM 的解析。 然而,由于 渲染树 是依赖于 DOM树 和 CSSOM树 的,所以他必须等待到 CSSOM树 构建完成,也就是 CSS 资源加载完成(或者 CSS 资源加载失败)后,才能开始渲染。因此,CSS 加载会阻塞 Dom 的渲染。 css 会阻塞后面 js 的执行。 由于 GUI 渲染线程与 JavaScript 引擎为互斥的关系。因此,样式表会在后面的 js 执行前先加载执行完毕,所以css 会阻塞后面 js 的执行。 4. DOMContentLoaded 与 load 的区别 ? 当 DOMContentLoaded 事件触发时,仅当 DOM 解析完成后,不包括样式表,图片。 当文档中没有脚本时,浏览器解析完文档便能触发 DOMContentLoaded 事件。如果文档中包含脚本,则脚本会阻塞文档的解析,而脚本需要等 CSSOM 构建完成才能执行。在任何情况下,DOMContentLoaded 的触发不需要等待图片等其他资源加载完成。 当 onload 事件触发时,页面上所有的 DOM,样式表,脚本,图片等资源已经加载完毕。 DOMContentLoaded -&gt; load 5. defer 和 async 的区别 ? 没有 defer 或 async,浏览器会立即加载并执行指定的脚本,“立即”指的是在渲染该 script 标签之下的文档元素之前,也就是说不等待后续载入的文档元素,读到就加载并执行。 有 async,加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。 有 defer,加载后续文档元素的过程将和 script.js 的加载并行进行（异步）,但是 script.js 的执行要在所有元素解析完成之后,DOMContentLoaded 事件触发之前完成。 总结 defer 和 async 在网络读取（下载）这块儿是一样的,都是异步的（相较于 HTML 解析），差别在于脚本下载完之后何时执行,显然 defer 是最接近我们对于应用脚本加载和执行的要求的 关于 defer，它是按照加载顺序执行脚本的；async 则是乱序执行的，反正对它来说脚本的加载和执行是紧紧挨着的,所以不管你声明的顺序如何,只要它加载完了就会立刻执行 仔细想想,async 对于应用脚本的用处不大,因为它完全不考虑依赖（哪怕是最低级的顺序执行）,不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网：TCP]]></title>
    <url>%2F2020%2F05%2F14%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9ATCP%2F</url>
    <content type="text"><![CDATA[TCP和UDP 都是运输层协议 tcp有连接，可靠：数据包校验、对失序数据包重排序、丢弃重复数据、应答机制、超时重传、流量控制。 udp无连接，快。只是传输数据，不管服务器是否收到。 TCP拥塞控制防止过多数据注入到网络中，这样可以使网络中的路由器或链路不致过载。 慢开始 把初始拥塞窗口cwnd设置为1或2个发送方的最大报文段（SMSS），由小到大逐渐增大发送窗口。每经过一个传输轮次，cwnd加倍。 把拥塞窗口允许发送的报文段都连续发送出去，收到对已发送的最后一个字节的确认，为一个传输轮次，时间为一个往返时间。 拥塞避免 让拥塞窗口缓慢增大，没经过一个往返时间RTT就加1 快重传 让发送方尽早知道发生了个别报文段丢失 快恢复 发送方知道丢失报文段，则不启动慢开始，用快恢复，调整门限值cwnd/2. TCP建立连接——三次握手 客户端发送连接请求报文，将SYN位置设为1 服务器端收到报文后回复ACK+SYN报文。 客户端接收到报文后也向服务器端发送ACK报文，这个报文发送完毕后，完成了三次握手。 通过三次握手确认双方收发功能都正常，四次也可以但是显得比较多余。 TCP释放连接——四次挥手（断开连接） 客户端向服务器传送断开的请求包。客户端进入FIN_WAIT_1状态。 服务器端确定收到断开的请求，回复ACK报文。客户端进入FIN_WAIT_2状态。 服务器端向客户端FIN报文，请求关闭连接。服务器端进入LAST_ACK状态。 客户端收到FIN报文后，回复ACK报文。客户端进入TIME_WAIT状态。服务器端收到ACK报文就会关闭连接（不然一直处于LAST_ACK状态），客户端没有收到服务器端的回复，证明服务器端已关闭连接，客户端也可以关闭连接了。]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网：http和https]]></title>
    <url>%2F2020%2F05%2F14%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9Ahttp%E5%92%8Chttps%2F</url>
    <content type="text"><![CDATA[关于https用处： 建立一个信息安全通道，来保证数据传输的安全。 确认网站的真实性，防止钓鱼网站。 https就是在http下加入了ssl层，从而保护了交换数据隐私和完整性，提供了对网站服务器身份认证的功能，简单来说就是安全版的http。 http和https的区别 同属于应用层的协议 http协议是运行在tcp之上的，所有传输的内容都是未加密的，也就是明文的。https协议是运行在SSL\TLS之上的，而SSL\TLS协议运行在tcp之上，在http和tcp之间，所有传输的内容都经过加密的，比http更安全。（加密采用对称加密，而密钥的传输利用非对称加密） http默认使用端口80。https默认使用端口443。 https的工作原理 使用HTTPS的url访问服务器，客户端向服务器端请求建立SSL连接。（可以说TLS为SSL的新版本） 服务器收到客户端请求后，会将网站的证书信息（证书包含公钥）传送一份给客户端。 客户端浏览器和服务器端协商信息加密的等级。 客户端浏览器根据协商好的安全等级，建立会话密钥，然后利用网站的公钥加密会话密钥，并传送给服务器。 服务器利用私钥解密会话密钥，并利用会话密钥加密与客户端之间的通信。 非对称密码解密速度比较慢，但比较安全；对称密码解密速度比较快。所以用对称密码加密数据，非对称密码加密对称密钥。 非对称加密算法中私钥是基于不同的算法生成不同的随机数，私钥通过一定的加密算法推导出公钥，但私钥到公钥的推导过程是单向的，也就是说公钥无法反推导出私钥。]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：青蛙跳台阶和斐波那契数列]]></title>
    <url>%2F2020%2F03%2F17%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E5%92%8C%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[简单一次跳一层或两层，求跳上一个n级的台阶总共有多少种跳法。因为n级台阶，第一步有n种跳法：跳1级、跳2级跳1级，剩下n-1级，则剩下跳法是f(n-1)跳2级，剩下n-2级，则剩下跳法是f(n-2) f(0)=0f(1)=1f(2)=2f(n)=f(n-1)+f(n-2) 1234567891011function jump(n)&#123; if(n==0)&#123; return 0; &#125;else if(n==1)&#123; return 1; &#125;else if(n==2)&#123; return 2; &#125;else&#123; return jump(n-1)+jump(n-2); &#125;&#125; 复杂一次可以跳上1级台阶，也可以跳上2级……也可以跳上n级。求跳上一个n级的台阶总共有多少种跳法。因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级跳1级，剩下n-1级，则剩下跳法是f(n-1)跳2级，剩下n-2级，则剩下跳法是f(n-2)所以f(n)=f(n-1)+f(n-2)+…+f(1)因为f(n-1)=f(n-2)+f(n-3)+…+f(1)所以f(n)=2*f(n-1) 123456789function jumpII(number)&#123; if(number == 0)&#123; return 0; &#125;else if(number == 1)&#123; return 1; &#125; return 2*jumpII(number-1)&#125; 斐波那契数列斐波那契数列，又称黄金分割数列、因数学家列昂纳多·斐波那契以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、…… 性能优化之缓存 缓存: 存储数据的容器(cache) 在js中, 可以使用数组或者是对象进行存储数据,用键存储值,这样就可以实现既能存值也能取值 用缓存的基本思路 创建一个空对象，作为缓存的容器。 首先去缓存容器中查看缓存中是否有对应的数据，如果有，直接取出来使用。 如果没有，就先计算结果，然后把结果存储到缓存容器中，方便下次复用。123456789101112131415161718var cache = &#123; &#125;;var count = 0;function fib(n)&#123; count++; if(n === 1 || n === 2)&#123; return 1; &#125; if(cache[n])&#123; return cache[n]; &#125;else&#123; var ret = fib(n - 1) + fib(n - 2); cache[n] = ret; return ret; &#125;&#125;console.log(fib(10));console.log(&quot;fib函数调用的次数 &quot; + count); 总结 缓存: 存数据(该案例中,用键存月份,值存的对数) 在js中,缓存中如何表示, 对象 || 数组]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6：箭头函数]]></title>
    <url>%2F2020%2F03%2F17%2FES6%2FES6%EF%BC%9A%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[箭头函数体内的this对象是定义时所在的对象，而不是使用时所在的对象。 this指向调用箭头函数外层函数的对象（即箭头函数所在作用域的父级作用域），没有外层函数则指向window。 箭头函数相当于匿名函数。 箭头函数不可以当作构造函数，即不可以用new命令。 箭头函数不可以使用arguments对象，该对象在函数体内不存在。要用，就用rest参数代替。 箭头函数的this指向其上下文的this，通过call、apply也无法修改其指向。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git：Git使用]]></title>
    <url>%2F2020%2F03%2F17%2FGit%2FGit%EF%BC%9AGit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[git的简介、安装就不罗嗦了，详细的教程可参考廖雪峰的git教程 创建版本库（初始化一个git仓库）第一步选择一个合适的地方，创建一个空目录learngit 123$ mkdir learngit$ cd learngit$ pwd pwd命令用于显示当前目录 第二步通过git init命令把这个目录变成Git可以管理的仓库 1$ git init 1、此时可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 2、如果没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 添加文件到Git仓库编写一个readme.txt文件内容为： 12Git is a version control system.Git is free software. 第一步用命令git add告诉Git，把文件添加到仓库 1$ git add readme.txt 1、执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功 2、add可反复多次使用，添加多个文件 第二步用命令git commit告诉Git，把文件提交到仓库 1$ git commit -m &quot;wrote a readme file&quot; 1、-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的 2、commit可以一次提交很多文件，所以你可以多次add不同的文件 修改文件并提交修改readme.txt文件，改成如下内容 12Git is a distributed version control system.Git is free software. git status运行git status命令看看结果 1$ git status git status命令可以让我们时刻掌握仓库当前的状态 git diff比如有一个项目，隔了好几天没碰过了，想要继续写的时候，又忘了上次是怎么修改的，那么运行git diff命令看看具体修改了什么内容 1$ git diff readme.txt git diff顾名思义就是查看difference 提交修改（与提交新文件一样）第一步git add 1$ git add readme.txt 第二步git commit 1$ git commit -m &quot;add distributed&quot; 版本回退现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了 版本一：wrote a readme file 12Git is a version control system.Git is free software. 版本二：add distributed 12Git is a distributed version control system.Git is free software. git log运行git log命令可以查看每次修改的历史记录 1$ git log 该命令显示从最近到最远的提交日志 回退git reset运行git reset命令把版本二回退到版本一 123$ git reset --hard HEAD //当前版本$ git reset --hard HEAD^ //回退到上一个版本$ git reset --hard HEAD^^ //回退到上上一个版本 若有多个版本，可继续使用git reset命令回退 cat 看看readme.txt的内容是不是版本一 1$ cat readme.txt 后悔回退，恢复版本此时，使用git log看一下版本库里的版本，哎呀，版本二不见了那如果此时我又后悔了，我想要回退之前的版本了 1$ git reset --hard 所需版本的commit id commit id不知道怎么办？？？1、不怕，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到回退前执行git log后的版本库，每一个版本的commit后那一长串乱码一样的东西就是该版本的commit id了当然，commit id很长，没必要写全，写前几位就好了（一般七位吧） 恢复版本二 1$ git reset --hard f3ab58 2、可是，当你关掉了命令行窗口后才后悔怎么办？？？不怕，在Git中，总是有后悔药可以吃的 Git提供了一个命令git reflog用来记录你的每一次命令 1$ git reflog 又可以找回所需版本的commit id了 工作区与暂存区工作区就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区 版本库工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库 Git的版本库里存了很多东西1、最重要的就是称为stage（或者叫index）的暂存区2、还有Git为我们自动创建的第一个分支master3、以及指向master的一个指针叫HEAD 前面讲了提交新文件到Git版本库： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支 撤销修改git checkout – file场景一（仅修改了文件） 有一次头脑混乱，在readme.txt中加了一行乱码，死定了，要赶紧手动删掉，以为这样就没事了吗？不，事儿可大了，运行git status查看 1$ git status 会显示改动了readme.txt 这时候，运行git checkout – file丢弃工作区的修改即可 1$ git checkout -- readme.txt 有两种情况（都是修改了工作区的文件导致工作区与版本库不一致）： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态 git reset HEAD file场景二（修改文件后，git add到暂存区了） 有一次头脑更混乱，不仅在readme.txt中加了一行乱码，还git add到暂存区了 幸好，用git status查看 1$ git status 显示还没有提交 这时候运行命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区即可 1$ git reset HEAD readme.txt 再用git status查看 1$ git status 现在暂存区是干净的，工作区有修改，回到场景一即可 1$ git checkout -- readme.txt 版本回退场景三（改了文件，不仅添加了，还提交了） 回到上上一个内容版本回退了 删除文件一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了 1$ rm test.txt Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了 1$ git status 此时有两种情况 第一种情况确实要从版本库中删除该文件 运行命令git rm删掉 1$ git rm test.txt 并且git commit 1$ git commit -m &quot;remove test.txt&quot; 第二种情况删错了 因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本 1$ git checkout -- test.txt git checkout – file 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原” 远程仓库git的杀手级功能—远程仓库这个世界上有个叫GitHub的神奇的网站，这个网站是提供Git仓库托管服务的，只要注册一个GitHub账号，就可以免费获得Git远程仓库 设置SSH Key由于本地Git仓库和GitHub仓库之间的传输是通过SSH加密的 第一步创建SSH Key 在用户主目录下，看看有没有.ssh目录；如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件；如果已经有了，可直接跳到下一步 如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码 第二步登陆GitHub，打开“Account settings”，“SSH Keys”页面， 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容 把本地项目添加到远程库第一步通过命令git init把项目文件夹变成Git可管理的仓库 1$ git init 第二步把项目粘贴到这个本地Git仓库里面 1$ git add . 第三步把项目提交到仓库 1$ git commit -m &quot;注释&quot; 第四步登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库，在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库 目前，在GitHub上的这个learngit仓库还是空的 第五步在本地的learngit仓库下运行命令 1$ git remote add origin git@github.com:michaelliao/learngit.git michaelliao替换成自己的GitHub账户名使本地仓库关联远程库添加后，远程库的名字就是origin，这是Git默认的叫法 第六步把本地库的所有内容推送到远程库上 1$ git push -u origin master 最后的最后从现在起，只要本地作了提交，就可以运行命令把本地master分支的最新修改推送至GitHub 1$ git push origin master 从远程库克隆到本地库第一步登陆GitHub，创建一个新的仓库，名字叫gitskills勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件 第二步用命令git clone克隆一个本地库 1$ git clone git@github.com:michaelliao/gitskills.git michaelliao替换成自己的GitHub账户名 分支管理创建与合并分支一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长 第一步创建dev分支 1$ git branch dev 切换到dev分支 1$ git checkout dev 可合并为创建并切换到dev分支 1$ git checkout -b dev 第二步用git branch命令查看当前分支 123$ git branch* dev master git branch命令会列出所有分支，当前分支前面会标一个*号 第三步在dev分支上正常提交比如对readme.txt做个修改，加上一行 1Creating a new branch is quick. 然后提交 12$ git add readme.txt $ git commit -m &quot;branch test&quot; 第四步现在，dev分支的工作完成，我们就可以切换回master分支 1$ git checkout master 切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变 第五步把dev分支的工作成果合并到master分支上 1$ git merge dev git merge命令用于合并指定分支到当前分支注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式 第六步合并完成后，就可以放心地删除dev分支了 1$ git branch -d dev 删除后，查看branch，就只剩下master分支了 12$ git branch* master 解决冲突第一步此时，创建了一个新的分支feature1 1$ git checkout -b feature1 在readme.txt最后添加一行并提交 1Creating a new branch is quick AND simple. 第二步切换到master分支 1$ git checkout master 在master分支上readme.txt最后添加一行并提交 1Creating a new branch is quick &amp; simple. 此时，master分支和feature1分支各自都分别有新的提交 第三步由于两个分支各自有修改，两者合并起来可能会有冲突 1$ git merge feature1 git status会告诉我们冲突的文件 1$ git status 也可以查看readme.txt的内容 1234567Git is a distributed version control system.Git is free software distributed under the GPL.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 第四步此时，需要手动修改冲突内容 123Git is a distributed version control system.Git is free software distributed under the GPL.Creating a new branch is quick and simple. 再提交 12$ git add readme.txt $ git commit -m &quot;conflict fixed&quot; 现在，master分支和feature1分支变成这样用带参数的git log也可以看到分支的合并情况 1$ git log --graph --pretty=oneline --abbrev-commit 第五步最后，删除feature1分支 1$ git branch -d feature1 分支管理策略通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息 第一步创建并切换dev分支 1$ git checkout -b dev 第二步修改readme.txt文件，并提交一个新的commit 12$ git add readme.txt $ git commit -m &quot;add merge&quot; 第三步切换回master 1$ git checkout master 第四步准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward 1$ git merge --no-ff -m &quot;merge with no-ff&quot; dev 加上-m参数，把commit描述写进去 合并后，我们用git log看看分支历史 1$ git log --graph --pretty=oneline --abbrev-commit Bug分支某天突然接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但当前正在dev上进行的工作还没有提交，并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug 第一步把当前工作现场“储藏”起来，等以后恢复现场后继续工作 1$ git stash 现在，用git status查看工作区，就是干净的 第二步首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支 1$ git checkout master 1$ git checkout -b issue-101 第三步修复bug，然后提交 12$ git add readme.txt $ git commit -m &quot;fix bug 101&quot; 第四步修复完成后，切换到master分支，并完成合并，最后删除issue-101分支 1$ git checkout master 1$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101 1$ git branch -d issue-101 第五步接着回到dev分支干活了 1$ git checkout dev 1$ git status 工作区是干净的，用git stash list命令看看刚才的工作现场存到哪去了？ 1$ git stash list 第六步恢复stash内容 一种是用git stash apply恢复，然后用git stash drop删除stash内容 另一种方式是用git stash pop，恢复的同时把stash内容也删了 1$ git stash pop 可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash 1$ git stash apply stash@&#123;0&#125; 疑问第一个问题在dev中工作，在master中创建分支修改bug，好像互不相干呀，为什么要stash呢？ 暂存区是公用的，如果不通过stash命令隐藏，会带到其它分支（issue-101）去 第二个问题为什么要创建分支修改bug呢，直接在master中改不就好了吗？ 实际项目中，这个bug可能很麻烦，你需要修复一天的时间才能搞定，如果你不创建101分支，那么这时候你们组内其他小伙伴也要紧急修复线上一个bug，但是他的bug可能就1分钟。他修复好了却不能上线，因为你没有创建分支，要等你一天，才能把你处理好的正确代码一起上线。可能也会觉得创建分支不够效率，但是工作中稳健很重要 Feature分支每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支 第一步开发并提交 1$ git checkout -b feature-vulcan 12$ git add vulcan.py$ git commit -m &quot;add feature vulcan&quot; 第二步切回dev，准备合并 1$ git checkout dev 第三步一切顺利的话，feature分支和bug分支是类似的，合并，然后删除但是，由于种种原因，新功能取消，这个分支必须就地销毁 1$ git branch -d feature-vulcan 销毁失败 Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改如果要强行删除，需要使用命令git branch -D feature-vulcan 1$ git branch -D feature-vulcan 多人协作查看远程库的信息 1$ git remote 显示更详细的信息 1$ git remote -v 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库 推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上 1$ git push origin master 或推送其他分支 1$ git push origin dev 注意： 1、master分支是主分支，因此要时刻与远程同步； 2、dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； 3、bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； 4、feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 抓取分支当push失败时，则因为远程分支比你的本地更新 先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送 1$ git pull git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接 设置dev和origin/dev的链接 1$ git branch --set-upstream dev origin/dev 再pull 1$ git pull git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样 解决后，提交，再push 标签管理创建标签首先，切换到需要打标签的分支上 12345$ git branch* dev master$ git checkout masterSwitched to branch &apos;master&apos; 创建一个新标签 1$ git tag &lt;name&gt; 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字 1$ git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot; 查看所有标签 12$ git tag //按字母排序$ git show &lt;tagname&gt; 默认标签是打在最新提交的commit上的 有时候，如果忘了打标签 方法是找到历史提交的commit id 1$ git log --pretty=oneline --abbrev-commit 然后打上标签就可以了1$ git tag &lt;name&gt; &lt;commit id&gt; 未完待续]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git：分支管理之合并]]></title>
    <url>%2F2020%2F03%2F17%2FGit%2FGit%EF%BC%9A%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E4%B9%8B%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[假设已存在分支dev，且修改部分代码 先把已修改的推上分支dev 把切换回主分支，下拉 运行合并指令 1git merge dev 合并后在本地修改冲突 再次commit并提交到主分支]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git：将在master分支上做的修改提交到分支]]></title>
    <url>%2F2020%2F03%2F17%2FGit%2FGit%EF%BC%9A%E5%B0%86%E5%9C%A8master%E5%88%86%E6%94%AF%E4%B8%8A%E5%81%9A%E7%9A%84%E4%BF%AE%E6%94%B9%E6%8F%90%E4%BA%A4%E5%88%B0%E5%88%86%E6%94%AF%2F</url>
    <content type="text"><![CDATA[前提我在master上修复了某个bug，但是master被锁定了，我想提交到dev分支，那么使用 cherry-pick可以满足我们的要求 1234//先从主分支记下id$ git log//切换到dev分支上$ git cherry-pick &lt;id&gt;]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git：添加到远程github仓库的一个错误]]></title>
    <url>%2F2020%2F03%2F17%2FGit%2FGit%EF%BC%9A%E6%B7%BB%E5%8A%A0%E5%88%B0%E8%BF%9C%E7%A8%8Bgithub%E4%BB%93%E5%BA%93%E7%9A%84%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[问题今天使用git 添加到远程github仓库的时候提示错误：fatal: remote origin already exists. 解决办法 先删除远程 Git 仓库 1$ git remote rm origin 再添加远程 Git 仓库 1$ git remote add origin 仓库地址]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：垂直水平居中]]></title>
    <url>%2F2020%2F03%2F03%2FCSS%2FCSS%EF%BC%9A%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[基于绝对定位要求元素具有固定的高度和宽度123456789&#123; position:absolute; top:50%; left:50%; margin-top:-20px; margin-left:-20px; height:40px; width:40px;&#125; 局限性：不能自适应，边距大小与padding，box-sizing有关 借助calc()函数 1234567&#123; position:absolute; top:calc(50%-20px); left:calc(50%-20px); height:40px; width:40px;&#125; 不需要在偏移量中把元素尺寸写死123456&#123; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);&#125; 局限性：ie8不支持 基于Flex布局123456&#123; display:flex; justify-content:center;//使子元素水平居中 align-items:center;//使子元素垂直居中 height:40px;&#125; 局限性：ie7/8不兼容 基于table布局12345&#123; display: table-cell; vertical-align: middle;//使子元素垂直居中 text-align: center;//使子元素水平居中&#125; 局限性：需要额外html标记 基于inline-block12345&#123; display: inline-block; vertical-align: middle;//使元素垂直居中 text-align: center;//使元素水平居中&#125; 只有文字1234&#123; line-height: 24px;//使元素垂直居中 text-align: center;//使元素水平居中&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：line-height]]></title>
    <url>%2F2020%2F02%2F27%2FCSS%2FCSS%EF%BC%9Aline-height%2F</url>
    <content type="text"><![CDATA[line-height在应用到一个块级元素时，它定义了该元素中基线之间的最小距离 1234line-height:15px;//行间距为15pxline-height:150%;//行间距=当前的字体尺寸*150%line-height:1.5;//行间距=当前的字体尺寸*1.5line-height:1.5em;//行间距=当前的字体尺寸*1.5（若当前没有设置，继承父元素）]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：圣杯布局和双飞翼布局]]></title>
    <url>%2F2020%2F02%2F27%2FCSS%2FCSS%EF%BC%9A%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[圣杯布局 header和footer占屏幕全部宽度，高度固定 中间的contaier部分是一个三栏布局 left和right宽度固定，middle自适应填满整个区域；高度为三栏中最大的高度 浮动1234567&lt;header class=&quot;header&quot;&gt;header&lt;/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;middle&quot;&gt;middle&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;/div&gt;&lt;footer class=&quot;footer&quot;&gt;footer&lt;/footer&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344.header&#123; height:50px; width:100%; border:1px solid black;&#125;// 中间部分center设置100%撑满// 这样因为浮动的关系，center会占据整个container，左右两块区域被挤下去了.middle&#123; float: left; width: 100%; height:100%; background-color:pink;&#125;// 设置left的 margin-left: -100%;，让left回到上一行最左侧.left &#123; float: left; width: 100px; height: 100%; margin-left: -100%; background: black;&#125;// left回到第一行后，right位于第二行的最左侧// 设置margin-left把right拉回第一行的最右侧.right&#123; float: left; width:100px; height:100%; margin-left: -100px; background-color:black;&#125;// left和right这会把middle给遮住了// 所以这时给外层的container设置 padding，给left和right空出位置.container&#123; height: 300px; padding: 0 100px;&#125;.footer&#123; height:50px; width:100%; border:1px solid black;&#125; flex布局1234567&lt;header class=&quot;header&quot;&gt;header&lt;/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt;middle&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;/div&gt;&lt;footer class=&quot;footer&quot;&gt;footer&lt;/footer&gt; 123456789101112131415161718192021222324252627282930//middle占据除left和right之外的剩余所有空间，并不被遮挡.header&#123; height:50px; width:100%; border:1px solid black;&#125;.container&#123; display: flex; height:300px;&#125;.left&#123; width:100px; height:100%; background-color:black;&#125;.middle&#123; flex:1;//middle占据剩余所有空间 height:100%; background-color:pink;&#125;.right&#123; width:100px; height:100%; background-color:black;&#125;.footer&#123; height:50px; width:100%; border:1px solid black;&#125; 绝对定位以上两种dom结构均可1234567891011121314151617181920212223242526272829303132333435.header&#123; height:50px; width:100%; border:1px solid black;&#125;.container&#123; height:300px; position: relative; padding: 0 100px;&#125;.left&#123; position: absolute; top: 0; left: 0; width:100px; height:100%; background-color:black;&#125;.middle&#123; height:100%; background-color:pink;&#125;.right&#123; position: absolute; top:0; right: 0; width:100px; height:100%; background-color:black;&#125;.footer&#123; height:50px; width:100%; border:1px solid black;&#125; 双飞翼布局双飞翼布局和圣杯布局几乎一样，区别在于处理middle中被遮挡的部分。 圣杯布局是在三栏布局的父容器中设置padding。 双飞翼布局是在middle中再放一个div用来显示内容，为其设置margin。 123456789&lt;header&gt;header&lt;/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;middle&quot;&gt; &lt;div class=&quot;main&quot;&gt;middle&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;/div&gt;&lt;footer&gt;footer&lt;/footer&gt; 1234//使用圣杯布局的浮动和绝对定位时设置，同时把container中的padding去除.main&#123; margin:0 100px;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端SEO（搜索引擎优化）和语义化]]></title>
    <url>%2F2020%2F02%2F23%2F%E5%89%8D%E7%AB%AF%2F%E5%89%8D%E7%AB%AFSEO%EF%BC%88%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96%EF%BC%89%E5%92%8C%E8%AF%AD%E4%B9%89%E5%8C%96%2F</url>
    <content type="text"><![CDATA[合理的title、description、keywords title值强调重点，要靠前，不同页面title不要相同。 description对页面内容高度概括，长度合适，不同页面有所不同。 keywords列举重点关键词即可，不要过分堆砌关键词。 语义化语义化的标签，旨在让标签有自己的含义，就是用合理、正确的标签来展示内容，比如h1~h6定义标题。 优点 易于用户阅读，css样式丢失的时候能让页面呈现清晰的结构。 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。 方便其他设备解析，如盲人阅读器根据语义渲染网页 有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。 常见语义化标签12345678910111213141516171819202122&lt;title&gt;：页面主体内容。&lt;hn&gt;：h1~h6，分级标题，&lt;h1&gt; 与 &lt;title&gt; 协调有利于搜索引擎优化。&lt;ul&gt;：无序列表。&lt;li&gt;：有序列表。&lt;small&gt;：呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权。&lt;strong&gt;：和 em 标签一样，用于强调文本，但它强调的程度更强一些。&lt;em&gt;：将其中的文本表示为强调的内容，表现为斜体。&lt;mark&gt;：使用黄色突出显示部分文本。&lt;figure&gt;：规定独立的流内容（图像、图表、照片、代码等等）（默认有40px左右margin）。&lt;figcaption&gt;：定义 figure 元素的标题，应该被置于 figure 元素的第一个或最后一个子元素的位置。&lt;cite&gt;：表示所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。&lt;blockquoto&gt;：定义块引用，块引用拥有它们自己的空间。&lt;q&gt;：短的引述（跨浏览器问题，尽量避免使用）。&lt;time&gt;：datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。&lt;abbr&gt;：简称或缩写。&lt;dfn&gt;：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。&lt;address&gt;：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）。&lt;del&gt;：移除的内容。&lt;ins&gt;：添加的内容。&lt;code&gt;：标记代码。&lt;meter&gt;：定义已知范围或分数值内的标量测量。（Internet Explorer 不支持 meter 标签）&lt;progress&gt;：定义运行中的进度（进程）。 h5新增语义化标签1234567&lt;header&gt; 定义文档或者文档的部分区域的页眉&lt;nav&gt; 描述一个含有多个超链接的区域&lt;main&gt; 定义文档的主要内容，该内容在文档中应当是独一无二的&lt;article&gt; 表示文档、页面、应用或网站中的独立结构&lt;aside&gt; 表示一个和其余页面内容几乎无关的部分&lt;footer&gt; 定义最近一个章节内容或者根节点元素的页脚&lt;section&gt; 表示文档中的一个区域（或节），比如，内容中的一个专题组。 重要内容的html代码放最前搜索引擎抓取html的顺序是从上到下，保证重要内容一定会被抓取 重要内容不要用js输出爬虫不会执行js获取内容 提高网站速度网站速度也是搜索引擎排序的一个重要指标]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：二进制转十进制]]></title>
    <url>%2F2020%2F02%2F23%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6%2F</url>
    <content type="text"><![CDATA[解法一按权相加1234567function toDecimal(str)&#123; var res = 0; for(var i=str.length-1;i&gt;=0;i--)&#123; res = str[i]===&apos;1&apos; ? Math.pow(2,str.length-1-i) + res : res; &#125; return res;&#125; 123456789function toDecimal(str)&#123; var res = 0; var temp = 1; for(var i=str.length-1;i&gt;=0;i--)&#123; res = str[i]===&apos;1&apos; ? res + temp : res; temp *= 2; &#125; return res;&#125; 解法二parseInt 的第二个参数表示要解析的数字的基数123function toDecimal(str)&#123; return parseInt(str,2);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网：http报文结构]]></title>
    <url>%2F2020%2F02%2F23%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9Ahttp%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[http报文的产生HTTP通信过程包括客户端往服务器端发送请求以及服务器端给客户端返回响应两个过程。在这两个过程中就会产生请求报文和响应报文。 什么是HTTP报文呢？HTTP报文是用于HTTP协议交互的信息，HTTP报文本身是由多行数据构成的字符串文本。客户端的HTTP报文叫做请求报文，服务器端的HTTP报文叫做响应报文。 报文结构 HTTP报文由报文首部和报文主体构成，中间由一个空行分隔。 报文首部是客户端或服务器端需处理的请求或响应的内容及属性， 可以传递额外的重要信息。 报文首部包括请求行和请求头部。 报文主体主要包含应被发送的数据。 通常，不一定有报文主体。 http请求报文一个HTTP请求报文由请求行、请求头部、空行和请求数据4个部分构成。 请求行数据格式由三个部分组成：请求方法、URI、HTTP协议版本，他们之间用空格分隔。12// 该部分位于数据首行，基本格式为：GET /index.html HTTP/1.1 该部分的请求方法字段给出了请求类型，URI给出请求的资源位置(/index.html)。HTTP中的请求类型包括:GET、POST、HEAD、PUT、DELETE。一般常用的为GET和POST方式。最后HTTP协议版本给出HTTP的版本号。 http响应报文HTTP响应报文由状态行（HTTP版本、状态码（数字和原因短语））、响应头部、空行和响应体4个部分构成。 状态行主要给出响应HTTP协议的版本号、响应返回状态码、响应描述，同样是单行显示。格式为：1HTTP/1.1 200 OK 状态码告知从服务器端返回的请求的状态，一般由一个三位数组成,分别以整数1～5开头组成。 报文首部结构 由首部字段名和字段值构成的，中间用冒号“:”分割。 首部字段格式： 首部字段名:字段值。 类型 通用首部字段：请求报文和响应报文两方都会使用的首部。 请求首部字段：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。 响应首部字段：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。 实体首部字段：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等和实体有关的信息。]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行内元素、块元素、行内块元素]]></title>
    <url>%2F2020%2F02%2F22%2F%E5%89%8D%E7%AB%AF%2F%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E3%80%81%E5%9D%97%E5%85%83%E7%B4%A0%E3%80%81%E8%A1%8C%E5%86%85%E5%9D%97%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[行内元素 设置宽高无效。 margin水平方向有效，垂直方向无效。 padding水平方向有效，垂直方向在显示上有效果即会增大元素的内容范围，但对其他元素无影响。 不会自动进行换行。 123456789101112131415161718常见行内元素a - 锚点b - 粗体(不推荐)big - 大字体br - 换行em - 强调font - 字体设定(不推荐)i - 斜体img - 图片input - 输入框label - 表格标签select - 项目选择small - 小字体文本span - 常用内联容器，定义文本内区块strong - 粗体强调textarea - 多行文本输入框u - 下划线var - 定义变量 块元素 能够识别宽高。 margin和padding的上下左右均对其有效。 可以自动换行。 多个块状元素标签写在一起，默认排列方式为从上至下。 12345678910111213141516171819常见块元素address - 地址enter - 居中对齐块dir - 目录列表div - 常用块级容器，也是css layout的主要标签dl - 定义列表form - 交互表单h1 - 大标题h2 - 副标题h3 - 3级标题h4 - 4级标题h5 - 5级标题h6 - 6级标题hr - 水平分隔线menu - 菜单列表ol - 排序表单p - 段落table - 表格ul - 非排序列表（无序列表） 可变元素可变元素由上下文语境来决定是块元素还是内联元素 1234567button - 按钮del - 删除文本iframe - inline frameins - 插入的文本map - 图片区块（map）object - object对象script - 客户端脚本 行内块元素 不自动换行 能够识别宽高 默认排列方式为从左到右 三者转换使用display属性能够将三者任意转换： display:inline;转换为行内元素 display:block;转换为块状元素 display:inline-block;转换为行内块状元素]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：选择器]]></title>
    <url>%2F2020%2F02%2F22%2FCSS%2FCSS%EF%BC%9A%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[选择器优先级从高到低 在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。 内联样式，作为style属性写在元素内的样式 id选择器 class带伪类，如 .input:first-child 标签[指定属性]，如 input[type=’file’] 类选择器 标签带伪类，如input:first-child，与5、6按css的顺序排优先级 标签选择器 通配符选择器 属性选择器属性选择器支持正则匹配 选择器 含义 tag[attr] 匹配具有attr属性的所有元素，不考虑它的值 tag[attr=’val’] 匹配attr属性值等于val的所有元素 tag[attr^=’val’] 匹配attr属性值以指定的值val开头的所有元素 tag[attr$=’val’] 匹配attr属性值以指定的值val结尾的所有元素 tag[attr*=’val’] 匹配attr属性值中包含指定的值val的所有元素 tag为标签名 attr为属性 val为属性值 选择器解析 CSS选择器时==从右往左解析==的 尽量少使用不必要的层级关系]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：各种单位]]></title>
    <url>%2F2020%2F02%2F21%2FCSS%2FCSS%EF%BC%9A%E5%90%84%E7%A7%8D%E5%8D%95%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[% padding和margin的%垂直水平方向都是基于父元素的宽度计算px（pixel，像素）是一个虚拟长度单位，是计算机系统的数字化图像长度单位。物理像素（px）设备能控制显示的最小单位逻辑像素（px）又称css像素，浏览器使用的抽象单位，而不是实际存在的设备独立像素（dip或dp）独立于设备的用于逻辑上衡量像素的单位，包括了CSS像素设备像素缩放比（dpr） dpr=物理像素/逻辑像素 1px = (dpr)^2 * dp dpr=ppi/160屏幕像素密度（PPI） 每英寸内有多少个设备像素点（物理像素） PPI越高，像素数越高，图像越清晰 屏幕分辨率（XxY）指屏幕上垂直有x个物理像素，水平有y个物理像素。 屏幕尺寸（x in）指屏幕对角线的长度有x英寸 em（相对长度单位） 子元素字体大小的em是相对于父元素字体大小，如果自身定义了font-size按自身来计算。 元素的width/height/padding/margin用em的话是相对于自身的font-size。 最多取到小数点后三位。 rem（根em） 相对于html元素上字体的大小。 1rem等于html元素上字体设置的大小。 vw、vh 1vw等于视窗宽度的1%。 1vh等于视窗高度的1%。 单位 含义 vw 相对于视图窗口的宽度，视窗宽度为100vw vh 相对于视图窗口的高度，视窗高度为100vh vmin vw和vh中的较小值 vmax vw和vh中的较大值]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：隐藏元素]]></title>
    <url>%2F2020%2F02%2F20%2FCSS%2FCSS%EF%BC%9A%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[display:none visibility: hidden opacity: 0 空间占据 display隐藏后不占据空间，会产生回流和重绘 其余两个虽隐藏，但仍占据空间，只会引起重绘 子元素继承 display不会被继承，父元素都不存在了，子元素自然也不会显示 visibility会被子元素继承，可以通过设置子元素visibility为visible使其显示 opacity也会被子元素继承，但不能通过设置子元素opacity为1使其显示 事件绑定 display隐藏后已经不存在了，肯定也无法触发事件 其余两个虽隐藏，但仍存在，可以触发事件 过渡动画transition对display和visibility无效，对opacity有效]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6：promise]]></title>
    <url>%2F2020%2F02%2F20%2FES6%2FES6%EF%BC%9Apromise%2F</url>
    <content type="text"><![CDATA[一句话概述什么是promisePromise对象用于异步操作，它表示一个尚未完成且预计在未来完成的异步操作。 为什么用promise用于异步操作，除了promise还可以用异步回调解决异步操作。 那为什么有异步回调还要promise，promise可以多重链式调用，可以避免层层嵌套回调。可以利用then进行「链式回调」，将异步操作以同步操作的流程表示出来。 注意 Promise在生命周期内有三种状态，分别是pending、fulfilled 和 rejected。 状态改变只能是pending-&gt;fulfilled(成功)，或者pending-&gt;rejected(失败)。而且状态一旦改变，就不能再次改变。 Promise中调用resolve或reject并不会终结 Promise 的参数函数的执行。 Promise的构造函数中代码是同步执行的，但是then方法是异步执行的，then方法需要等到resolve函数执行时才得到执行。 reject 和 catch 的区别 在resolve中发生异常的话，在reject中是捕获不到这个异常的。.then中产生的异常能在.catch中捕获 如果在then中抛错，而没有对错误进行处理（即catch），那么会一直保持reject状态，直到catch了错误。且catch之前的函数都不会执行。 每次调用then都会返回一个新创建的promise对象，而then内部只是返回的数据。 在异步回调中抛错，不会被catch到。 promise状态变为resolve或reject，就凝固了，不会再改变。 Promise一旦执行了resolve函数后，就不会再执行reject和其他的resolve函数了。一旦Promise执行了reject函数，将会被catch函数捕获，执行catch中的代码。 如何处理异步 promise 回调函数 12345678function f1(callback)&#123; setTimeout(function () &#123; // f1的任务代码 callback(); &#125;, 1000);&#125;// 执行f1(f2) 发布订阅 事件监听 async/await 一个简单的promise对象12345new Promise(test).then(function (result) &#123; console.log(&apos;成功：&apos; + result);&#125;).catch(function (reason) &#123; console.log(&apos;失败：&apos; + reason);&#125;);]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：BFC]]></title>
    <url>%2F2020%2F02%2F17%2FCSS%2FCSS%EF%BC%9ABFC%2F</url>
    <content type="text"><![CDATA[BFC定义块级格式化上下文，是指一个独立的块级渲染区域。该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。 BFC生成满足下列css声明之一的元素便会生成BFC 根元素或其它包含它的元素 float的值不为none； overflow的值不为visible； position的值不为static； display的值为inline-block、table-cell、table-caption； flex boxes (元素的display: flex或inline-flex)； BFC布局规则 内部的元素会在垂直方向一个接一个地排列，可以理解为是BFC中的一个常规流 元素垂直方向的距离由margin决定，即属于同一个BFC的两个相邻盒子的margin可能会发生重叠 每个元素的左外边距与包含块的左边界相接触(从左往右，否则相反)，即使存在浮动也是如此，这说明BFC中的子元素不会超出它的包含块 BFC的区域不会与float元素区域重叠 计算BFC的高度时，浮动子元素也参与计算 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然 位于不同BFC下的相邻元素之间不会发生margin重叠 BFC的应用解决margin塌陷和margin合并问题 margin塌陷为父子元素都设置margin，只取最大的一个。解决方法为父元素触发bfc，使其遵循bgc渲染规则。 margin合并的原理为它们处于同一个BFC中，符合“属于同一个BFC的两个相邻元素的margin会发生重叠”的规则。解决方法为在其中一个元素外面包裹一层容器，并触发容器生成一个BFC（overflow：hidden），使两个元素处于不同的BFC。 解决高度塌陷问题当我们不给父节点设置高度，子节点设置浮动的时候，会发生高度塌陷，这个时候我们就要清除浮动。 给父元素设置overflow：hidden可以清除子元素的浮动是应用了BFC的原理：给父元素设置overflow：hidden触发了BFC，形成一个独立的渲染区域，所以内部的元素就不会影响外面的布局，BFC把浮动的子元素的高度当作自己的高度去处理溢出，从外面看起来就是清除了浮动 解决侵占浮动元素的问题当一个元素浮动，另一个元素不浮动时，浮动元素因为脱离文档流，就会盖在不浮动的元素上。 解决方法：不浮动的元素也设为浮动，或者添加overflow：hidden 原理：为不浮动的元素建立BFC环境，BFC不与float box重叠。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：margin塌陷和margin合并]]></title>
    <url>%2F2020%2F02%2F17%2FCSS%2FCSS%EF%BC%9Amargin%E5%A1%8C%E9%99%B7%E5%92%8Cmargin%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[margin塌陷 标准文档流中，垂直方向的margin不叠加，以较大的为准。即父子嵌套元素在垂直方向的margin,父子元素是结合在一起的,他们两个的margin会取其中最大的值。 正常情况下,父级元素应该相对浏览器进行定位,子级相对父级定位。 但由于margin的塌陷,父级相对浏览器定位.而子级没有相对父级定位,子级相对父级,就像坍塌了一样。 原理是他们处于同一个BFC中。 体现 红色方块margin-top为100px 现在给里面的小方块设置margin-top:100px，发现两个方块位置没动 而当给里面的小方块设置margin-top:150px，小方块带着大方块往下移动了50px（100和150取了150，里面的小方块依然紧贴大方块最上面） 解决 给父元素设置边框或内边距(不建议使用) 给父元素添加某些条件触发bfc(块级格式上下文),改变父级的渲染规则 position:absolute/fixed display:inline-block/table float:left/right overflow:hidden 给子元素的前面加一个兄弟元素。 margin合并 标准文档流中，两个兄弟结构的元素在垂直方向上的margin不叠加，是合并的，以较大的为准。 原因是他们处于同一个BFC中。 解决margin塌陷的原理是使两个元素处于不同的bfc中，不同的bfc是不会发生margin塌陷的 解决 给其中一个元素添加盒子div并触发bfc 给两个元素都添加盒子div并触发bfc position:absolute/fixed display:inline-block; float:left/right overflow:hidden]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSocket]]></title>
    <url>%2F2020%2F02%2F15%2F%E5%89%8D%E7%AB%AF%2FWebSocket%2F</url>
    <content type="text"><![CDATA[长连接和短连接长连接是存在于网络层的一种连接状态，而实现它则需要在传输层进行开发，因为它是基于对真实数据的收发，需要在底层进行管控。 http http1.0不支持长连接，http1.1支持长连接 http1.x是文本协议，http2.0是二进制协议 HTTP作为应用层协议，其实它的生命周期在服务器返回结果时就已经结束了，而所谓的支持长连接，其实是基于’Keep-Alive’请求头所约定，从而向下进行长连接发起的一种机制。该长连接依然是基于TCP的。 短连接所谓短连接，即连接只保持在数据传输过程，请求发起，连接建立，数据返回，连接关闭。它适用于一些实时数据请求，配合轮询来进行新旧数据的更替。 长连接长连接便是在连接发起后，在请求关闭连接前客户端与服务端都保持连接，实质是保持这个通信管道，之后便可以对其进行复用。它适用于涉及消息推送，请求频繁的场景（直播，流媒体）。连接建立后，在该连接下的所有请求都可以重用这个长连接管道，避免了频繁了连接请求，提升了效率。 轮询 所谓轮询，即是浏览器通过JavaScript启动一个定时器，然后以固定的间隔给服务器发请求，询问服务器有没有新消息这样一个机制。 然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。 只要有请求的的地方，都可以实现轮询，譬如各种事件驱动模型。它的长短是在于某次请求的返回周期。 短轮询短轮询指的是在循环周期内，不断发起请求，每一次请求都立即返回结果，根据新旧数据对比决定是否使用这个结果。 长轮询而长轮询即是在请求的过程中，若是服务器端数据并没有更新，那么则将这个连接挂起，直到服务器推送新的数据，再返回，然后再进入循环周期。 由上可以看到，长短轮询的理想实现都应当基于长连接，否则若是循环周期太短，那么服务器的荷载会相当重；当然，即便是在长连接下，访问人数过多，长短轮询都有可能造成服务器的瞬时访问量庞大，这就需要一些相应的优化实践了。 websocket WebSocket是HTML5新增的一种在单个 TCP 连接上进行全双工通讯的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。 在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 为什么http不能实现这是因为HTTP协议是一个请求－响应协议，请求必须先由浏览器发给服务器，服务器才能响应这个请求，再把数据发送给浏览器。换句话说，浏览器不主动请求，服务器是没法主动发数据给浏览器的。 用轮询是可以实现的，但这个机制的缺点一是实时性不够，二是频繁的请求会给服务器带来极大的压力。 websocket实现WebSocket并不是全新的协议，而是利用了HTTP协议来建立连接。 实际上HTTP协议是建立在TCP协议之上的，TCP协议本身就实现了全双工通信，但是HTTP协议的请求－应答机制限制了全双工通信。WebSocket连接建立以后，其实只是简单规定了一下：接下来，咱们通信就不使用HTTP协议了，直接互相发数据吧。 创建websocket连接首先，WebSocket连接必须由浏览器发起，因为请求协议是一个标准的HTTP请求，格式如下： 1234567GET ws://localhost:3000/ws/chat HTTP/1.1Host: localhostUpgrade: websocketConnection: UpgradeOrigin: http://localhost:3000Sec-WebSocket-Key: client-random-stringSec-WebSocket-Version: 13 该请求和普通的HTTP请求有几点不同： GET请求的地址不是类似/path/，而是以ws://开头的地址； 请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接； Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据； Sec-WebSocket-Version指定了WebSocket的协议版本。 一个WebSocket连接就建立成功，浏览器和服务器就可以随时主动发送消息给对方。消息有两种，一种是文本，一种是二进制数据。通常，我们可以发送JSON格式的文本。 浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。 安全的websocket安全的WebSocket连接机制和HTTPS类似。首先，浏览器用wss://xxx创建WebSocket连接时，会先通过HTTPS创建安全的连接，然后，该HTTPS连接升级为WebSocket连接，底层通信走的仍然是安全的SSL/TLS协议。 浏览器很显然，要支持WebSocket通信，浏览器得支持这个协议，这样才能发出ws://xxx的请求。目前，支持WebSocket的主流浏览器如下： Chrome Firefox IE &gt;= 10 Sarafi &gt;= 6 Android &gt;= 4.4 iOS &gt;= 8 服务器由于WebSocket是一个协议，服务器具体怎么实现，取决于所用编程语言和框架本身。Node.js本身支持的协议包括TCP协议和HTTP协议，要支持WebSocket协议，需要对Node.js提供的HTTPServer做额外的开发。已经有若干基于Node.js的稳定可靠的WebSocket实现，我们直接用npm安装使用即可。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回流（Reflow）和重绘（Repaint）]]></title>
    <url>%2F2020%2F02%2F15%2F%E5%89%8D%E7%AB%AF%2F%E5%9B%9E%E6%B5%81%EF%BC%88Reflow%EF%BC%89%E5%92%8C%E9%87%8D%E7%BB%98%EF%BC%88Repaint%EF%BC%89%2F</url>
    <content type="text"><![CDATA[浏览器渲染解析HTML，生成DOM树，解析CSS，生成CSSOM树。将DOM树和CSSOM树结合，生成渲染树（Render Tree）。 回流当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流。 每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。 重绘当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。 回流必定触发重绘，而重绘不一定触发回流。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面渲染过程（输入一个url）]]></title>
    <url>%2F2020%2F02%2F13%2F%E5%89%8D%E7%AB%AF%2F%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%EF%BC%88%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAurl%EF%BC%89%2F</url>
    <content type="text"><![CDATA[输入一个url到网页呈现 输入网址 发送到DNS服务器，并获取域名对应的web服务器对应的ip地址。 与web服务器建立TCP连接 浏览器向web服务器发送http请求 web服务器响应请求，并返回指定url数据 浏览器下载web服务器返回的数据。 解析 HTML 文件,构建 DOM 树,同时浏览器主进程负责下载 CSS 文件 CSS 文件下载完成,解析 CSS 文件生成cssom树，调用JS执行引擎执行JS代码，然后将DOM树和CSSOM树结合生成渲染树。 根据渲染树来布局，计算每个节点的布局信息，将各个节点绘制到屏幕上来渲染页面，直至显示完成。 若dom树生成过程中遇到script标签，则暂停，执行js直至完成再继续生成。 若执行js时需要操作cssom，还得等css加载执行完生成cssom才能继续执行。 因此，css资源要先于js资源加载，js放于页面底部，尽量少影响dom树的生成 各种拓展页面加载白屏原因： 在弱网络下，网络延迟，JS加载延迟，会阻塞页面。 客户端存在bug，缓存模块错乱，不缓存js等后来挂起的文件，以及乱缓存index.html。 如果页面完全一片空白。极有可能是后端出现问题，后端配置无错误输出，并且服务状态500，这个时候页面就是一片空白。如果是前端导致的，那么极有可能是单页应用异常，比如到了一个没有设置的新的页面。1、打开能看到源码和request、response的浏览器，如chrome，查看源码输出2、如果是后端问题，那么后端查看accesslog、程序日志，看看是否有问题3、如果是前端问题，那么根据给出的js异常之类的排查 统计白屏数量：监听某个主div的变化，在规定时间内该DIV没有变化，那就可以进行白屏统计了。 监控白屏时间：监听某个主div的变化，直至页面渲染。 优化：尽量减少文件夹的嵌套，文件名不要过长。 一个网站很卡找原因首先用3g网络测试一下：如果卡就是http请求数据可能过大。可以合并JS脚本和CSS文件，css精灵图，对HTTP传输进行gzip压缩。css放顶部，javascript放底部。 可能服务端出问题：比如用户访问量大，并发量大。mysql没有优化好，造成死锁。 可以用CDN加速把数据放在离用户更近的位置。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：多层数组转化为一层]]></title>
    <url>%2F2020%2F01%2F14%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%A4%9A%E5%B1%82%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%B8%80%E5%B1%82%2F</url>
    <content type="text"><![CDATA[题目给定一个数组，将多层数组转化为一层。 注意，数组元素不一定是数字，有可能为对象或字符串。 测试用例121. [&apos;1&apos;,[2,3],-1] // [&apos;1&apos;,2,3,-1]2. [&apos;1&apos;,[2,3],&#123;a:-1&#125;] // [&apos;1&apos;,2,3,&#123;a:-1&#125;] 解法思路 遍历数组，取出元素放入新数组，若元素为数组则递归取出 算法123456789101112131415/** * @param &#123;array&#125; arr * @param &#123;array&#125; res * @return &#123;array&#125; */var flatten = function (arr, res) &#123; for(let i in arr) &#123; if(arr[i] instanceof Array) &#123; test(arr[i],res) &#125; else &#123; res.push(arr[i]); &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode：验证回文串]]></title>
    <url>%2F2019%2F12%2F19%2F%E7%AE%97%E6%B3%95%2FLeetCode%EF%BC%9A%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 测试用例121. &quot;A man, a plan, a canal: Panama&quot; // true2. &quot;race a car&quot; // false 解法思路 先判空字符串 对非空字符串，先用正则把除字母和数字之外的字符去除，再全部转换为小写字母 把字符串分割为数组，翻转，再拼接为字符串，与原字符串进行对比 算法1234567891011121314/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isPalindrome = function(s) &#123; if(s === &apos;&apos;) &#123; return true; &#125; s = s.replace(/[^0-9a-zA-Z]/g, &apos;&apos;).toLowerCase(); if(s === s.split(&apos;&apos;).reverse().join(&apos;&apos;))&#123; return true; &#125; return false;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode：有效的括号]]></title>
    <url>%2F2019%2F12%2F06%2F%E7%AE%97%E6%B3%95%2FLeetCode%EF%BC%9A%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[题目给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 测试用例123451. &quot;()&quot; // true2. &quot;()[]&#123;&#125;&quot; // true3. &quot;(]&quot; // false4. &quot;([)]&quot; // false5. &quot;&#123;[]&#125;&quot; // true 解法一思路 使用字符串的replace方法进行匹配替换，直到全部匹配成功，字符串长度为0，返回true 或直到没有相匹配的项，匹配前的字符串与匹配后的字符串相等，则返回false 算法12345678910111213141516171819/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isValid = function(s) &#123; if(s.length === 0) &#123; return true; &#125; while(s.length !== 0) &#123; var temp = s; s = s.replace(&apos;()&apos;,&apos;&apos;); s = s.replace(&apos;[]&apos;,&apos;&apos;); s = s.replace(&apos;&#123;&#125;&apos;,&apos;&apos;); if(s === temp) &#123; return false; &#125; &#125; return true;&#125;; 解法二思路 构造哈希表，遍历字符串 对于左括号，把相应的右括号放进栈里 对于右括号，若与栈顶匹配，则把栈顶去除；若是不匹配，则往栈顶添加undefined，为了防止开头就是右括号的情况 算法1234567891011121314151617181920/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isValid = function(s) &#123; var map = &#123; &apos;(&apos;: &apos;)&apos;, &apos;[&apos;: &apos;]&apos;, &apos;&#123;&apos;: &apos;&#125;&apos; &#125; var stack = []; for(let i in s) &#123; if(s[i] !== stack[stack.length-1]) &#123; stack.push(map[s[i]]) &#125; else &#123; stack.pop(); &#125; &#125; return stack.length === 0 ? true : false;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode：罗马数字转整数]]></title>
    <url>%2F2019%2F12%2F06%2F%E7%AE%97%E6%B3%95%2FLeetCode%EF%BC%9A%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 测试用例123451. &quot;III&quot; // 32. &quot;IV&quot; // 43. &quot;IX&quot; // 94. &quot;LVIII&quot; // 58 解释: L = 50, V= 5, III = 35. &quot;MCMXCIV&quot; // 1994 解释:M = 1000, CM = 900, XC = 90, IV = 4 解法思路 根据题目中的所有情况写出哈希表 先匹配特殊情况，由于是匹配两个字符串，所以应考虑到最后一个字符串没有下一个的情况，所以先判断是否到最后了 若匹配，直接加，并使指针跳过这两个字符串 若不匹配，则直接得出该字符串的值，指针正常指向下一个 算法12345678910111213141516171819202122232425262728293031/** * @param &#123;string&#125; s * @return &#123;number&#125; */var romanToInt = function(s) &#123; var map = &#123; I: 1, IV: 4, V: 5, IX: 9, X: 10, XL: 40, L: 50, XC: 90, C: 100, CD: 400, D: 500, CM: 900, M: 1000 &#125; var res = 0; for(let i=0;i&lt;s.length;i++) &#123; if(i+1 &lt; s.length &amp;&amp; map[s.substr(i,2)]) &#123; res += map[s.substr(i,2)]; i++; &#125; else &#123; res += map[s.substr(i,1)]; &#125; &#125; return res;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：等宽的三栏布局]]></title>
    <url>%2F2019%2F12%2F05%2FCSS%2FCSS%EF%BC%9A%E7%AD%89%E5%AE%BD%E7%9A%84%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[12345&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt; float1234567891011121314151617.box &#123; width: 100%; height: 200px; background: black;&#125;.left, .center, .right &#123; width: 33.33%; height: 100%; float: left; background: #FFA54F;&#125;.center &#123; background: #FFA500;&#125;.right&#123; background: #FFA07A;&#125; flex1234567891011121314151617.box &#123; width: 100%; height: 200px; background: black; display: flex;&#125;.left, .center, .right &#123; width: 33.33%; height: 100%; background: #FFA54F;&#125;.center &#123; background: #FFA500;&#125;.right&#123; background: #FFA07A;&#125; table123456789101112131415161718.box &#123; width: 100%; height: 200px; background: black; display: table;&#125;.left, .center, .right &#123; display: table-cell; width: 33.33%; height: 100%; background: #FFA54F;&#125;.center &#123; background: #FFA500;&#125;.right&#123; background: #FFA07A;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网：cdn]]></title>
    <url>%2F2019%2F11%2F16%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9Acdn%2F</url>
    <content type="text"><![CDATA[是什么内容分发网络。使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。 cdn缓存用户浏览器和服务器端之间加入cdn 用户在浏览网站的时候，向服务器请求到资源后，cdn会在本地保存网站中的图片或者js、css等其他文件的副本，通过http响应头中的cache-control字段设置数据缓存时间，这样用户再次访问该网站的时候，浏览器就不用再下载全部的文件，减少了下载量意味着提高了页面加载的速度。 再次浏览网站时，客户端浏览器会先向CDN边缘节点发起请求，CDN边缘节点会检测用户请求数据的缓存是否过期，如果没有过期，则直接响应用户请求，此时一个http请求结束；如果数据已经过期，那么CDN还需要向源站发出回源请求,来拉取最新的数据。]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git：git fetch和git pull]]></title>
    <url>%2F2019%2F11%2F13%2FGit%2FGit%EF%BC%9Agit%20fetch%E5%92%8Cgit%20pull%2F</url>
    <content type="text"><![CDATA[git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。 git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git：关于回退版本的一些小技巧]]></title>
    <url>%2F2019%2F08%2F27%2FGit%2FGit%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%9B%9E%E9%80%80%E7%89%88%E6%9C%AC%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[先通过 git log 查看某次提交的id 使用git reset –hard [id] 回退到某一次提交 若不想保留原来的提交记录，可把原来的分支删除 1git push origin --delete [branchName] 再把本地的修改提交到新的分支 版本回退仅仅是本地版本回退]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：position]]></title>
    <url>%2F2019%2F08%2F19%2FCSS%2FCSS%EF%BC%9Aposition%2F</url>
    <content type="text"><![CDATA[position:static没有定位，元素出现在正常的文档流中，忽略left、right、top、bottom和z-index。 position:fixed相对于浏览器窗口定位，即浏览器窗口滚动也不会影响元素位置，元素的位置与文档流无关，因此不占据空间，可能与其他元素发生重叠。 一定要设置宽度 position:relative 相对于元素自身正常位置定位，元素在正常的文档流中占位。 当设置margin或padding属性时，该对象在标准文档流中的占位空间也随之改变。 position:absolute 元素绝对定位，相对于static定位以外的第一个父元素，若无符合要求的父元素则相对于body，元素脱离文档流。 必须指定left、right、top、bottom中的至少一个，否则left，top值与原文档流位置一致，即跟当它static时的位置一样，margin和padding仍能影响其的位置，但脱离文档流，不占据位置，和其他元素形成折叠。 如果top、bottom都未指定，则其顶端将与原文档流位置一致，即垂直保持位置不变。 绝对定位对象在可视区域之外会导致滚动条出现，相对定位则不会 绝对定位对象头部超过可视区域会被裁掉。 position:inherit规定应该从父元素继承 position 属性的值。 z-index 如果两个同级元素的此属性具有同样的值，那么将依据它们在HTML文档中流的顺序层叠，写在后面的将会覆盖前面的。 需要注意的是，父子关系是无法用z-index来设定上下关系的，一定是子级在上父级在下。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些调试小技巧]]></title>
    <url>%2F2019%2F07%2F29%2F%E5%89%8D%E7%AB%AF%2F%E4%B8%80%E4%BA%9B%E8%B0%83%E8%AF%95%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[一些常用的快捷键 快捷键 功能 ctrl + o 搜索文件 ctrl + shift + F 在所有文件中搜索特定的文字 ctrl + shift + o 在某个文件中搜索特定的文字 ctrl + G 跳转到某一行 ctrl + L 清除控制台的信息 ctrl + [ / ctrl + ] 标签切换 ctrl + shift + c 审查元素 shift + Enter / sources -&gt; snippets 在控制台编写多行代码 选中，H 显示/隐藏元素 一些常用的功能 通过js代码来设置断点：debugger，或者直接在sources中打断点，查看堆栈，了解函数调用情况 elements的event listeners中可以查看元素事件监听器 选中元素，右击Break on.. -&gt; Attributes Modifications，元素改变时启动断点 开发者工具打开的情况下右击chrome的刷新按钮，可清除缓存并硬重载]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：模块化]]></title>
    <url>%2F2019%2F05%2F30%2FCSS%2FCSS%EF%BC%9A%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[文件结构常见文件结构一个项目的CSS最基本结构通常是下面这样的： base.css common.css pages.css 复杂一点的项目可能是这样分： base.css header.css footer.css sidebar.css forms.css icons.css buttons.css dropdown.css modals.css layout.css index.css user.css admin.css pages.css 如果后期不打算合并CSS的，建议尽可能减少 CSS 文件的数量。 SMACSSSMACSS 的全称叫 Scalable and Modular Architecture for CSS。即可扩展和模块化的CSS架构。 SMACSS将样式分成5种类型：Base，Layout，Module，State，Theme Base: 基础样式表，定义了基本的样式，我们平时写CSS比如reset.css就是属于基础样式表，另外我认为清除浮动，一些动画也可以归类为基础样式。 Layout: 布局样式，用于实现网页的基本布局，搭起整个网页的基本骨架。 Module: 网页中不同的区域有这个不同的功能，这些功能是相对独立的，我们可以称其为模块。模块是独立的，可重用的组件，它们不依赖于布局组件，可以安全的删除修改而不影响其他模块。 State: 状态样式，通常和js一起配合使用，表示某个组件或功能不同的状态，比如菜单选中状态，按钮不可用状态等。 Theme: 主题皮肤，对于可更换皮肤的站点来说，这个是很有必要的，分离了结构和皮肤，根据不同的皮肤应用不同的样式文件。 css选择器命名规则它的每一条规则都是全局的，在 CSS 预处理出现之前，这很容易造成命名上的冲突。 当涉及到多人维护同一段 CSS 代码时，命名的意义表达，也会影响到维护效率。 使用独一无二的规则。命名唯一。 使用简短的命名。 嵌套层级不宜过深，建议控制在3层以内。 BEMBEM是Block，Element，Modifier的缩写。是比较流行的一种 CSS 命名方式。 Block：在BEM的理论中，一个网页是由block组成的，比如头部是个block，内容是block，logo也是block，一个block可能由几个子block组成。 Element：element是block的一部分，具有某种功能，element依赖于block，比如在logo中，img是logo的一个element，在菜单中，菜单项是菜单的一个element Modifier：modifier是用来修饰block或者element的，它表示block或者element在外观或行为上的改变 123456789命名规则如下：.block &#123;&#125;.block__element &#123;&#125;.block--modifier &#123;&#125;例如：.login &#123;&#125;.login__btn &#123;&#125;.login__btn--reset &#123;&#125;.login__btn--confirm &#123;&#125; 下划线（__）被用来区分元素，而用连字符(–)是用来修饰元素的。 SUITSuit起源于BEM，但是它对组件名使用驼峰式和连字号把组件从他们的修饰和子孙后代中区分出来.]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器兼容问题]]></title>
    <url>%2F2019%2F04%2F25%2F%E5%89%8D%E7%AB%AF%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[css不同浏览器的标签默认的margin和padding不同 12345//解决*&#123; padding:0; margin:0;&#125; 对于一些新特性，低版本浏览器不兼容，可以用渐进增强或优雅降级。 js阻止冒泡12345678function canclebubble(event)&#123; var event = event||window.event; //兼容火狐 if(event.stopPropagation)&#123; event.stopPropagation(); //标准浏览器 &#125;else&#123; event.cancaleBubble==true; //老ie &#125; &#125; 取消默认事件12345678function stopevent(event)&#123; var event = event||window.event; //兼容火狐 if(event.preventDefault)&#123; event.preventDefault(); //标准浏览器 &#125;else&#123; event.returnValue==false; //老ie &#125; &#125; 注意 event代表事件的状态，例如触发event对象的元素、鼠标的位置及状态、按下的键等等； event对象只在事件发生的过程中才有效。 firefox里的event跟IE里的不同，IE里的是全局变量，随时可用；firefox里的要用参数引导才能用，是运行时的临时变量。 在IE/Opera中是window.event，在Firefox中是event；而事件的对象，在IE中是window.event.srcElement，在Firefox中是event.target，Opera中两者都可用。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渐进增强和优雅降级]]></title>
    <url>%2F2019%2F04%2F25%2F%E5%89%8D%E7%AB%AF%2F%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E5%92%8C%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[渐进增强针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。123456.transition&#123; -webkit-transition: all .5s; -moz-transition: all .5s; -o-transition: all .5s; transition: all .5s; &#125; 优雅降级一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。123456.transition&#123; transition: all .5s; -o-transition: all .5s; -moz-transition: all .5s; -webkit-transition: all .5s;&#125; 区别 渐进增强观点认为应该关注于内容本身。 优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：如何找出单链表中的倒数第k个元素]]></title>
    <url>%2F2019%2F04%2F25%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E6%89%BE%E5%87%BA%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[首先遍历一遍单链表，求出整个单链表的长度n，然后将倒数第k个，转换为正数第n-k个，接下来遍历一次就可以得到结果。 优化：设置两个指针p1和p2，p1在p2前，两者相差k-1个节点，当p1指向null时，p2刚好指向目标元素。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构：树的深度遍历和广度遍历]]></title>
    <url>%2F2019%2F04%2F22%2F%E5%85%B6%E4%BB%96%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[普通树深度遍历先访问根结点，然后遍历左子树接着是遍历右子树。利用堆栈的先进后出。 广度遍历从根开始访问,按照根节点左右顺序访问.每次把同层节点左右孩子访问完毕.再访问下一层，所以用队列的先进先出实现。 二叉树前序遍历根 左 右 中序遍历左 根 右 后序遍历左 右 根]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网：DNS查询过程]]></title>
    <url>%2F2019%2F04%2F22%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9ADNS%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[迭代+递归 在DNS解析器缓存中查找某主机的ip地址 向其本地域名服务器进行递归查找。 本地域名服务器查不到，就向根域名服务器进行迭代查询。 根域名服务器告诉本地域名服务器，下一步该向顶级域名服务器查找。 本地域名服务器向顶级域名服务器查找。 顶级域名服务器告诉本地域名服务器，下一步该向权限域名服务器查找。 权限域名服务器返回目标主机的ip地址。 本地域名服务器就把ip地址告诉目标主机。]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：盒模型]]></title>
    <url>%2F2019%2F04%2F22%2FCSS%2FCSS%EF%BC%9A%E7%9B%92%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[标准模型12盒模型宽高 = margin + border + padding + content元素宽高（元素占据的位置） = content IE盒模型12盒模型宽高 = margin + 元素宽高元素宽高（元素占据的位置） = border + padding + content 修改盒模型（box-sizing）box-sizing content-box：默认属性，标准盒模型 border-box：使元素宽高包括padding和border，内容区的实际宽度会是元素宽高减去border + padding的计算值。（即IE盒模型）]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题（一）]]></title>
    <url>%2F2019%2F04%2F21%2F%E7%AE%97%E6%B3%95%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 123456789101112131415var reverse = function(x) &#123; var arr = x.toString().split(&apos;&apos;); if(arr[0]==&apos;-&apos;)&#123; var temp = arr.slice(1,arr.length); temp.reverse().unshift(&quot;-&quot;); x = parseInt(temp.join(&apos;&apos;)); &#125;else&#123; x = parseInt(arr.reverse().join(&apos;&apos;)); &#125; if(x&gt;=-Math.pow(2,31)&amp;&amp;x&lt;=Math.pow(2,31))&#123; return x; &#125;else&#123; return 0; &#125;&#125;; 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。 123456789101112131415161718192021var longestCommonPrefix = function(strs) &#123; var str=&quot;&quot;; if(strs.length == 1)&#123; str = strs[0]; &#125;else if(strs.length &gt;= 2)&#123; for(var i=1;i&lt;=Math.min(strs[0].length,strs[1].length);i++)&#123; if(strs[0].slice(0,i)==strs[1].slice(0,i))&#123; str = strs[0].slice(0,i); continue; &#125;else&#123; break; &#125; &#125; for(var j=2;j&lt;strs.length;j++)&#123; while(str!=&quot;&quot;&amp;&amp;strs[j].substr(0,str.length)!=str)&#123; str = str.slice(0,str.length-1); &#125; &#125; &#125; return str;&#125;; 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。即先开的后闭合。 123&quot;([)]&quot; //false&quot;&#123;[]&#125;&quot; //true&quot;&quot; //true 注意空字符串可被认为是有效字符串。 123456789101112131415161718var isValid = function(s) &#123; var temp = []; for(var i in s)&#123; if(s[i]==&quot;(&quot;)&#123; temp.push(&quot;)&quot;); &#125;else if(s[i]==&quot;[&quot;)&#123; temp.push(&quot;]&quot;); &#125;else if(s[i]==&quot;&#123;&quot;)&#123; temp.push(&quot;&#125;&quot;); &#125;else if(s[i]!=temp.pop())&#123; return false; &#125; &#125; return !temp.length; //只开不闭temp.length为true //空字符串temp.length为false //其余有效字符串temp会被移除空&#125;; 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 12345678var searchInsert = function(nums, target) &#123; for(var i=0;i&lt;nums.length;i++)&#123; if(nums[i]&gt;=target)&#123; return i &#125; &#125; return nums.length;&#125;; 给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指由字母组成，但不包含任何空格的字符串。 123456789101112var lengthOfLastWord = function(s) &#123; var len = s.length; var count = 0; while(len!=0&amp;&amp;s[len-1]==&quot; &quot;)&#123; len--; &#125; while(s[len-1]!=&quot; &quot;&amp;&amp;len&gt;0)&#123; count++; len--; &#125; return count;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2019%2F04%2F18%2F%E5%89%8D%E7%AB%AF%2Fcanvas%2F</url>
    <content type="text"><![CDATA[Canvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等。 属性 height width 一个Canvas定义了一个指定尺寸的矩形框1&lt;canvas id=&quot;test-canvas&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt; 检测浏览器支持由于浏览器对HTML5标准支持不一致，所以，通常在canvas内部添加一些说明性HTML代码，如果浏览器支持Canvas，它将忽略canvas内部的HTML，如果浏览器不支持Canvas，它将显示canvas内部的HTML 123&lt;canvas id=&quot;test-stock&quot; width=&quot;300&quot; height=&quot;200&quot;&gt; &lt;p&gt;Current Price: 25.51&lt;/p&gt;&lt;/canvas&gt; 在使用Canvas前，还需要用canvas.getContext来测试浏览器是否支持Canvas 123456var canvas = document.getElementById(&apos;test-canvas&apos;);if (canvas.getContext) &#123; console.log(&apos;你的浏览器支持Canvas!&apos;);&#125; else &#123; console.log(&apos;你的浏览器不支持Canvas!&apos;);&#125; 方法canvas绘图以左上角的（0， 0）为基准原点1234let canvas = document.querySelector(&apos;#canvas&apos;); // 得到canvas//得到canvas上下文环境let ctx = canvas.getContext(&apos;2d&apos;)//绘制2d图形let gl = canvas.getContext(&quot;webgl&quot;);//绘制3d图形 绘制矩形ctx.rect(x,y,width,height); 创建矩形。 但并不会真正将矩形画出，只能调用stroke() 或 fill()后才会真正作用于画布。 先填充再描边。 可通过canvas.width或canvas.height获取画布的宽度和高度 ctx.fillRect(x,y,width,height) 执行填充操作，绘制一个已填色的、以(x,y)位置为起点、大小为width x height的矩形。 有填充颜色，默认为black。 ctx.fillStyle=””为图形设置填充颜色 ctx.strokeRect(x,y,width,height); 绘制一个不填色、以(x,y)位置为起点、大小为width x height的矩形。 有边框颜色，默认为black。 ctx.strokeStyle=””为图形设置边框颜色 ctx.clearRect(x,y,width,height); 将(x,y)位置大小为width x height的矩形变为透明。 Internet Explorer 9、Firefox、Opera、Chrome 以及 Safari 支持 clearRect() 方法。 若canvas设置了背景颜色是不能被清除的，因为那是画布的背景颜色，clearRect清除的是绘制的图形，使绘制的图形变为透明，显现出画布背景色。 绘制复杂形状ctx.lineWidth=x;设置线宽为x，不需要加px ctx.fill();填充图形，可利用fillStyle设置填充颜色 ctx.stroke();绘制图形，可利用strokeStyle设置边框颜色 ctx.beginPath();清除原来的痕迹,绘制图形之前要先调用 ctx.closePath();自动完成闭合 ctx.moveTo(x,y);从(x,y)点开始绘图 ctx.lineTo(x,y);绘图终点为(x,y) ctx.arc(x, y, r, 起始弧度， 终点弧度，是否逆时针) 圆心为(x,y),半径为r 弧度 = Math.PI*角度 设置完弧线，要用moveTo()进行绘制 绘制文本ctx.font = “24px 宋体”设置字体大小、型号 ctx.fillText(“文字内容”,left,top); 绘制实心文字。 left为距画布最左边距离，top为距画布最上边距离。 可通过fillStyke设置文字填充颜色 ctx.strokeText(“文字内容”,left,top); 绘制空心文字。 left与top同上。 可通过strokeStyle设置文字边框颜色。 设置文字阴影这些要在设置文字内容之前设置 ctx.shadowOffsetX = x; x轴偏移量，默认位于元素正下方。 ctx.shadowOffsetY = y; y轴偏移量，默认位于元素正下方。 ctx.shadowBlur = num; 设置模糊系数。默认为0不模糊。 ctx.shadowColor = “”; 设置阴影颜色，同时要设置shadowBlur，否则看不见 用canvas画出一个(0,0)坐标绿色的100x100矩形框，再从(10,10)坐标将50x50的区域变成透明 123456789&lt;canvas id=&quot;test&quot; width=&quot;100px&quot; height=&quot;100px&quot;&gt;&lt;/canvas&gt;&lt;script&gt;var canvas = document.getElementById(&quot;test&quot;);var ctx = canvas.getContext(&quot;2d&quot;);ctx.fillStyle = &quot;green&quot;;ctx.fillRect(0,0,100,100);ctx.clearRect(10,10,50,50);&lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统：进程、线程、程序]]></title>
    <url>%2F2019%2F04%2F12%2F%E5%85%B6%E4%BB%96%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[程序只是一组指令的有序集合。 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是资源分配的最小单位。 线程是程序执行的最小单位。 一个程序至少一个进程，一个进程至少一个线程。 一个线程只能属于一个进程，但是一个进程可以拥有多个线程 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。 而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。 多线程处理就是允许一个进程中在同一时刻执行多个任务。 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网：http的header字段]]></title>
    <url>%2F2019%2F04%2F12%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9Ahttp%E7%9A%84header%E5%AD%97%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[http头 = 通用头 + 请求头 + 响应头 通用头(General)通用头域包含请求和响应消息都支持的头域，提供了与报文相关的最基本的信息。 header 含义 Request URL 请求的URL Request Method 请求的方法 Status Code HTTP 状态码 Remote Address 远程IP地址 Referrer Policy 记录了是从哪个链接跳来的 响应头(Response Headers) header 含义 示例 Accept-Ranges 表明服务器是否支持指定范围请求及哪种类型的分段请求 Accept-Ranges: bytes Age 从原始服务器到代理缓存形成的估算时间（以秒计，非负） Age: 12 Allow 对某网络资源的有效的请求行为，不允许则返回405 Allow: GET, HEAD Cache-Control 告诉所有的缓存机制是否可以缓存及哪种类型 Cache-Control: no-cache Content-Encoding web服务器支持的返回内容压缩编码类型。 Content-Encoding: gzip Content-Language 响应体的语言 Content-Language: en,zh Content-Length 响应体的长度 Content-Length: 348 Content-Location 请求资源可替代的备用的另一地址 Content-Location: /index.htm Content-MD5 返回资源的MD5校验值 Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ== Content-Range 在整个返回体中本部分的字节位置 Content-Range: bytes 21010-47021/47022 Content-Type 返回内容的MIME类型 Content-Type: text/html; charset=utf-8 Date 原始服务器消息发出的时间 Date: Tue, 15 Nov 2010 08:12:31 GMT ETag 请求变量的实体标签的当前值 ETag: “737060cd8c284d8af7ad3082f209582d” Expires 响应过期的日期和时间 Expires: Thu, 01 Dec 2010 16:00:00 GMT Last-Modified 请求资源的最后修改时间 Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT Location 用来重定向接收方到非请求URL的位置来完成请求或标识新的资源 Location: http://www.zcmhi.com/archives/94.html Pragma 包括实现特定的指令，它可应用到响应链上的任何接收方 Pragma: no-cache Proxy-Authenticate 它指出认证方案和可应用到代理的该URL上的参数 Proxy-Authenticate: Basic refresh 应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持） Refresh: 5; url=http://www.zcmhi.com/archives/94.html Retry-After 如果实体暂时不可取，通知客户端在指定时间之后再次尝试 Retry-After: 120 Server web服务器软件名称 Server: Apache/1.3.27 (Unix) (Red-Hat/Linux) Set-Cookie 设置Http Cookie Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 Trailer 指出头域在分块传输编码的尾部存在 Trailer: Max-Forwards Transfer-Encoding 文件传输编码 Transfer-Encoding:chunked Vary 告诉下游代理是使用缓存响应还是从原始服务器请求 Vary: * Via 告知代理客户端响应是通过哪里发送的 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 警告实体可能存在的问题 Warning: 199 Miscellaneous warning WWW-Authenticate 表明客户端请求实体应该使用的授权方案 WWW-Authenticate: Basic 请求头(Request Headers) header 含义 示例 Accept 指定客户端能够接收的内容类型 Accept: text/plain, text/html Accept-Charset 浏览器可以接受的字符编码集。 Accept-Charset: iso-8859-5 Accept-Encoding 指定浏览器可以支持的web服务器返回内容压缩编码类型。 Accept-Encoding: compress, gzip Accept-Language 浏览器可接受的语言 Accept-Language: en,zh Accept-Ranges 可以请求网页实体的一个或者多个子范围字段 Accept-Ranges: bytes Authorization HTTP授权的授权证书 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Cache-Control 指定请求和响应遵循的缓存机制 Cache-Control: no-cache Connection 表示是否需要持久连接。（HTTP 1.1默认进行持久连接） Connection: close Cookie HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。 Cookie: $Version=1; Skin=new; Content-Length 请求的内容长度 Content-Length: 348 Content-Type 请求的与实体对应的MIME信息 Content-Type: application/x-www-form-urlencoded Date 请求发送的日期和时间 Date: Tue, 15 Nov 2010 08:12:31 GMT Expect 请求的特定的服务器行为 Expect: 100-continue From 发出请求的用户的Email From: user@email.com Host 指定请求的服务器的域名和端口号 Host: www.zcmhi.com If-Match 只有请求内容与实体相匹配才有效 If-Match: “737060cd8c284d8af7ad3082f209582d” If-Modified-Since 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码 If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT If-None-Match 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 If-None-Match: “737060cd8c284d8af7ad3082f209582d” If-Range 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag If-Range: “737060cd8c284d8af7ad3082f209582d” If-Unmodified-Since 只在实体在指定时间之后未被修改才请求成功 If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT Max-Forwards 限制信息通过代理和网关传送的时间 Max-Forwards: 10 Pragma 用来包含实现特定的指令 Pragma: no-cache Proxy-Authorization 连接到代理的授权证书 Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Range 只请求实体的一部分，指定范围 Range: bytes=500-999 Referer 先前网页的地址，当前请求网页紧随其后,即来路 Referer: http://www.zcmhi.com/archives/71.html TE 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息 TE: trailers,deflate;q=0.5 Upgrade 向服务器指定某种传输协议以便服务器进行转换（如果支持） Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 User-Agent User-Agent的内容包含发出请求的用户信息 User-Agent: Mozilla/5.0 (Linux; X11) Via 通知中间网关或代理服务器地址，通信协议 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 关于消息实体的警告信息 Warn: 199 Miscellaneous warning]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网：计算机网络体系结构]]></title>
    <url>%2F2019%2F04%2F12%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[TCP/IP体系结构五层协议 应用层（http，ftp） 运输层（TCP，UDP） 网络层（IP） 数据链路层 物理层 四层协议 应用层（http，ftp） 运输层（TCP，UDP） 网际层IP 网络接口层 OSI模型 应用层（HTTP） 表示层 会话层（SSL\TLS） 运输层（TCP，UDP） 网络层（IP） 数据链路层 物理层]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：把十六进制的ip地址转换为十进制的]]></title>
    <url>%2F2019%2F04%2F10%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E6%8A%8A%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%9A%84ip%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E8%BF%9B%E5%88%B6%E7%9A%84%2F</url>
    <content type="text"><![CDATA[12345678910function change(ip)&#123; var temp = []; for(var i=0;i&lt;ip.length;i+=2)&#123; temp.push(ip.substr(i,2)) &#125; return temp.map(function(value)&#123; return parseInt(value,16); &#125;).join(&quot;.&quot;);&#125;console.log(change(&quot;C0A80000&quot;)); //&quot;192.168.0.0&quot; 拓展 12345在ip地址中，8位二进制取一个.且二进制的4位对应十六进制的1位因此8位二进制对应一个十进制整数2位十六进制对应一个十进制整数]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：快速排序]]></title>
    <url>%2F2019%2F04%2F09%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序分为交换排序、选择排序、插入排序、归并排序、基数排序快速排序和冒泡排序数据交换排序 首先，定义一个quickSort函数，它的参数是一个数组。 123function quickSort(arr)&#123; &#125; 然后，检查数组的元素个数，如果小于等于1，就返回。 12345function quickSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr; &#125;&#125; 接着，选择”基准”（pivot），并将其与原数组分离，再定义两个空数组，用来存放一左一右的两个子集。 123456789function quickSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr; &#125; var pivotIndex = Math.floor(arr.length/2); var pivot = arr.splice(pivotIndex,1)[0]; var left = []; var right = [];&#125; 然后，开始遍历数组，小于”基准”的元素放入左边的子集，大于等于基准的元素放入右边的子集。 12345678910111213141516function quickSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr; &#125; var pivotIndex = Math.floor(arr.length/2); var pivot = arr.splice(pivotIndex,1)[0]; var left = []; var right = []; for(var i in arr)&#123; if(arr[i] &lt; pivot)&#123; left.push(arr[i]); &#125;else&#123; right.push(arr[i]); &#125; &#125;&#125; 最后，使用递归不断重复这个过程，就可以得到排序后的数组。1234567891011121314151617function quickSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr; &#125; var pivotIndex = Math.floor(arr.length/2); var pivot = arr.splice(pivotIndex,1)[0]; var left = []; var right = []; for(var i in arr)&#123; if(arr[i] &lt; pivot)&#123; left.push(arr[i]); &#125;else&#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot],quickSort(right));&#125; 优化：选一个好的基准：随机选取三个数，排序取中 时间复杂度：nlogn]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6：let和const]]></title>
    <url>%2F2019%2F04%2F02%2FES6%2FES6%EF%BC%9Alet%E5%92%8Cconst%2F</url>
    <content type="text"><![CDATA[let是定义变量 const是定义常量。若定义基本数据类型，则不能再次改变；若定义复杂数据类型，如对象，则可以修改或者添加属性，但指针是不会变的。 let和const都不会变量提升，在声明之前使用会形成死区。 使用babel工具将es6转换为es5]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型：json和xml]]></title>
    <url>%2F2019%2F03%2F29%2F%E5%85%B6%E4%BB%96%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9Ajson%E5%92%8Cxml%2F</url>
    <content type="text"><![CDATA[json json是一种轻量级的数据交换格式。 兼容性高。 格式简单，易读写。 易于解析。 xml xml是一种扩展标记语言。 可用来标记数据，定义数据类型。 格式统一。 文件庞大，格式复杂。 客户端和服务器端都需要大量代码来解析，导致代码复杂难以维护。]]></content>
      <categories>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6：apply、call和bind]]></title>
    <url>%2F2019%2F03%2F29%2FES6%2FES6%EF%BC%9Aapply%E3%80%81call%E5%92%8Cbind%2F</url>
    <content type="text"><![CDATA[都是为了改变某个函数运行时的上下文，即改变函数里的this的指向。将一个函数应用在其他对象上。 第一个参数要绑定给this的值，为nul或undefined时指向window。 apply、call绑定后会立即调用，bind绑定后不会立即调用。 apply第二个参数为数组，call后面为参数列表。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM和DOM]]></title>
    <url>%2F2019%2F03%2F28%2F%E5%89%8D%E7%AB%AF%2FBOM%E5%92%8CDOM%2F</url>
    <content type="text"><![CDATA[BOM和DOM DOM（文档对象模型）是 HTML 和 XML 的应用程序接口。 DOM可以将任何HTML或XML文档描绘成一个由多层次节点构成的结构。 BOM （浏览器对象模型）主要处理浏览器窗口和框架。 javacsript是通过访问BOM对象来访问、控制、修改客户端浏览器。 由于BOM的window包含了document，document对象又是DOM的根节点。可以说，BOM包含了DOM。 浏览器提供出来给予访问的是BOM对象，从BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档。 拓展：遍历dom树]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：二分查找]]></title>
    <url>%2F2019%2F03%2F28%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[二分法查找，也称折半查找，是一种在有序数组中查找特定元素的搜索算法。 首先，从有序数组的中间的元素开始搜索， 如果该元素正好是目标元素（即要查找的元素），则搜索过程结束，否则进行下一步。 如果目标元素大于或者小于中间元素， 则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作。 如果某一步数组为空，则表示找不到目标元素。 12345678910111213141516171819function search(arr,key)&#123; var low = 0; var high = arr.length-1; while(low &lt;= high)&#123; var mid = parseInt((low+high)/2); if(key == arr[mid])&#123; return mid; &#125;else if(key &lt; arr[mid])&#123; high = mid-1; &#125;else if(key &gt; arr[mid])&#123; low = mid+1; &#125;else&#123; return -1; &#125; &#125;&#125;console.log(search([0,1,2,3,5,6,7],5));//4console.log(search([0,1,2,3,5,6,7],4));//undefined]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：flex布局]]></title>
    <url>%2F2019%2F03%2F21%2FCSS%2FCSS%EF%BC%9Aflex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[前言flex布局称为弹性布局。任何一个容器都可以指定为 Flex 布局。 设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效 基本概念采用 Flex 布局的元素，称为 Flex 容器，简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目，简称”项目”。 水平的主轴（main axis） 垂直的交叉轴（cross axis） 主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end 交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性flex-directionflex-direction属性决定主轴的方向（即项目的排列方向）。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿 flex-wrap默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 123.box &#123; flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;;&#125; justify-contentjustify-content属性定义了项目在主轴上的对齐方式。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-itemsalign-items属性定义项目在交叉轴上如何对齐。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-contentalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目的属性orderorder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow flex-grow属性定义项目的放大比例，默认为0。 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。 如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。（即把剩余空间划分为四份，属性为2的占两份，属性为1的占一份）。 flex-shrink flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。数值大的缩小得多。 如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 flex-basisflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flexflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 123.item &#123; flex: &lt;flex-grow&gt; &lt;flex-shrink&gt; &lt;flex-basis&gt;; &#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 align-selfalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto。 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 auto：表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟dom]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%89%8D%E7%AB%AF%2F%E8%99%9A%E6%8B%9Fdom%2F</url>
    <content type="text"><![CDATA[是什么可以看作是一个使用javascript模拟了DOM结构的树形结构，这个树结构包含整个DOM结构的信息。 为什么之前使用原生js或者jquery写页面的时候会发现操作DOM是一件非常麻烦的一件事情，且在浏览器里一遍又一遍的渲染DOM是非常非常消耗性能的。在js做dom对比，减少对dom的操作，而不是每一次都要渲染，这样效率会提高。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种算法（三）]]></title>
    <url>%2F2019%2F03%2F19%2F%E7%AE%97%E6%B3%95%2F%E5%90%84%E7%A7%8D%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[有一个字符串有很多is，写一个方法只保留一个is？ 123456789function deleteIs(str)&#123; var index = str.search(&quot;is&quot;); var left = str.slice(0,index+2); var right = str.slice(index+2,str.length); right = right.split(&quot;is&quot;).join(&quot;&quot;); return left.concat(right); &#125;console.log(deleteIs(&quot;thisismybook&quot;));//thismybook 有3个-10-10之间的整数，写一个方法这三个数一共有多少可能相加等于10。 改写数组的push方法，保持原有逻辑，添加一个console.log(arguments)，即push什么打印什么。 12345Array.prototype.push = function(val)&#123; console.log(val);&#125;var temp = [1,2,5];temp.push(7);//打印7 传入一个无序数组，要求n数相加，获取特定的sum 12345678910111213141516 function getResult(arr,n,sum)&#123; if(n==0&amp;&amp;sum==0)&#123; return true; &#125; if(n&lt;0)&#123; return false; &#125; if(n&gt;0)&#123; for(var i in arr)&#123; var temp = arr.slice(i+1,arr.length); return getResult(temp,n-1,sum-arr[i]) || getResult(temp,n,sum); &#125; &#125;&#125;console.log(getResult([1,2,3,4],2,7)); //true 用正则表达式去掉两边的空格 123456function remove(str)&#123; var reg = /(^\s+)|(\s+?)/g; return str.replace(reg,&quot;&quot;);&#125;console.log(remove(&quot;this is book&quot;));//&quot;thisisbook&quot; 给定一个非空的数字数组，数组有且只有一个非重复项，实现一个方法获取落单项 12345678910111213function getSingleNumber(arr)&#123; var temp = []; for(var i in arr)&#123; if(temp.indexOf(arr[i]) == -1)&#123; temp.push(arr[i]); &#125;else&#123; temp.splice(temp.indexOf(arr[i]),1); &#125; &#125; return temp[0];&#125;console.log(getSingleNumber([0,1,0,0])); //1 请实现一个函数merge，传入一个数组，合并数组中【相邻且重复】的元素 123456789101112function merge(arr)&#123; var reg = /(.)\1*/g; var str = arr.join(&quot;&quot;); str = str.replace(reg,&quot;$1&quot;); arr = str.split(&quot;&quot;); arr = arr.map(function(val)&#123; return parseInt(val); &#125;) return arr;&#125;console.log(merge([3,2,2,4,5,5,6,2,1]));//[3,2,4,5,6,2,1]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种算法（二）]]></title>
    <url>%2F2019%2F03%2F19%2F%E7%AE%97%E6%B3%95%2F%E5%90%84%E7%A7%8D%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[求“123456789876543212345678987654321…”中的第n位123456789function index(n)&#123; if(n%16&lt;10)&#123; return n%16; &#125;else&#123; return 9-(n%16-9); &#125;&#125;console.log(index(26));//8 实现add(1);//1add(1)(2); //3add(1)(2)(3); //6 12345678910111213141516171819var add = function(a) &#123; var sum = a; var s = function(b) &#123; sum += b; //s，继续累加后面的执行参数。 return s; &#125;; //当要打印一个对象时，会自动调用 valueOf()或 toString方法 s.toString = function() &#123; return sum; &#125;; //获取第一个参数赋值给sum后，s。 return s;&#125;;add(1)(2)(3);//6//第一次调用add(),初始化了s，并将a保存在s的作用链中。//然后返回s保证了第二次调用的是s函数。//第二次之后的调用也是调用s，而在s中将传入的参数与保存在作用链中a相加并付给sum。 给定一个数组，返回所有的数字。如[1,’3’,false,null,100]=&gt;[1,3,100] 123456789101112131415function search(arr)&#123; var temp = []; for(var i in arr)&#123; if(typeof arr[i] == &quot;string&quot; || typeof arr[i] == &quot;number&quot;)&#123; temp.push(arr[i]); &#125; &#125; temp = temp.map(function(val)&#123; if（typeof parseInt（val） == &quot;number&quot;） return parseInt(val); &#125;) return temp;&#125;console.log(search([1,&apos;3&apos;,false,null,100])); //[1,3,100]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种算法（一）]]></title>
    <url>%2F2019%2F03%2F17%2F%E7%AE%97%E6%B3%95%2F%E5%90%84%E7%A7%8D%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[求1+2+3+…+n1234567function Sum_Solution(n) &#123; var result = n; if(n &gt; 0) result += Sum_Solution(n-1); return result;&#125;console.log(Sum_Solution(3)); //6 统计一个数字在无序数组中出现的次数123456789101112131415function count(arr,num)&#123; arr.sort(function(a,b)&#123; return a-b; &#125;); var result; var left = arr.indexOf(num); var right = arr.lastIndexOf(num,arr.length-1); if(arr.indexOf(num) == -1)&#123; result = 0; &#125;else&#123; result = right-left+1; &#125; return result;&#125;console.log(count([5,5,5,5,5,2,3],5)); //5 找出数组中任意一个重复的数字12345678910111213141516function duplicate(numbers, duplication)&#123; // write code here //这里要特别注意~找到任意重复的一个值并赋值到duplication[0] //函数返回True/False var temp = []; for(var i in numbers)&#123; if(temp.indexOf(numbers[i])==-1)&#123; temp.push(numbers[i]); &#125;else&#123; duplication[0] = numbers[i]; return true; &#125; &#125; return false;&#125;console.log(duplicate([5,5,5,5,5,2,3],[]));//true 快速排序 1234567891011121314151617function quickSort(arr)&#123; if(arr.length &lt;= 1)&#123; return arr; &#125; var pivotIndex = Math.floor(arr.length/2); var pivot = splice(pivotIndex,1)[0]; var left = []; var right = []; for(var i in arr)&#123; if(arr[i] &lt; pivot)&#123; left.push(arr[i]); &#125;else&#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot],quickSort(right));&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：实现给数字添加千分位符的方法]]></title>
    <url>%2F2019%2F03%2F16%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%AE%9E%E7%8E%B0%E7%BB%99%E6%95%B0%E5%AD%97%E6%B7%BB%E5%8A%A0%E5%8D%83%E5%88%86%E4%BD%8D%E7%AC%A6%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[toLocaleString方法12const num = 12345678;num.toLocaleString(); toLacalString：返回这个数字在特定语言环境下的表示字符串。 在没有指定区域的基本使用时，返回使用默认的语言环境和默认选项格式化的字符串。 正则表达式1234567const num = 12345678;var reg=/\d&#123;1,3&#125;(?=(\d&#123;3&#125;)+$)/g;num.replace(reg,&quot;$&amp;,&quot;);1. 正则表达式 \d&#123;1,3&#125;(?=(\d&#123;3&#125;)+$) 表示前面有1~3个数字，后面的至少由一组3个数字结尾。2. ?=表示正向引用，可以作为匹配的条件，但匹配到的内容不获取，并且作为下一次查询的开始。3. $&amp; 表示与正则表达式相匹配的内容。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：清除浮动]]></title>
    <url>%2F2019%2F03%2F07%2FCSS%2FCSS%EF%BC%9A%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[浮动产生影响 给父元素设置高度。 给父元素设置overflow:hidden; 父元素也设置浮动。 在结尾处添加空div标签clear:both 父元素定义伪类::after 12345::after&#123; clear: both; content: &quot;&quot;; display: block; &#125; 父元素定义display:table]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[h5和css3的新特性]]></title>
    <url>%2F2019%2F03%2F06%2F%E5%89%8D%E7%AB%AF%2Fh5%E5%92%8Ccss3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[HTML5绘画标签canvas用于媒介回放的video、audio本地离线存储localStorage长期存储数据，浏览器关闭后数据不丢失 sessionStorage数据在浏览器关闭后自动删除； 语义化更好的内容元素比如article、footer、header、nav、section； 表单控件calendar、data、time、email、url、search； webworker、websocket、Geolocation； 移除的元素： 纯表现的元素：basefont、big、center、font、s、strike、tt 对可用性产生负面影响的元素：frame、frameset、noframes CSS3RGBA和透明度word-wrap（对长的不可分割单词换行）1word-wrap: normal|break-word; 文字阴影12text-shadow：5px 5px 5px #FF0000;//水平阴影，垂直阴影，模糊距离，阴影颜色 @font-face规则定义自己的字体 圆角（边框半径）border-radius 属性用于创建圆角 边框图片border-image box-sizing盒阴影1box-shadow:10px 10px 5px #88888 媒体查询定义两套css，当浏览器的尺寸变化时会采用不同的属性]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地存储方式]]></title>
    <url>%2F2019%2F03%2F05%2F%E5%89%8D%E7%AB%AF%2F%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[cookie、localStorage、sessionStorage相同：在本地（浏览器端）存储数据。 不同 localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。 sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下。 localStorage是永久存储，除非手动删除。 sessionStorage当会话结束（当前页面关闭的时候，自动销毁） cookie的数据会在每一次发送http请求的时候，同时发送给服务器，而localStorage、sessionStorage不会。 每个cookie存放的内容大小有限制，一般为4kb。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C：冒泡法和选择法]]></title>
    <url>%2F2018%2F12%2F05%2F%E7%AE%97%E6%B3%95%2FC%EF%BC%9A%E5%86%92%E6%B3%A1%E6%B3%95%E5%92%8C%E9%80%89%E6%8B%A9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[冒泡法算法示例用起泡法对10个整数按升序排序。 算法分析如果有n个数，则要进行n-1趟比较。在第1趟比较中要进行n-1次相邻元素的两两比较，在第j趟比较中要进行n-j次两两比较。比较的顺序从前往后，经过一趟比较后，将最值沉底（换到最后一个元素位置），最大值沉底为升序，最小值沉底为降序。 算法源代码12345678910111213141516171819202122232425#include &lt;stdio.h&gt; int main() &#123; int a[10],i,j,t; printf(&quot;Please input 10 numbers: &quot;); /*输入源数据*/ for(i=0;i&lt;10;i++) scanf(&quot;%d&quot;,&amp;a[i]); /*排序*/ for(j=0;j&lt;9;j++) /*外循环控制排序趟数，n个数排n-1趟*/ for(i=0;i&lt;9-j;i++) /*内循环每趟比较的次数，第j趟比较n-j次*/ if(a[i]&gt;a[i+1]) /*相邻元素比较，逆序则交换*/ &#123; t=a[i]; a[i]=a[i+1]; a[i+1]=t; &#125; /*输出排序结果*/ printf(&quot;The sorted numbers: &quot;); for(i=0;i&lt;10;i++) printf(&quot;%d &quot;,a[i]); printf(&quot;\n&quot;); return 0; &#125; 选择法算法示例要求用选择法对10个整数按降序排序。 算法分析每趟选出一个最值和无序序列的第一个数交换，n个数共选n-1趟。第i趟假设i为最值下标，然后将最值和i+1至最后一个数比较，找出最值的下标，若最值下标不为初设值，则将最值元素和下标为i的元素交换。 算法源代码12345678910111213141516171819202122#include &lt;stdio.h&gt; int main() &#123; int a[10],i,j,k,t,n=10; printf(&quot;Please input 10 numbers:&quot;); for(i=0;i&lt;10;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(i=0;i&lt;n-1;i++) /*外循环控制趟数，n个数选n-1趟*/ &#123; k=i; /*假设当前趟的第一个数为最值,记在k中 */ for(j=i+1;j&lt;n;j++) /*从下一个数到最后一个数之间找最值*/ if(a[k]&lt;a[j]) /*若其后有比最值更大的*/ k=j; /*则将其下标记在k中*/ if(k!=i) /*若k不为最初的i值，说明在其后找到比其更大的数*/ &#123; t=a[k]; a[k]=a[i]; a[i]=t; &#125; /*则交换最值和当前序列的第一 个数*/ &#125; printf(&quot;The sorted numbers: &quot;); for(i=0;i&lt;10;i++) printf(&quot;%d &quot;,a[i]); printf(&quot;\n&quot;); &#125; 区别：（个人见解） 冒泡法要进行对n个数进行n-1趟，第j趟要进行n-j次比较，每次比较相邻的数不符合则要交换，每趟最多需要n-j次数的交换 选择法也要进行n-1趟，每趟是选出最值，而选最值是把下标交换，直到选出最值的下标，把最值和第一位交换，每趟最多仅需1次数的交换 简单地说，冒泡法每次都是数的交换（各个下标对应的数是变化的），而选择法是通过下标交换（这时候各个下标对应的数是不变的）选出最值的下标，最后再进行数的交换]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron进阶：打开新窗口]]></title>
    <url>%2F2018%2F11%2F14%2F%E5%85%B6%E4%BB%96%2FElectron%E8%BF%9B%E9%98%B6%EF%BC%9A%E6%89%93%E5%BC%80%E6%96%B0%E7%AA%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[标签实现新窗口打开 增加 target=”_blank”属性 router-link标签只有tag=”a”模式下 target=”_blank” 属性才会生效（vue2） 编程式导航123456let routeData = this.$router.resolve(&#123; name: &quot;searchGoods&quot;, query: params, params:&#123;catId:params.catId&#125; &#125;); window.open(routeData.href, &apos;_blank&apos;);]]></content>
      <categories>
        <category>Electron</category>
      </categories>
      <tags>
        <tag>Electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron：结合vue创建桌面应用]]></title>
    <url>%2F2018%2F11%2F14%2F%E5%85%B6%E4%BB%96%2FElectron%EF%BC%9A%E7%BB%93%E5%90%88vue%E5%88%9B%E5%BB%BA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[首先创建项目并安装好依赖12345vue init webpack test-electroncd test-electronnpm installnpm install electron --save-devnpm install electron-packager --save-dev 其次将零基础中的main.js拷贝到新建项目的build目录下，并更名为electron.js 按照实际项目路径更改electron.js中的路径 12345mainWindow.loadURL(url.format(&#123; pathname: path.join(__dirname, &apos;../dist/index.html&apos;), protocol: &apos;file:&apos;, slashes: true &#125;)) 最后在新建项目package.json文件中增加一条指令 1234567&quot;scripts&quot;: &#123; ... &quot;lint&quot;: &quot;eslint --ext .js,.vue src test/unit/specs test/e2e/specs&quot;, &quot;build&quot;: &quot;node build/build.js&quot;, //增加这条,JSON文件不支持注释，引用时请清除 &quot;electron_dev&quot;: &quot;npm run build &amp;&amp; electron build/electron.js&quot; &#125;, 启动12npm run build //生成dist目录npm run electron_dev //启动electron PS 打包前：更改config/index.js中生产模式下（build）的assetsPublicPth, 原本为 /, 改为 ./ 。]]></content>
      <categories>
        <category>Electron</category>
      </categories>
      <tags>
        <tag>Electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron：从零到完成一个桌面应用]]></title>
    <url>%2F2018%2F10%2F20%2F%E5%85%B6%E4%BB%96%2FElectron%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%88%B0%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Electron 开发环境 安装node 安装cnpm（或者npm） 安装electron 安装打包工具 1npm install -g electron-packager 经典例子electron-quick-start一个简约的记事本12345678//克隆这仓库 git clone https://github.com/electron/electron-quick-start//进入仓库 cd electron-quick-start//安装依赖库 cnpm install//运行应用，也可以用： cnpm run start cnpm start electron-api-demos介绍了主要的一些功能及实现代码 1234git clone https://github.com/electron/electron-api-demoscd electron-api-demoscnpm installcnpm start 开始开发安装electron推荐的安装方法是把electron作为您 app 中的开发依赖项，使您可以在不同的 app 中使用不同的 Electron 版本 在根目录下运行 1npm install --save-dev electron 当然，也可以在 $PATH 中全局安装1npm install electron -g 创建Electron简单文件结构在根目录下创建package.json文件，内容如下 1234567891011&#123; &quot;name&quot;: &quot;test&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;electron .&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;electron&quot;: &quot;^3.0.4&quot; &#125;&#125; 在根目录下创建main.js，内容如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const &#123; app, BrowserWindow &#125; = require(&apos;electron&apos;) // Keep a global reference of the window object, if you don&apos;t, the window will // be closed automatically when the JavaScript object is garbage collected. let win function createWindow () &#123; // 创建浏览器窗口。 win = new BrowserWindow(&#123; width: 800, height: 600 &#125;) // 然后加载应用的 index.html。 win.loadFile(&apos;index.html&apos;) // 打开开发者工具 win.webContents.openDevTools() // 当 window 被关闭，这个事件会被触发。 win.on(&apos;closed&apos;, () =&gt; &#123; // 取消引用 window 对象，如果你的应用支持多窗口的话， // 通常会把多个 window 对象存放在一个数组里面， // 与此同时，你应该删除相应的元素。 win = null &#125;) &#125; // Electron 会在初始化后并准备 // 创建浏览器窗口时，调用这个函数。 // 部分 API 在 ready 事件触发后才能使用。 app.on(&apos;ready&apos;, createWindow) // 当全部窗口关闭时退出。 app.on(&apos;window-all-closed&apos;, () =&gt; &#123; // 在 macOS 上，除非用户用 Cmd + Q 确定地退出， // 否则绝大部分应用及其菜单栏会保持激活。 if (process.platform !== &apos;darwin&apos;) &#123; app.quit() &#125; &#125;) app.on(&apos;activate&apos;, () =&gt; &#123; // 在macOS上，当单击dock图标并且没有其他窗口打开时， // 通常在应用程序中重新创建一个窗口。 if (win === null) &#123; createWindow() &#125; &#125;) // 在这个文件中，你可以续写应用剩下主进程代码。 // 也可以拆分成几个文件，然后用 require 导入。 然后创建index.html文件，内容如下 12345678910&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;TEST&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;span style=&quot;color:#fff;&quot;&gt;Hello World&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 启动app1npm start 或者在package.json中配置1&quot;scripts&quot;: &#123;&quot;start&quot;: &quot;electron .&quot;&#125; 则可以输入一下命令启动1electron . 打包全局安装electron-packager]]></content>
      <categories>
        <category>Electron</category>
      </categories>
      <tags>
        <tag>Electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm：install 出错]]></title>
    <url>%2F2018%2F08%2F22%2FGit%2Fnpm%EF%BC%9Ainstall%20%E5%87%BA%E9%94%99%2F</url>
    <content type="text"><![CDATA[第一种问题123$ npm installnpm WARN registry Unexpected warning for or http://registry.cnpmjs.org/: Mis Miscellaneous Warning ECONNRESET: request to to https://cnpmjs.oss-ap-southeast-1.aliyuncs.com/acorn/-/acorn-5.7.1.tgz fai failed, reason: read ECONNRESETnpm WARN registry Using stale package data from om http://registry.cnpmjs.org/ du/ due to a request error during revalidation. 解决方法12$ npm config set registry ry http://registry.cnpmjs.org$ npm install 第二种问题1234567891011$ npm installnpm ERR! code ECONNRESETnpm ERR! errno ECONNRESETnpm ERR! network request to to https://cnpmjs.oss-ap-southeast-1.aliyuncs.com/arrify/-/arrify-1.0.1.tgz fai failed, reason: read ECONNRESETnpm ERR! network This is a problem related to network connectivity.npm ERR! network In most cases you are behind a proxy or have bad network settings.npm ERR! networknpm ERR! network If you are behind a proxy, please make sure that thenpm ERR! network &apos;proxy&apos; config is set properly. See: &apos;npm help config&apos;npm ERR! A complete log of this run can be found in: 解决方法12$ npm config delete proxy$ npm install 第三种问题12$ npm installnpm ERR! write after end 解决方法降低版本 1npm i -g npm@5.6.0]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github 搭建属于自己的博客（进阶）NexT主题]]></title>
    <url>%2F2018%2F05%2F04%2F%E5%85%B6%E4%BB%96%2FHexo%2BGithub%20%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89NexT%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[主题安装安装NexT在站点目录下（hexo），输入命令： 1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题在站点目录中（blog），打开配置文件_config.yml，修改1theme：next 验证主题1$ hexo s 主题设定以下所有设置注意格式 NexT主题设定可以在next主题目录下的_config.yml文件中修改 12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 基础设置在站点目录下的配置文件_cofig.yml中修改 12345678# Sitetitle: your blog titlesubtitle:description: describe yourselfkeywords:author: yournamelanguage: zh-Hans //简体中文timezone: 修改菜单项在主题目录下修改配置文件_cofig.yml中的menu 123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 这些配置都要与你主题目录下的languages文件中对应的yml文档里配置相关联 12345678910menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 限定主页文章高度修改主题目录下的值 123auto_excerpt: enable: true length: 150 设置头像修改主题目录下Sidebar Avatar的avatar值1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /images/avatar.jpg 地址可以是网络地址，也可以是本地地址（放置在source/images/ 目录下） 添加标签页面点击标签，跳转的页面会显示page not found 此时需要在站点目录的source文件夹里新建tags文件夹，并新建index.md，添加： 12345---title: tagsdate: type: &quot;tags&quot;--- 当要为某一篇文章添加标签，只需在blog/source/_post目录下的具体文章的tags中添加标签即可 实现点击出现桃心效果将代码copy到/themes/next/source/js/src里面新建的love.js中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950! function(e, t, a) &#123; function n() &#123; c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;), o(), r() &#125; function r() &#123; for (var e = 0; e &lt; d.length; e++) d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = &quot;left:&quot; + d[e].x + &quot;px;top:&quot; + d[e].y + &quot;px;opacity:&quot; + d[e].alpha + &quot;;transform:scale(&quot; + d[e].scale + &quot;,&quot; + d[e].scale + &quot;) rotate(45deg);background:&quot; + d[e].color + &quot;;z-index:99999&quot;); requestAnimationFrame(r) &#125; function o() &#123; var t = &quot;function&quot; == typeof e.onclick &amp;&amp; e.onclick; e.onclick = function(e) &#123; t &amp;&amp; t(), i(e) &#125; &#125; function i(e) &#123; var a = t.createElement(&quot;div&quot;); a.className = &quot;heart&quot;, d.push(&#123; el: a, x: e.clientX - 5, y: e.clientY - 5, scale: 1, alpha: 1, color: s() &#125;), t.body.appendChild(a) &#125; function c(e) &#123; var a = t.createElement(&quot;style&quot;); a.type = &quot;text/css&quot;; try &#123; a.appendChild(t.createTextNode(e)) &#125; catch (t) &#123; a.styleSheet.cssText = e &#125; t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a) &#125; function s() &#123; return &quot;rgb(&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;)&quot; &#125; var d = []; e.requestAnimationFrame = function() &#123; return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function(e) &#123; setTimeout(e, 1e3 / 60) &#125; &#125;(), n()&#125;(window, document); 打开\themes\next\layout_layout.swig文件,在末尾（在前面引用会出现找不到的bug） ，引用love.js 1&lt;script src=&quot;/js/src/love.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 添加动态背景打开\themes\next\layout_layout.swig文件，在 之前添加代码(注意不要放在&lt; /head&gt;的后面) 123&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 打开开\themes\next_config.yml,在里面修改为如下代码 1canvas_nest: true 在网站底部加上访问量打开\themes\next\layout_partials\footer.swig文件,在类copyright前加上这段代码： 1&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 然后在合适的位置添加显示统计的代码： 12345&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 在每篇文章末尾添加“本文结束”标记在路径 \themes\next\layout_macro 中新建 passage-end-tag.swig 文件,并添加以下内容 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout_macro\post.swig文件，在post-body 之后， post-footer 之前添加如下代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 打开主题配置文件,在末尾添加 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 侧边栏社交链接在主题配置文件中修改： 12345678910111213# Social linkssocial: GitHub: https://github.com/your-user-name Twitter: https://twitter.com/your-user-name 微博: http://weibo.com/your-user-name# Social Iconssocial_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter 微博: weibo 添加小图标在主题配置文件中修改： 123favicon: #small: /images/favicon.ico medium: /images/favicon.ico NexT主题美化 除了NexT还有很多其他好看的主题，百度会有很多方法的]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github 搭建属于自己的博客（基础）]]></title>
    <url>%2F2018%2F05%2F03%2F%E5%85%B6%E4%BB%96%2FHexo%2BGithub%20%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[搭建环境准备Node.js 的安装和准备12$ node -v$ npm -v git的安装和准备1$ git --version github账户的配置 github账户注册 创建新仓库 注意：仓库名称一定为 github用户名.github.io 仓库设置 接下来开启github pages功能 ，点击界面右侧的 Settings，你将会打开这个库的settings页面，向下拖动，直到看见GitHub Pages 安装hexo在任意一个地方创建文件夹hexo，进入到该目录输入： 1$ npm install hexo-cli -g 然后可能会看到一个WARN，并不会影响操作，继续输入： 1$ npm install hexo --save 1$ hexo -v hexo的相关配置 初始化hexo 12$ hexo init &lt;新文件夹&gt; $ cd &lt;新文件夹&gt; 首次体验hexo 123$ hexo g$ hexo s //若一直无法跳转，则是端口被占用$ hexo server -p 5000 //改变端口号 配置Git个人信息如果之前已经配置好git个人信息，请跳过这一个步骤 设置Git的user name和email 12$ git config --global user.name &quot;yourusername&quot;$ git config --global user.email &quot;youremail&quot; 生成密钥 1$ ssh-keygen -t rsa -C &quot;youremail&quot; 配置Deployment在_config.yml文件中，找到Deployment，然后按照如下修改： 1234deploy: type: git repo: https://github.com/yourname/yourname.github.io.git branch: master 写博客、发布新文章 新建一篇博客 1$ hexo new post &quot;article title&quot; 用MarDown编辑器打开就可以编辑文章了 生成、部署 123$ hexo g // 生成$ hexo s // 本地预览$ hexo d // 部署 1$ hexo d -g //在部署前先生成 踩坑提醒 注意需要提前安装一个扩展 1npm install hexo-deployer-git --save 如果没有执行这行命令，将会提醒 deloyer not found:git]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F03%2F%E5%85%B6%E4%BB%96%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>demo</category>
      </categories>
      <tags>
        <tag>demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm：清理缓存]]></title>
    <url>%2F2018%2F03%2F28%2FGit%2Fnpm%EF%BC%9A%E6%B8%85%E7%90%86%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[旧版本（4及以下）1$ npm cache clean 新版本（5）先尝试1$ npm cache clean --force 若不行则使用下面的命令 1$ npm cache clear --force &amp;&amp; npm install --no-shrinkwrap --update-binary]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习路线规划]]></title>
    <url>%2F2018%2F01%2F23%2F%E5%89%8D%E7%AB%AF%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[前端学习路线规划一、代码编写工具sublime Text 3: sublime text编辑器单从界面看非常简洁，可以说让人一见倾心的感觉。完全符合码农的口味~~。功能上也不复杂，就跟记事本似的，很容易上手。 可以自由扩展，sublime提供了安装插件的方式，可以任意安装你想要的插件. 二、学习路线规划1. 熟练使用 HTML、CSSHTML 是标签语言，可以构建前端页面的骨架；CSS是层叠样式控制表，可以构建前端页面的外貌 这部分比较简单，到网上搜资料，书籍视频非常多。css中盒子模型，流动，block，inline，层叠，样式优先级等这些比较重要。最后再深入了解下浏览器差异性，ie9以下兼容简单了解就行了，ie9以下浏览器被淘汰掉是趋势，低版本没必要浪费大量时间去学习兼容主流浏览器，google chrome浏览器、firefox浏览器、safari浏览器、opera浏览器即可。浏览器差异内容很多，建议在实践中多多积累。 12推荐书籍：《Head First HTML 与 CSS (第2版)》 《CSS 禅意花园(修订版)》 2.javascript部分（最重要的部分）难点，也是重点，要学的内容实在很多，如果没有其他编程语言的基础的话，学起来可能要费些力，有很多比较抽象的概念，必须要深入理解，比如闭包、原型、面向对象、封装等，要理解透彻。看书是必不可少的，找一本优秀的js书从头到尾深入学习了。另外，js面向对象编程必须要学习，非常重要，个人推荐一本书《javascript高级程序设计》。边学边练，实践出真知。 1234推荐教程：网易云课堂上 李炎恢老师的视频，讲得很详细，讲的是和那本红宝书一样的内容 多动手写demo推荐书籍：《Javascript 权威指南》 《JavaScript 高级程序设计(第3版)》 3.jQuery学习（这不是一个框架，是一个类库）这些基础知识掌握好之后，还需要学jQuery，这是一个非常优秀的Javascript库，大型开发必备。它简化了Javascript的复杂操作，消除了Javascript跨平台兼容问题，提供了大量实用方法，有良好的文档和帮助手册，是一个非常成熟的Javascript库。 12推荐教程：网易云课堂上 李炎恢老师的视频，多动手写demo推荐书籍：《锋利的jquery》 4.ajax的学习通过在后台与服务器进行数据交换，AJAX可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新，ajax是现在前端后台交互的主要方式。 12掌握的知识点：js原生的发送ajax的方法 jq的简便的发送ajax的方法 5.gitGit是目前世界上最先进的分布式版本控制系统，适合于在团队合作时进行版本控制，提高开发效率 1推荐教程：廖雪峰老师的关于git的教程博客 6.理解前端语言新标准 HTML5、CSS3、ES6 及其特性熟练使用 HTML、CSS、JavaScript 还需要我们理解其语言最新相关标准：HTML5、CSS3 和 ES6(ECMAScript6)。 HTML 5 里新增了许多特性：语义化和新的音频、视频支持等； CSS 3 被划分为模块，解决了 CSS2 为等待各个标准统一而耗费大量时间才能推进的不足之处，同时也提供了 2D、3D、动画效果等新特性； ECMAScript6 等于 JavaScript - DOM - BOM，是 JavaScript 在 2015 年的最新标准，因为 ES6 对标准改动较大，前端开发者常常将一个前端项目是否支持 ES6 作为推进前端新技术的重要桥梁之一。ES6 将箭头函数、let 变量声明命令、Promise 编程、模块化编程等新特性纳入其标准中，得到了各大浏览器最新版本的支持。 12扩展阅读：《ES6 标准入门(第2版)》 《深入理解ES6》 7.掌握浏览器兼容、响应式布局相关解决方案早期占据浏览器半壁江山的IE浏览器上存在的众多浏览器兼容问题，耗费了当时前端开发者的大量开发时间。虽然说现在的前端开发者已经不需要考虑太多的浏览器兼容问题，对其概念的了解有利于了解前端历史包袱或在未来足以应对一些面向特殊群体(早期 IE 浏览器使用者)的前端项目。关于IE浏览器的兼容性问题在李炎恢老师的那个视频有详细的讲解 响应式布局和单页面应用是当代前端开发者的必备技能。从 Web Pages 到 Web App 时代，我们开发的前端项目有越来越多的可能需要同时在电脑端和手机端进行访问，一个有良好响应式布局的前端项目可以一个代码运行在多种不同分辨率的平台之上。 三、现在前端主流的框架1. vuejs :2016年最火的前端框架（MVVC框架）是一套用于构建用户界面的渐进式框架Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 常用于单页面应用的开发 12345678掌握的要点：(vue全家桶) 1.vue-router 2.vuex 3.vue-resource 4.vue-cli 5.Element-ui 推荐教程：详细阅读官网教程，中国人自己研发的，有中文版，不难 2. ReactjsReact 是一个用于构建用户界面的 javascript 库。 React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。 React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。 React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。 React特点： 1234561.声明式设计 −React采用声明范式，可以轻松描述应用。2.高效 −React通过对DOM的模拟，最大限度地减少与DOM的交互。3.灵活 −React可以与已知的库或框架很好地配合。4.JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。5.组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。6.单向响应的数据流 − React实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。 123456掌握的知识点：（React全家桶技术） 1.Reactjs 2.React生命周期 3.React Router 4.Redux 5.React Native(主要用于移动端的开发) 3.AngularJS（国外开发大型项目常用框架）AngularJS的四大功能： MVC 将后台的MVC模式写入了前端语言中。我总觉得前端语言将来会很叼，从node.js开始我就又一种这样的感觉。可能在很久之后取代后端语言不是没有可能的。 模块化 就是一系列函数的集合，当应用被启动时，这些函数就会被执行。主要利用angular.module来定义模块。也是Angular.js的亮点。 指令属性 我自己的理解就是比html标签更加具有属性和方法的指令标签 双向数据绑定 传统的数据绑定是单向绑定，数据只能从model和controller生成需要的html，但是不能返过来使用。只是单方向的。双向数据绑定:也就是说我在前面填写，后面直接生成代码，将填写的显示出来。双向的意思就是如果view修改了属性值，那么model机会看到这个改变。相反也是一样的。 4. 小程序（类似一个前端开发框架）1推荐教程：官网上的小程序开发文档，尝试动手写一下小程序 5.nodejs(前端用来写后台的工具)简单的说 Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。 Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。1推荐教程：官网的教程 四、一些常用的ui框架1. Bootstrape：最好的响应式css框架2. Element-ui：完美适应vuejs的ui框架3. Amazeui：Amaze UI 是一个轻量级、 Mobile first 的前端框架, 基于开源社区流行前端框架编写的。4. Aliceui5.Echart：最好的图表制作框架·····六、前端最好掌握的一些常用技能 Markdown笔记的使用，程序员专用笔记本 github的使用：全球最大的开源代码网站，在上面你可以找到全世界所有出名项目的源代码，被称为人类的知识宝库。 用github page搭建个人博客，上传个人项目到github上，面试加分必备项 移动端的开发 前端web开发命名规范，谷歌、百度命名标准 等等·······]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
