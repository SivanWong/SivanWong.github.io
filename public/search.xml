<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vite]]></title>
    <url>%2F2022%2F04%2F26%2F%E5%89%8D%E7%AB%AF%2Fvite%2F</url>
    <content type="text"><![CDATA[1.概述 项目基本是基于webpack进行打包的，随着模块的增多及需求的迭代，启动、发布等都会越来越慢，为了对此进行优化，开展对vite的调研。 调研 Vite 打包工具 与AN业务的适用性，与 Webpack 相比的差异。 2.调研方法 使用webiste进行调研。 修改配置及处理启动时的报错。 使用vite进行打包，修改打包时的报错。 打包后执行命令进行预览，修改预览时的报错。3.调研过程 以下是webpack迁移vite会遇到的一些问题 12345&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vite&quot;, &quot;build&quot;: &quot;vite build --debug&quot;, &quot;serve&quot;: &quot;vite preview&quot;,&#125; 3.1 启动3.1.1 环境变量引入 新建本地文件 .env.local ，该文件需添加进 .gitignore 中。 变量名需要以 VITE_xxx 的方式命名。 在配置文件中使用： 123456789101112131415//.env.localVITE_COUNTRY = vnVITE_ENVIRONMENT = test// vite.config.jsimport &#123; defineConfig, loadEnv &#125; from &apos;vite&apos;;export default (&#123; mode &#125;) =&gt; &#123; const env = loadEnv(mode, process.cwd()); const environment = env.VITE_ENV || env.VITE_ENVIRONMENT || &apos;test&apos; const country = env.VITE_CID || env.VITE_COUNTRY || &apos;my&apos; return defineConfig(&#123; //... &#125;)&#125; 3.1.2 别名12345678910// vite.config.jsexport default (&#123; mode &#125;) =&gt; &#123; // ... return defineConfig(&#123; resolve: &#123; alias: [&#123; find: &apos;@/&apos;, replacement: &apos;/src/&apos; &#125;], &#125; &#125;)&#125; 3.1.3 样式问题1: [vite] Internal server error: Preprocessor dependency “sass” not found. Did you install it? 安装sass 问题2: [vite] Internal server error: Inline JavaScript is not enabled. Is it set in your options? 12345678910return defineConfig(&#123; css: &#123; preprocessorOptions: &#123; less: &#123; javascriptEnabled: true, modifyVars: theme &#125; &#125; &#125;&#125;) 问题3: [vite] Internal server error: ‘~antd/dist/antd.less’ wasn’t found. Tried - /Users/xinweiwang/Desktop/affiliate/web-affiliate/src/~antd/dist/antd.less,node_modules/~antd/dist/antd.less,npm://~antd/dist/antd.less,~antd/dist/antd.less 把theme.js中的 @import “~antd/dist/antd.less”; 注释。 添加插件vite-plugin-imp按需加载antd 123456789101112return defineConfig(&#123; plugins: [ vitePluginImp(&#123; libList: [ &#123; libName: &quot;antd&quot;, style: (name) =&gt; `antd/es/$&#123;name&#125;/style/`, &#125;, ], &#125;) ],&#125;) 问题4：不支持 ‘:export’ 问题5：Unknown theme type: undefined, name: undefined https://github.com/ant-design/ant-design/issues/19002 1234567return defineConfig(&#123; resolve: &#123; alias: &#123; &apos;@ant-design/icons/lib/dist&apos;: &apos;@ant-design/icons/lib/index.es.js&apos; &#125;, &#125;, &#125;) 3.1.4 配置代理123456789101112return defineConfig(&#123; server: &#123; port: 8888, host: &apos;0.0.0.0&apos;, proxy: &#123; &apos;/api&apos;: &#123; target: `https://affiliate.$&#123;environment&#125;.$&#123;BASE_DOMAIN_ALL[country]&#125;/`, changeOrigin: true &#125; &#125; &#125;&#125;) 3.1.5 引入入口文件12// index.html &lt;script type=&quot;module&quot; src=&quot;/src/index.tsx&quot;&gt;&lt;/script&gt; 3.1.6 启动时各种408，请求超时 ，可以删除node_modules，重新install 3.1.7 Uncaught SyntaxError: The requested module ‘/global.config.js?t=1647918620356’ does not provide an export named ‘default’vite不支持cjs，https://github.com/vitejs/vite/issues/3024 方案一：可以通过预捆绑的方式处理，但那代表着需要捆绑很多个文件 方案二：把global.config.js中的module.exports改为export default，所有文件的module.exports及require都需要更改 3.1.8 Uncaught ReferenceError: global is not defined方案一 1234// index.html&lt;script&gt; global = globalThis;&lt;/script&gt; 方案二：缺点是打包时会把同名文件的文件名修改掉 123456// vite.config.js return defineConfig(&#123; define: &#123; global: JSON.stringify(&#123;&#125;) &#125;&#125;) 3.1.9 babel使用插件@vitejs/plugin-react 12345678910// vite.config.jsreturn defineConfig(&#123; plugins: [ react(&#123; babel: &#123; plugins: [], &#125;, &#125;), ]&#125;) 3.1.10 未解之谜（后来没有再出现了）https://github.com/vitejs/vite/issues/6241 vite@2.5.10没有出现此问题，但评论说还有，所以也暂时不算是解决了。 3.1.11 全局变量define中对应的值是一个常量，需要使用JSON.stringify()来表示是一个常量。 1234567// vite.config.js const country = env.VITE_COUNTRY;return defineConfig(&#123; define: &#123; COUNTRY: JSON.stringify(country) &#125;&#125;) 3.1.12 Uncaught Error: Dynamic require of “/Users/xinweiwang/Desktop/affiliate/web-affiliate/node_modules/@mkt/common-component/dist/LazyImage/default-image.svg” is not supported方案一： 类似问题及解决方案：https://github.com/vitejs/vite/issues/5308 使用插件@originjs/vite-plugin-commonjs处理了： 1234567// vite.config.js const country = env.VITE_COUNTRY;return defineConfig(&#123; plugins: [ viteCommonjs() ]&#125;) 3.1.13 [vite] Internal server error: Failed to resolve import “‘ + name + ‘“ from “node_modules/.vite/react-app-polyfill_stable.js?v=f714c2ed”. Does the file exist?找到一个类似问题 方案：使用@vitejs/plugin-legacy取代react-app-polyfill，具体配置根据实际情况而定。 1234567891011// vite.config.js import legacy from &apos;@vitejs/plugin-legacy&apos;;return defineConfig(&#123; plugins: [ legacy(&#123; targets: [&apos;ie &gt;= 11&apos;], additionalLegacyPolyfills: [&apos;regenerator-runtime/runtime&apos;] &#125;), ]&#125;) 3.1.14 regeneratorRuntime is not definedimport “regenerator-runtime” 3.1.15 Uncaught TypeError: Unknown theme type: undefined, name: undefined解决方案：https://github.com/ant-design/ant-design/issues/19002#issuecomment-965958565 3.2 打包3.2.1 重名问题打包时不允许有重名现象，即使一个是类型名，一个是变量名，会报 Identifier ‘xxx’ has already been declared. 有两处地方存在此问题： /src/components/Payment/BillingDetail/PaymentDetail/index.tsx：PaymentConfirmation /src/components/Payment/Setting/ZipCodeAddress/index.tsx：ZipCodeAddress 3.2.2 压缩后大于500k的文件与业务相关，需要优化具体模块 3.3 打包后预览3.3.1 Uncaught TypeError: Failed to resolve module specifier “indexof”. Relative references must start with either “/“, “./“, or “../“.解决方案：https://github.com/vitejs/vite/issues/2670#issuecomment-905495115 3.3.2 Uncaught ReferenceError: require is not defined// vite.config.js 1234567return defineConfig(&#123; build: &#123; commonjsOptions: &#123; transformMixedEsModules: true &#125; &#125;, &#125;) 3.3.3 Uncaught ReferenceError: exports is not defined未解决：https://github.com/rollup/plugins/issues/1014 临时解决方案：https://github.com/rollup/plugins/issues/1014#issuecomment-1049512712 3.4 Jenkins部署3.5 业务相关以下是业务相关的补充，由于不影响编译打包等，所以并不保证是包含全部的。 3.5.1 svg使用插件vite-plugin-svg-icons生成svg sprite map 1234567891011121314151617// vite.config.js import &#123; createSvgIconsPlugin &#125; from &apos;vite-plugin-svg-icons&apos;;return defineConfig(&#123; plugins: [ createSvgIconsPlugin(&#123; iconDirs: [ path.resolve(process.cwd(), &apos;src/assets/icons&apos;), path.resolve(process.cwd(), &apos;src/assets/svg&apos;) ], symbolId: &apos;[name]&apos; &#125;) ]&#125;)// src/index.tsximport &apos;virtual:svg-icons-register&apos;; 3.5.2 其余基于webpack的插件vite插件合集 webpack插件 类似的vite插 svg-sprite-loader vite-plugin-svg-icons workbox-webpack-plugin vite-plugin-pwa realtime-translation-webpack-plugin babel-plugin-istanbul-shopee 3.5.3 业务相关报错Uncaught (in promise) ReferenceError: require is not defined：类似的require都需要修改 如 src/components/common/Empty 12345// 原来的写法&lt;img src=&#123;require(&apos;@/assets/images/empty.png&apos;)&#125;/&gt;// 改为&lt;img src=&#123;new URL(&apos;../../../assets/images/empty.png&apos;, import.meta.url).href&#125;/&gt; 如 src/translate/index.ts 12345678// 原来的写法const message = require(&apos;./messages/&apos; + language + &apos;.json&apos;);result[language] = regExpEditLanguage(message);// 改为const messages = import.meta.globEager(&apos;./messages/*.json&apos;);const path = `./messages/$&#123;language&#125;.json`;result[language] = regExpEditLanguage(messages[path]); 4.调研结果4.1 原理官网有给出与传统打包工具的对比 4.2 Webpack vs Vite action webpack vite 首次启动 90s~120s 0.4s ~ 1s 首次首屏 很快 约40s 第二次启动首屏 很快 约9s HMR 8s～10s 0.05s ～ 0.2s 打包构建 2min~3min 2min ~ 3min vite的启动比webpack快很多，但首次启动的首屏展示并不快，该加载的包还是要等加载完才展示。 第二次启动时，vite由于缓存，首屏展示速度变快。 官方表示，Vite HMR 更新反映到浏览器的时间小于 50ms。 两者打包速度差不多。 5.结论 在开发上，特别是启动项目时，速度是有一定提升的。 vite还不算很成熟，有很多隐藏问题，甚至有一些问题无法从根本解决，如3.1.10。 并不是所有webpack插件都有对应的vite插件，自定义的更是需要重写，工作量也许很大。 一个庞大的项目，从webpack迁移vite，工作量很大，业务代码也有需要兼容的，例如各种require]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[whistle：利用whistle操作WebSocket请求]]></title>
    <url>%2F2022%2F04%2F26%2F%E5%89%8D%E7%AB%AF%2Fwhistle%EF%BC%9A%E5%88%A9%E7%94%A8whistle%E6%93%8D%E4%BD%9CWebSocket%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[一、安装123npm install -g whistle.script# Mac、Linux用户可能需要加sudosudo npm install -g whistle.script 安装插件后要重启whistle 二、使用打开script插件的界面，创建一个名字为 test 的脚本: 可以通过 Plugins-&gt;Home-&gt;script打开或右键并选择 在新标签页中打开 或者直接访问 http://local.whistlejs.com/plugin.script 三、操作请求1、操作HTTP或HTTPs请求(操作HTTPs需要开启HTTPs拦截)脚本中输入： 12345678910111213141516171819202122232425262728293031exports.handleRequest = function* (ctx, next) &#123; // ctx.fullUrl 可以获取请求url // ctx.headers 可以获取请求头 // ctx.options 里面包含一些特殊的请求头字段，分别可以获取一些额外信息，如请设置的规则等 // ctx.method 获取和设置请求方法 // const reqBody = yield ctx.getReqBody(); 获取请求body的Buffer数据，如果没有数据返回null // const reqText = yield ctx.getReqText(); 获取请求body的文本，如果没有返回&apos;&apos; // const formData = yield ctx.getReqForm(); 获取表单对象，如果不是表单，返回空对象&#123;&#125; // console.log(ctx.method, ctx.headers, reqBody); // ctx.req.body = String| Buffer | Stream | null，修改请求的内容 // 只有执行next方法后才可以把正常的请求发送出去 // 如果需要自定义请求，可以通过全局的request方法操作 // console.log(request); // next方法可以设置next(&#123; host, port &#125;); const &#123; statusCode, headers &#125; = yield next(); console.log(ctx.fullUrl, statusCode, headers); // const resBody = yield ctx.getResBody(); // const resText = yield ctx.getResText(); // ctx.status = 404; 修改响应状态码 // ctx.set(headers); 批量修改响应头 // ctx.set(&apos;x-test&apos;, &apos;abc&apos;); 修改响应头 // ctx.body = String| Buffer | Stream | null; 修改响应内容&#125;; // 如果Node &gt;= 7.6，可以采用async await的方式exports.handleRequest = async (ctx, next) =&gt; &#123; // do sth // next方法可以设置next(&#123; host, port &#125;); const &#123; statusCode, headers &#125; = await next(); // do sth&#125;; 在whistle的Rules配置界面上输入规则（需要放在最前面）: 123script://test games.*.shopee.**# 如果需要通过配置给脚本传递一些额外参数，可以如下配置script://test(a,b,c) games.*.shopee.** 可以在脚本中通过 process.args 获取: 123exports.handleRequest = (ctx, next) =&gt; &#123; console.log(process.args); // output: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#125;; 2、操作WebSocket请求(需要开启HTTPs拦截)脚本中输入： 1234567891011121314151617// Node &lt; 7.6可以改用genrator和yieldexports.handleWebSocket = async (req, connect) =&gt; &#123; // connect方法可以设置connect(&#123; host, port &#125;); const res = await connect(); res.on(&apos;message&apos;, (data) =&gt; &#123; // 在script的Console打印出服务端发送的数据 console.log(&apos;Received: &apos;, data); // 可以修改后再发送到Server req.send(data); &#125;); req.on(&apos;message&apos;, (data) =&gt; &#123; // 在script的Console打印出客户端发送的数据 console.log(&apos;Sent: &apos;, data); // 可以修改后再发送到Server res.send(data); &#125;);&#125;; whistle规则配置同上 更多关于whistle.script的使用详见官网：https://github.com/whistle-plugins/whistle.script]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器内核、渲染引擎、JS引擎]]></title>
    <url>%2F2022%2F04%2F26%2F%E5%89%8D%E7%AB%AF%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95%E2%80%94%E2%80%94Xcode%2F</url>
    <content type="text"><![CDATA[一、下载安装 App Store可以进行下载 安装 1234$ xcode-select --install$ xcode-select -p// 显示以下信息即是成功安装 /Applications/Xcode.app/Contents/Developer 注意安装时出现错误 12345xcode-select -pxcode-select: error: command line tools are already installed, use &quot;Software Update&quot; to install updates// 解决$ rm -rf /Library/Developer/CommandLineTools$ xcode-select --install// 如果还是报错，加上sudo 二、ios模拟器 列出可用的 iOS 模拟器 1$ xcrun instruments -s 安装更多版本模拟器 Simulator 默认只有最新的 iOS 版本的模拟器，如果你需要在老版本的 iOS 上调试，可以这样安装更多版本。 运行Xcode Window -&gt; Devices and Simulator -&gt; Simulator 点击左下角的 + 可以添加其它型号的机器 OS version -&gt; Download more simulator runtime 可以下载其他版本的iOS系统 启动模拟器 12$ xcrun instruments -w XXX// 如 xcrun instruments -w &quot;iPhone 11 (13.6)&quot; 三、安装shopee app 下载需要安装的app压缩包 解压后直接拖入模拟器即可安装 登录时不要打开proxifier，不然会一直pending 四、安装proxifier，配置代理 下载proxifier 安装whistle，运行w2 start启动 运行proxifier，配置 点击Proxies，添加一条 Action 规则代理到本地8899端口 然后点击Rules，新建一个规则，把以下内容添加到 Applications 1Simulator; &quot;Xcode Server Builder”; &quot;MobileSafari”; “com.apple.WebKit.Networking”;k12;vpn;ShopeeSG; 五、安装并信任证书我们开发的都是https页面，需要在配置好代理后，下载安装证书 iphone模拟器里用safari访问127.0.0.1:8899，然后在https那里下载安装证书 模拟器Settings -&gt; General -&gt; Profile, 点击证书进入下载 模拟器Settings -&gt; General -&gt; About -&gt; Certificate Trust Settings, 打开whistle证书信任按钮进行信任 相应安装包和代理配置可参考：whistle代理xcode iphone模拟器调试]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[E2E测试]]></title>
    <url>%2F2022%2F02%2F15%2F%E5%89%8D%E7%AB%AF%2FE2E%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[E2E (end-to-end) E2E测试就是end to end testing，即端到端测试。 它模仿用户，从某个入口开始，逐步执行操作，直到完成某项工作。 E2E 测试并没有那么强调要覆盖全部使用场景，它关注的是一个完整的操作链是否能够完成。对于 Web 前端来说，还关注 界面布局、内容信息是否符合预期。 不管逻辑使用什么框架什么逻辑写的，只想知道浏览器上我要的交互效果，ui展示效果是不是正确的，功能使用上是不是正确的，那么这就叫E2E测试。 cypresscypress是一款开箱即用,可以跑在Chrome浏览器上的测试工具。可以利用Cypress来模拟用户操作了，一方面可以测试代码是否正确，并且还能看到ui相应变化是否符合预期。 安装1$ npm install cypress --save-dev --registry=https://registry.npm.taobao.org 使用可以只写cypress需要访问的服务地址。123456789101112// cypress.json&#123; &quot;baseUrl&quot;: &quot;http://localhost:8000&quot;, #测试访问的路由地址 &quot;reporter&quot;: &quot;junit&quot;, #报告类型 &quot;reporterOptions&quot;: &#123; &quot;mochaFile&quot;: &quot;results/test-[hash].xml&quot;, #输出的文件 &quot;toConsole&quot;: true #是否输出的命令行 &#125;, &quot;viewportHeight&quot;: 800, # viewPort也就是预览窗的高度 &quot;viewportWidth&quot;: 1600 # viewPort也就是预览窗的宽度&#125; 通过cypress open本地打开测试窗口 1$ cypress open 点击右上角的运行所有集成化测试，或是点击单个测试用例单独测试 目录结构123456789101112├── fixtures # mock数据的存储目录，这里存放了所有mock的json文件│ ├── orders.json│ ├── panicBuyings.json│ └── routers.json├── integration # 测试用例代码目录│ ├── orderManagement.spec.js│ └── panicBuyingManagement.spec.js├── plugins # 插件目录│ └── index.js└── support ├── commands.js └── index.js 代码编写模拟用户操作123456789101112131415161718describe(&apos;测试抢购订单管理&apos;, () =&gt; &#123; beforeEach(() =&gt; &#123; #每个测试用例调用之前的操作 const mock = Cypress.env(&apos;MOCK&apos;) || &apos;false&apos;; # 自定义环境变量，运行时传递的话需要指定CYPRESS_前缀，这里使用是CYPRESS_MOCK=true cypress open cy.server(); # 如果需要mock接口的话，必须要运行server if (mock === true) &#123; cy.intercept(&apos;GET&apos;, &apos;/panic-buying/manager/orders*&apos;, &#123; fixture: &apos;orders.json&apos; &#125;).as( &apos;getOrders&apos;, ); # 拦截/panic-buying/manager/order*路由，并指定返回数据使用orders.json，定义这个接口是getOrders函数，用于后面测试使用。 &#125; else &#123; cy.intercept(&apos;GET&apos;, &apos;/panic-buying/manager/orders*&apos;).as(&apos;getOrders&apos;); &#125; &#125;); it(&apos;测试订单列表搜索&apos;, () =&gt; &#123; cy.visit(&apos;/#/rush-order/list&apos;); #访问页面路径 cy.wait(&apos;@getOrders&apos;).its(&apos;response.statusCode&apos;).should(&apos;be.oneOf&apos;, [200, 304]); # 等待getOrders函数，也就是接口返回并判断返回状态是200或是304中的一个。 cy.wait(1000); # 显示的等待1秒 &#125;);&#125;); API更多api操作参考：Commands 测试套件和用例 describe(): 代表测试套件，里面可以设定，一个测试套件可以不包括任何钩子函数（Hook），但必须包含至少一条测试用例 it() ，能嵌套子测试套件。 context(): 是 describe() 的别名，其行为方式是一致的，可以直接用 context() 代替 describe()。 it(): 代表一条测试用例。 …… 钩子函数 before(): 运行 cypress via cypress open 时，打开项目时将触发该事件。每次 cypress run 执行时都会触发该事件，会在第一个用例之前运行。 after()：会在跑完所有的用例之后运行。 beforeEach()：会在每一个用例前运行。 afterEach()：会在每一个用例结束后运行。 …… dom节点 get(): 用来在 DOM 树中查找 DOM 元素，get方法可以像jquery一样通过selector查找到对应的dom。 children()：获取一组 DOM 元素中每个 DOM 元素的子元素。 parent()：获取一组 DOM 元素的父 DOM 元素。 siblings()：获取兄弟 DOM 元素等。 trigger(): 在 DOM 元素上触发事件。 …… 123456789101112131415161718192021// 触发dom的mouseover事件dom.trigger(&apos;mouseover&apos;)// 语法使用示例// eventName（string）event 在DOM元素上要触发的的名称。.trigger(eventName)// position（string）// 应该触发事件的位置。该center位置是默认位置。// 有效的位置topLeft，top，topRight，left，center，right，bottomLeft，bottom，和bottomRight。.trigger(eventName, position)// options: 传递选项对象以更改的默认行为.trigger(eventName, options)// x（number）: 从元素左侧到触发事件的距离（单位px）。// y（number）: 从元素顶部到触发事件的距离（单位px）。.trigger(eventName, x, y).trigger(eventName, position, options).trigger(eventName, x, y, options) 网络接口 intercept: 在网络层管理 HTTP 请求的行为 1234cy.intercept(url, staticResponse)cy.intercept(method, url, staticResponse)cy.intercept(routeMatcher, staticResponse)cy.intercept(url, routeMatcher, staticResponse) Actions行为事件ui自动化操作页面上的元素，常用的方法输入如文本，点击元素，清空文本，点击按钮。还有一些特殊的checkbox,radio,滚动条等。cypress都可以api操作： type(): 往输入框输入文本元素。 focus(): 聚焦DOM元素。 clear(): 清空DOM元素。 rightclick(): 右击 DOM 元素 click()：点击 DOM 元素 select(): select 选项框 进阶有时候一个项目往往十分庞大，并不是所有组件都需要进行E2E测试，因此可以把需要进行测试的组件单独拿出来，本地部署一下，进行测试。 123456├── cypress # cypress目录│ ├── fixtures│ ├── integration│ ├── ...│ └── plugins├── e2e # 需要进行测试的组件代码 单独设置一个小项目，把需要进行测试的组件引进来，组成一个页面，对此页面进行测试。因此在开始测试前，需要先把这个页面跑起来，再开始测试。 参考 前端E2E测试框架 cypress了解一下 UI自动化测试框架Cypress介绍和使用 Cypress自动化测试入门使用]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[whistle插件：whistle.script]]></title>
    <url>%2F2021%2F02%2F20%2F%E5%89%8D%E7%AB%AF%2Fwhistle%E6%8F%92%E4%BB%B6%EF%BC%9Awhistle.script%2F</url>
    <content type="text"><![CDATA[whistle.scriptwhistle.script为whistle的一个扩展脚本插件，可以直接在界面上引用全局安装的Node模块及Node的内容模块编写脚本操作请求及其响应，所有正常Node程序可以实现的功能，都可以通过该插件实现，包括： HTTP[s]: 动态设置whistle规则 拦截请求响应 控制请求响应速度 修改请求url、请求方法、请求头、请求内容 修改响应状态码、响应头、响应内容 在插件界面的Console上显示脚本程序 console.xxx 的内容，如果可以打印响应的内容或调试信息等 WebSocket: 动态设置whistle规则 拦截请求响应 修改发送或收到的数据 直接向WebSocket客户端或服务端发送数据 在插件界面的Console上显示脚本程序 console.xxx 的内容，如果可以打印发送和接收到的数据或调试信息等，从而通过该插件可以直接查看WebSocket的数据 Tunnel: 基本功能同WebSocket，可以用来直接操作Socket请求，如Protobuf协议的请求等 安装123npm install -g whistle.script# Mac、Linux用户可能需要加sudosudo npm install -g whistle.script 安装插件后要重启whistle才可以打开插件，否则unknown 使用打开script插件的界面，创建一个名字为 test 的脚本: 可以通过 Plugins-&gt;Home-&gt;script打开或右键并选择 在新标签页中打开 或者直接访问 http://local.whistlejs.com/plugin.script 设置规则 设置HTTP或HTTPs请求的whistle规则(操作HTTPs需要开启HTTPs拦截) 在界面中的test 脚本输入 1234567exports.handleRequestRules = (ctx) =&gt; &#123; // ctx.fullUrl 可以获取请求url // ctx.headers 可以获取请求头 // ctx.options 里面包含一些特殊的请求头字段，分别可以获取一些额外信息，如请求方法、设置的规则等 ctx.rules = [&apos;www.qq.com file://&#123;test.html&#125;&apos;]; ctx.values = &#123; &apos;test.html&apos;: &apos;Hello world.&apos; &#125;;&#125;; 如果里面包含一些异步方法可以采用generator函数或async函数，即：exports.handleRequestRules = function* (ctx) {} 或 exports.handleRequestRules = async () =&gt; {} 在whistle的Rules配置界面上输入规则: 1whistle.script://test www.ifeng.com www.qq.com www.baidu.com echo.websocket.org 如果需要通过配置给脚本传递一些额外参数，可以如下配置(注意中间不能有空格): 1whistle.script://test(a,b,c) www.ifeng.com www.qq.com www.baidu.com echo.websocket.org 可以在脚本中通过 process.args 获取: 12345exports.handleRequestRules = (ctx) =&gt; &#123; console.log(process.args); // output: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] ctx.rules = [&apos;www.qq.com file://&#123;test.html&#125;&apos;]; ctx.values = &#123; &apos;test.html&apos;: &apos;Hello world.&apos; &#125;; &#125;; 设置WebSocket请求的规则(需要开启HTTPs拦截): 123456exports.handleWebSocketRules = (ctx) =&gt; &#123; // ctx.fullUrl 可以获取请求url // ctx.headers 可以获取请求头 // ctx.options 里面包含一些特殊的请求头字段，分别可以获取一些额外信息，如请求方法、设置的规则等 this.rules = &apos;127.0.0.1 echo.websocket.org&apos;; &#125;; 接下来的操作同上。 设置Tunnel请求的规则(要测试可以暂时关闭HTTPs拦截): 123456exports.handleTunnel = (ctx) =&gt; &#123; // ctx.fullUrl 可以获取请求url // ctx.headers 可以获取请求头 // ctx.options 里面包含一些特殊的请求头字段，分别可以获取一些额外信息，如请求方法、设置的规则等 this.rules = &apos;127.0.0.1 www.baidu.com&apos;; &#125;; 接下来的操作同上。 操作请求 操作HTTP或HTTPs请求(操作HTTPs需要开启HTTPs拦截) 12345678910111213141516171819202122232425262728293031exports.handleRequest = function* (ctx, next) &#123; // ctx.fullUrl 可以获取请求url // ctx.headers 可以获取请求头 // ctx.options 里面包含一些特殊的请求头字段，分别可以获取一些额外信息，如请设置的规则等 // ctx.method 获取和设置请求方法 // const reqBody = yield ctx.getReqBody(); 获取请求body的Buffer数据，如果没有数据返回null // const reqText = yield ctx.getReqText(); 获取请求body的文本，如果没有返回&apos;&apos; // const formData = yield ctx.getReqForm(); 获取表单对象，如果不是表单，返回空对象&#123;&#125; // console.log(ctx.method, ctx.headers, reqBody); // ctx.req.body = String| Buffer | Stream | null，修改请求的内容 // 只有执行next方法后才可以把正常的请求发送出去 // 如果需要自定义请求，可以通过全局的request方法操作 // console.log(request); // next方法可以设置next(&#123; host, port &#125;); const &#123; statusCode, headers &#125; = yield next(); console.log(ctx.fullUrl, statusCode, headers); // const resBody = yield ctx.getResBody(); // const resText = yield ctx.getResText(); // ctx.status = 404; 修改响应状态码 // ctx.set(headers); 批量修改响应头 // ctx.set(&apos;x-test&apos;, &apos;abc&apos;); 修改响应头 // ctx.body = String| Buffer | Stream | null; 修改响应内容 &#125;; // 如果Node &gt;= 7.6，可以采用async await的方式 exports.handleRequest = async (ctx, next) =&gt; &#123; // do sth // next方法可以设置next(&#123; host, port &#125;); const &#123; statusCode, headers &#125; = await next(); // do sth &#125;; 在whistle的Rules配置界面上输入规则: 12345# 这里不能用whistle.script，否则请求不会转发到handleRequest# whistle.script只会执行handleXxxRules# 你也可以通过在handleXxxRules里面设置 script://test(a,b,c)，实现转发script://test www.ifeng.com www.qq.com www.baidu.com echo.websocket.org 需要在配置中带上参数，可以参考上面的规则设置 操作WebSocket请求(需要开启HTTPs拦截) 12345678910111213// Node &lt; 7.6可以改用genrator和yield exports.handleWebSocket = async (req, connect) =&gt; &#123; // connect方法可以设置connect(&#123; host, port &#125;); const res = await connect(); res.on(&apos;message&apos;, (data) =&gt; &#123; console.log(&apos;Received: &apos;, data); req.send(data); &#125;); req.on(&apos;message&apos;, (data) =&gt; &#123; console.log(&apos;Sent: &apos;, data); res.send(data); &#125;); &#125;; whistle规则配置同上 操作Tunnel请求 1234567// Node &gt;= 7.6可以改用async和await exports.handleTunnel = function* (req, connect) &#123; // connect方法可以设置connect(&#123; host, port &#125;); const res = yield connect(); req.pipe(res).pipe(req); // 也可以参考上面操作WebSocket，自己监听data和write方法处理，这样就可以直接修改和打印内容 &#125;; whistle规则配置同上 参考链接whistle.script]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器内核、渲染引擎、JS引擎]]></title>
    <url>%2F2021%2F02%2F20%2F%E5%89%8D%E7%AB%AF%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E3%80%81%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E3%80%81JS%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[定义 浏览器内核分成两部分：渲染引擎和JS引擎。 由于JS引擎越来越独立，浏览器内核 就倾向于 单指 渲染引擎。 渲染引擎是一种对HTML文档进行解析并将其显示在页面上的工具。（说白了，就是按照HTML代码在界面上绘制各种控件图形） 常见引擎渲染引擎 firefox使用gecko引擎 IE使用Trident引擎 2015年微软推出自己新的浏览器，原名叫斯巴达，后改名edge,使用edge引擎 opera最早使用Presto引擎，后来弃用 chrome\safari\opera使用webkit引擎 13年chrome和opera开始使用Blink引擎 JS 引擎 老版本IE使用Jscript引擎 IE9之后使用Chakra引擎 edge浏览器仍然使用Chakra引擎 firefox使用monkey系列引擎 safari使用的SquirrelFish系列引擎 Opera使用Carakan引擎 chrome使用V8引擎。nodeJs其实就是封装了V8引擎 参考链接浏览器内核、渲染引擎、JS引擎简介]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调试神器whistle的安装使用]]></title>
    <url>%2F2021%2F02%2F20%2F%E5%89%8D%E7%AB%AF%2F%E8%B0%83%E8%AF%95%E7%A5%9E%E5%99%A8whistle%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[搭建环境准备安装nodewhistle支持v0.10.0以上版本的Node，为获取更好的性能，推荐安装最新版本的Node。 123// 未安装的去官网进行安装// 安装后通过命令行可查看版本$ node -v 安装whistle对于全局安装，Mac或Linux的非root用户需要在命令行前面加sudo。1$ npm install -g whistle whistle安装完成后，执行命令 whistle help 或 w2 help，查看whistle的帮助信息。 12// 如果能正常输出whistle的帮助信息，表示whistle已安装成功$ w2 help 使用whistle123// 启动whistle// 不设置端口，默认8899$ w2 start -p 8899 Note: 如果要防止其他人访问配置页面，可以在启动时加上登录用户名和密码 -n yourusername -w yourpassword。 12// 重启whsitle$ w2 restart 12// 停止whistle$ w2 stop 123// 调试模式启动whistle// 主要用于查看whistle的异常及插件开发$ w2 run 配置代理配置信息 代理服务器：127.0.0.1 默认端口：8899，若被占用，可启动时设置端口 配置方式一：pc端官网推荐配置浏览器代理，推荐安装浏览器代理插件SwitchyOmega，就按官网的来吧，其他配置方式可参考官网 由于常用chrome，以chrome为例 安装根证书 参考网站：安装根证书 安装证书后就可以抓取https的包了 SwitchyOmega配置进入SwitchyOmega，点击安装扩展后，页面会自动跳转到 SwitchyOmega 的配置页，随后便有新手教程 点击左侧“新建情景模式…”，弹框提示“情景模式名称”，你可以输入“whistle” 类型为代理服务器，点击创建 修改代理服务器参数，代理协议为HTTP，代理服务器为127.0.0.1，代理端口为8899 “不代理的地址列表” 的输入框里的所有文本都删掉，因为里面的 host 在本地开发很大概率会用到 点击左侧“应用选项” 点击chrmoe右上角的圆圈，切换为whistle（一定是切换后才可以抓包） 浏览器进入local.whistlejs.com，可以打开界面，证明配置成功，可以开始抓包了 配置方式二：移动端移动端需要在设置中配置当前Wi-Fi的代理，以 iOS 为例： 注意 安装插件后要重启whistle才可以打开插件，否则unknown 参考链接whistle]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode：阶乘后的零]]></title>
    <url>%2F2020%2F10%2F16%2F%E7%AE%97%E6%B3%95%2FLeetCode%EF%BC%9A%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[阶乘后的零给定一个整数 n，返回 n! 结果尾数中零的数量。 测试用例121. 3 // 02. 6 // 1 解法一思路 3! = 3 2 1 6! = 6 5 4 3 2 * 1 10! = （5 2） 8 7 6 5 4 3 2 * 1 每一个5都可以找到偶数配对，就相当于一个5可以产生一个0。 找出阶乘中含有多少个因子5就可以了 算法123456789101112131415/** * @param &#123;number&#125; n * @return &#123;number&#125; */var trailingZeroes = function(n) &#123; let count = 0; for(let i = 5; i &lt;= n; i++)&#123; let temp = i; while(temp % 5 === 0) &#123; count ++; temp /= 5 &#125; &#125; return count;&#125;; 解法二思路 5 的因子一定是每隔 5 个数出现一次 25 = 5 5, 125 = 5 5 * 5 每隔 5 个数，出现一个 5，每隔 25 个数，出现 2 个 5，每隔 125 个数，出现 3 个 5… 因此找出现了多少次五个数，当这个次数大于5时，证明n大于25，有多一个5，以此类推，125同理。 count = n / 5 + n / 25 + n / 125 … 算法123456789101112/** * @param &#123;number&#125; n * @return &#123;number&#125; */var trailingZeroes = function(n) &#123; let count = 0; while (n &gt; 0) &#123; n = Math.floor(n / 5); count += n; &#125; return count;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：n数之和]]></title>
    <url>%2F2020%2F08%2F10%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9An%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[两数之和为0题目给定一个不重复的数字数组，找出该数组中两个数之和等于0的所有情况。 测试用例121. [1,2,3,-1] // [[1,-1]]2. [1,2,3,-3,-1] // [[1,1],[3,-3]] 解法思路 数组长度少于2则直接返回 取数组首元素，与剩余元素比较是否相加为0，若为0取该值，拼接为数组，否则undefined 递归剩余元素，将得到的返回值拼接，对于undefined的值不拼接 算法123456789101112131415161718192021222324252627/** * @param &#123;array&#125; arr * @return &#123;array&#125; */var addUpToZero = function (arr) &#123; if(arr.length &lt; 2) &#123; return; &#125; var left = arr.splice(0,1)[0]; var right, res; for(let i in arr) &#123; if(left + arr[i] === 0) &#123; right = arr.splice(i,1)[0]; &#125; &#125; if(right) &#123; res = [left, right]; &#125; var next = test(arr); if(res &amp;&amp; next)&#123; return [res].concat(next); &#125; else if (res) &#123; return [res]; &#125; else if (next) &#123; return next; &#125;&#125; 两数之和为target题目给定一个已按照升序排列的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1必须小于index2。 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 测试用例11. [2,7,11,15],9 // [1,2] 解法思路 双指针法，一个指向头，一个指向尾 判断和是否为target，是则返回 否则，若sum小于target，则指向头的指针往前移动；若大于，则尾部移动 算法123456789101112131415161718/** * @param &#123;number[]&#125; numbers * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function(numbers, target) &#123; let i = 0, j = numbers.length -1; while(i &lt; j) &#123; const sum = numbers[i] + numbers[j]; if (sum === target) &#123; return [i + 1, j + 1]; &#125; else if (sum &lt; target) &#123; i++; &#125; else &#123; j--; &#125; &#125;&#125;; n数之和为target题目给定一个无序数组，判断该数组中能否实现n个数之和等于target的情况。 测试用例11. [1,2,3,4],2,7 // true 解法思路算法12345678910111213141516 function getResult(arr,n,target)&#123; if(n==0&amp;&amp;target==0)&#123; return true; &#125; if(n&lt;0)&#123; return false; &#125; if(n&gt;0)&#123; for(var i in arr)&#123; var temp = arr.slice(i+1,arr.length); return getResult(temp,n-1,target-arr[i]) || getResult(temp,n,target); &#125; &#125;&#125;console.log(getResult([1,2,3,4],2,7)); //true]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[whistle：利用whistle mock 数据]]></title>
    <url>%2F2020%2F07%2F17%2F%E5%89%8D%E7%AB%AF%2Fwhistle%EF%BC%9A%E5%88%A9%E7%94%A8whistle%20mock%20%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[vasevase 是 whistle 提供了一个强大的 mock 数据的插件，强大之处是可以结合 js 语句 + mock 语法去生成数据。 安装1$ npm i -g whistle.vase 使用在whistle界面的“Plugins”菜单中可以打开 vase 的界面 mock 语法在vase界面新建配置 “mock_json_demo”，并选择模板为 mock，输入 12345678910// mock 语法&#123; &quot;list|5&quot;: [ &#123; &quot;name&quot;: &quot;@string&quot;, &quot;avatar&quot;: &quot;http://lorempixel.com/100/100/&quot;, &quot;id|+1&quot;: 10000 &#125; ]&#125; 然后在“Rules”中配置一条规则 1http://mock.local/data.json vase://mock_json_demo 打开测试地址 http://mock.local/data.json ，即可看到模拟的数据。 js 语法在vase界面新建配置 “json_engine_script”，并选择模板为 script，输入 1234567891011121314// js 语法var json = merge(&#123; page: req.query.pi, // 取url查询参数的分页字段，加到要返回的数据里，达到模拟分页数据的效果 total: 60&#125;, render(&apos;mock_json_demo&apos;, null, &apos;mock&apos;)); // render 可以渲染上文提到名为“mock_json_demo”的数据模板，返回一个json if (req.query.callback) &#123; // 如果查询参数带了callback，则返回jsonp out(header(&apos;content-type&apos;, &apos;application/javascript; charset=utf8&apos;)); var json_text = join([req.query.callback + &apos;(&apos;, json, &apos;)&apos;]); // join是内置方法，可合并一组数据 out(json_text); // 向body输出数据&#125; else &#123; // 没有callback则返回json out(header(&apos;content-type&apos;, &apos;application/json; charset=utf8&apos;)); out(json);&#125; 然后在“Rules”中配置一条规则 1http://mock.local/data.json vase://json_engine_script 打开 http://mock.local/data.json?callback=cb&amp;pi=1 ，即可看到模拟的数据，可尝试改变、删除 callback、pi 参数，会发现返回的数据会随之改变。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全：XSS和CSRF]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%85%B6%E4%BB%96%2F%E5%AE%89%E5%85%A8%EF%BC%9AXSS%E5%92%8CCSRF%2F</url>
    <content type="text"><![CDATA[XSS攻击（跨站脚本攻击）原理恶意攻击者往web页面里插入恶意可执行网页脚本代码，当用户浏览该页面时，嵌入其中web里面的脚本代码会被执行，从而达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。 分类 存储型XSS恶意代码存储在数据库中 反射型XSS恶意代码存储在url中 DOM型XSS取出和执行恶意代码都是浏览器端完成防御开启CSP建立白名单，明确告诉浏览器哪些外部资源可以加载和执行。 设置http header中的Content-Security-Policy 设置meta标签1&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt; 输入输出过滤前端负责，后端也要做相同的过滤检查，因为攻击者完全可以绕过正常的输入流程，直接利用相关接口向服务器发送设置。 转义字符转义输入输出的内容，对于引号、尖括号、斜杠进行转义。 cookieweb应用程序在设置cookie时，将其属性设为HttpOnly，这样设置的cookie，js就无法进行读写，就可以预防XSS攻击窃取用户cookie，保护用户cookie信息。 CSRF攻击（跨站请求伪造）原理攻击者通过一些技术手段欺骗用户的浏览器去訪问一个自己以前认证过的站点并运行一些操作。 利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。可以这么理解：攻击者盗用了你的身份，以你的名义发送恶意请求。 一般发起攻击的是第三方网站。是利用用户的登录凭证，冒用用户信息，不能获取用户的数据。 CSRF攻击是源于WEB的隐式身份验证机制。WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的。 分类 get类型可以将get请求嵌入img标签，打开页面自动发送请求。 post类型可以利用自动提交的form表单，访问页面就会自动提交。 链接型需要用户点击链接才会触发。防御post尽量使用post请求，避免get请求。 cookie对cookie设置SameSite属性。该属性表示cookie不随跨域请求发送，可以很大程度减少csrf攻击。 token 用户访问某个表单页面。 服务端生成一个Token，放在用户的Session或者浏览器的Cookie中。 在页面表单附带上Token参数。 用户发送请求时以参数的形式带上本次页面中生成的token，服务端验证表单中的Token是否与用户Session（或Cookies）中的Token一致，一致为合法请求，不是则非法请求。 仅仅用来防御csrf攻击，当加上xss攻击时，无用 验证码xss和csrf 通常来说csrf是由xss引起的 xss是代码注入问题，csrf是http问题 同源策略同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。所以a.com下的js脚本采用ajax读取b.com里面的文件数据是会报错的。 不受同源策略限制的： 页面中的链接，重定向以及表单提交是不会受到同源策略限制的。 跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的script标签的src属性、img标签、link标签、iframe标签等。 通过标签的方式发起的请求不受同源策略的限制。且发送请求时浏览器会携带对应的cookie。 SQL注入原理通过传入一些特殊字符，从而达到欺骗服务器执行恶意的SQL命令的目的。 如输入特殊的用户名 123456//理想中的输入：admin passwordSELECT * FROM user WHERE username=&apos;admin&apos; AND psw=&apos;password&apos;//特殊用户名：admin&apos; --SELECT * FROM user WHERE username=&apos;admin&apos; --&apos; AND psw=&apos;xxxx&apos;//在SQL中，--是注释后面的内容的意思 防御 严格限制web应用的数据库的操作权限。 后端代码检查输入的数据是否符合预期。 对特殊字符进行转义处理。]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全：cookie和session]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%85%B6%E4%BB%96%2F%E5%AE%89%E5%85%A8%EF%BC%9Acookie%E5%92%8Csession%2F</url>
    <content type="text"><![CDATA[前言 会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。 Cookie通过在客户端记录信息确定用户身份。 Session通过在服务器端记录信息确定用户身份。 cookie在程序中，会话跟踪是很重要的事情。理论上，一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。 Web应用程序是使用HTTP协议传输数据的。==HTTP协议是无状态的协议==。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。 什么是cookiecookie其实是存储在浏览器中的纯文本，是服务器发送出来存储在浏览器上的一组组键值对，浏览器的安装目录下会专门有一个cookie文件夹来存放各个域下设置的cookie。 cookie怎么工作 存储cookie是浏览器提供的功能。 若客户端首次请求服务器，浏览器会添加请求头中的 cookie字段为{}，把请求的网址连同该Cookie一同提交给服务器。如果服务器需要记录该用户状态，就向客户端浏览器返回Cookie，客户端浏览器会把Cookie保存起来。 当网页要再次发http请求时，浏览器会先检查是否有相应的 cookie，有则自动把所有这个服务器Cookie添加在 request header中的 cookie字段中，把请求的网址连同该Cookie一同提交给服务器。这些是浏览器自动帮我们做的，而且每一次 http请求浏览器都会自动帮我们做。 服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容 cookie的存放有大小限制，不可以超过4kb, 每一个域名下的cookie数量最多是20个 获取cookiedocument.cookie，只能获取非HttpOnly类型的cookie。 打印出的结果是一个字符串类型，因为 cookie本身就是存储在浏览器中的字符串。但这个字符串是有格式的，由键值对 key=value构成，键值对之间由一个 分号和一个 空格隔开。 1key=value; key=value Cookie的不可跨域名性受同源策略限制，跨域的ajax请求默认不携带cookie，那为什么还会有csrf攻击呢？ 12由于script、img、iframe的src都不受同源策略影响，可以利用此来实现跨域请求，来实施攻击。浏览器会依据加载的域名附带上对应域名的cookie 例如，a.com是一个银行网站，用户在此网站登录且生成了授权的cookie，此时浏览器保存了这个cookie。随后访问 b.com，在这个网站中伪造一个请求a网站的请求，如转账、删除操作等，利用script、img、iframe来加载a网站的地址，浏览器就会携带上a网站此登陆用户的授权cookie信息，这样就构成了csrf攻击。 cookie的属性 属性名 数据类型 描述 name String 该Cookie的名称。Cookie一旦创建，名称便不可更改 value Object 该Cookie的值。如果值为Unicode字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码 maxAge int 该Cookie失效的时间，单位秒。如果为正数，则该Cookie在maxAge秒之后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。如果为0，表示删除该Cookie。默认为–1 secure boolean 该Cookie是否仅被使用安全协议传输。安全协议。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false path String 该Cookie的使用路径。如果设置为“/sessionWeb/”，则只有contextPath为“/sessionWeb”的程序可以访问该Cookie。如果设置为“/”，则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为“/” domain String 可以访问该Cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.” comment String 该Cookie的用处说明。浏览器显示Cookie信息的时候显示该说明 version int 该Cookie使用的版本号。0表示遵循Netscape的Cookie规范，1表示遵循W3C的RFC 2109规范 cookie的修改和删除 服务器可以对cookie进行操作，浏览器只能对非HttpOnly类型的cookie进行操作（为了预防xss攻击）。 Cookie并不提供修改、删除操作。 如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。 如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。注意是0而不是负数。负数代表其他的意义。 注意：修改、删除Cookie时，新建的Cookie除value、maxAge之外的所有属性，例如name、path、domain等，都要与原Cookie完全一样。否则，浏览器将视为两个不同的Cookie不予覆盖，导致修改、删除失败。 session除了使用Cookie，Web应用程序中还经常使用Session来记录客户端状态。Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。 session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。 什么是session 客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。 客户端浏览器再次访问时只需要从该session中查找该客户的状态就可以了。 session对象是在客户端第一次请求服务器的时候创建的。session也是一种key-value的属性对 如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。 session的生命周期session保存在服务器端。为了获得更高的存取速度，服务器一般把session放在内存里。每个用户都会有一个独立的session。如果session内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。因此，session里的信息应该尽量精简。 session在用户第一次访问服务器的时候自动创建。需要注意只有访问JSP、Servlet等程序时才会创建session，只访问HTML、IMAGE等静态资源并不会创建session。如果尚未生成session，也可以使用request.getSession(true)强制生成session。 session生成后，只要用户继续访问，服务器就会更新session的最后访问时间，并维护该session。用户每访问服务器一次，无论是否读写session，服务器都认为该用户的Session“活跃（active）”了一次。 为防止内存溢出，服务器会把长时间内没有活跃的session从内存删除。这个时间就是session的超时时间。如果超过了超时时间没访问过服务器，session就自动失效了。tomcat默认失效时间为20分钟。 session对浏览器的要求虽然session保存在服务器，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为session需要使用Cookie作为识别标志。HTTP协议是无状态的，session不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为JSESSIONID的Cookie，它的值为该session的id（也就是HttpSession.getId()的返回值）。session依据该Cookie来识别是否为同一用户。 如果客户端浏览器将Cookie功能禁用，或者不支持Cookie怎么办？例如，绝大多数的手机浏览器都不支持Cookie。Java Web提供了另一种解决方案：URL地址重写。 URL地址重写URL地址重写是对客户端不支持Cookie的解决方案。URL地址重写的原理是将该用户session的id信息重写到URL地址中。服务器能够解析重写后的URL获取session的id。这样即使客户端不支持Cookie，也可以使用session来记录用户状态。 两者区别 cookie数据存放在客户的浏览器上，session数据放在服务器上的，但名为JSESSIONID的Cookie（值为该Session的id）是放在客户端的。 cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。 设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话。 session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。(Session对象没有对存储的数据量的限制，其中可以保存更为复杂的数据类型) 两者最大的区别在于生存周期，session是IE启动到IE关闭.(浏览器页面一关 ,session就消失了)，cookie是预先设置的生存周期，或永久的保存于本地的文件。]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web页面性能优化]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%89%8D%E7%AB%AF%2Fweb%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[请求和响应减少http请求。一个完整的请求都需要经过 DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个 “漫长” 而复杂的过程。资源上由于每个请求都需要携带数据，因此每个请求都需要占用带宽。 使用CDN加速（缓存）。CDN（内容发布网络）是一组分布在多个不同地理位置的Web服务器，用于更加有效地向用户发布内容。其本质上是一个缓存，而且将数据（js、css、image等静态资源）缓存在离用户最近的地方，使用户以最快速度获取数据，即所谓网络访问第一跳。 使用内容传递网络(CDN)提供 JavaScript 文件,CDN 不仅可以提高性能,它还可以为你管理压缩和缓存。 当用户发起访问时，他的访问请求被只能dns定位到最近的缓存服务器，当服务器中没有缓存时，就会去请求最近的服务器中的资源。 利用浏览器缓存通过设置 HTTP 响应报文头使 JavaScript 文件可缓存,将网络资源存储到本地，下次请求资源时，如果命中可直接在本地获取，不需要重新向服务器请求资源 避免重定向。当页面发生了重定向，就会延迟整个HTML文档的传输。在HTML文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载。 重定向和404将浪费加载请求。 HTML合理使用内联。脚本和样式，应按需选择内联或者外链。对于访问少、样式和脚本复用少的页面，可以考虑使用内联样式从而减少 HTTP 请求。 但如果页面访问频繁，样式脚本在多个页面经常复用，使用外链则是最优选择。 这样浏览器可以缓存它们，下次加载时可以直接从缓存加载。 减少dom过多的DOM元素会影响渲染、加载、执行。除了精简页面结构外，还可以适时删除不必要的DOM元素（页面内已经不会再访问的元素），又或者可以懒加载（不一定会使用到的元素，如登录框）。 优化dom操作 使用事件委托来减少事件处理器的数量 减少重绘和回流 如果需要在 DOM操作时添加样式，尽量使用 增加 class 属性，而不是通过 style 一个一个地操作样式。 删除HTML的默认属性。js优化js。 将所有script标签放置在页面的底部,紧靠 body 关闭标签的上方。因为页面解析生成dom树时遇到script标签会停下去加载执行js。此法可以保证页面在脚本运行之前完成解析。 将脚本成组打包。页面的标签越少,页面的加载速度就越快,响应也更加迅速。不论外部脚本 文件还是内联代码都是如此。 由于浏览器渲染机制的设置，gui渲染线程和js引擎互斥，因此js的执行会阻塞dom的解析和渲染以及其他资源的加载。 css将样式表放在头部。css在head中通过link引入下载会阻塞页面的渲染，页面的渲染会等待css解析完生成cssom树，再结合dom树生成渲染树进行渲染。所以最好的做法是把css放在页面的最上面，让浏览器尽快下载css，减少首屏加载时间，避免白屏。 为了浏览器的渲染，能让页面显示的时候视觉上更好。避免某些情况，如：假设你放在页面最底部，则不会阻塞，用户打开页面时，有可能出现，页面先是显示一大堆文字或图片，自上而下，丝毫没有排版和样式可言。最后，页面又恢复所要的效果 由于gui渲染机制和js引擎互斥，因此css加载会阻塞js的加载，但是cssom和dom是并行的，css加载并不阻塞dom的解析，也不阻塞其他资源的加载，但两者需要互相配合生成渲染树，因此会阻塞dom的渲染。 优化css，避免css表达式。会导致效率低下。 资源延迟加载图片。不直接给src路径，而是在页面加载完成后用js操作src，减少了页面加载图片的时间。 懒加载在进入可视区域之后在进行请求资源 预加载在静态资源使用前先加载，在使用时可直接在缓存中获取]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器本地缓存]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%89%8D%E7%AB%AF%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[定义缓存是性能优化中简单高效的一种优化方式。 和本地存储不一样，浏览器缓存是浏览器请求网站留下的资源副本。 好处 减少带宽消耗 提升性能 缓解服务器压力 缓存位置 Service Worker Memory Cache Disk Cache Push Cache 缓存策略浏览器第一次向服务器发起请求拿到请求结果后，根据请求资源时返回的响应头来确定该不该缓存。 浏览器常见字段 Expires：告知客户端资源缓存失效的绝对时间。 Cache-Control：告知客户端或服务器如何处理缓存 max-age=xxx：表示缓存内容将在缓存时间的xxx秒后失效 no-cache：表示可以缓存，但每次用都要去向服务器验证缓存是否可用。 no-store：表示所有内容都不会缓存。 private：客户端可以缓存。 public：客户端和代理服务器都可以缓存。默认值。 Last-Modified：资源最后一次修改时间。 Etag：文件的特殊标识。用于文件内容对比，判断内容是否修改。 Cache-Control优先级高于Expires。 Etag优先级高于Last-Modified。 强缓存 根据本地缓存资源的header中的Expires和Cache-Control来判断是否命中强缓存。 如果命中强缓存则返回缓存的数据。 如果没有命中则进入协商缓存。 协商缓存 如果没有命中强缓存，浏览器会将本地缓存资源的header中的Last-Modified和Etag的值分别放入请求头的IF-Modified-Since和IF-None-Match字段中，向服务器发送请求，由服务器根据请求中的相关header信息来对比结果是否命中协商缓存。 若命中即资源未更新，则服务器返回新的响应header信息且返回的http状态为304，但是并不返回资源内容，它会显示一个Not Modified的字符串，来告知浏览器使用缓存。 否则返回最新的数据，并将新数据存入缓存。 总结当浏览器再次访问一个已经访问过的资源时，会 先判断是否存在缓存，再看是否命中强缓存，如果命中，就直接使用缓存了。 如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存。 如果命中协商缓存，服务器会返回 304。 告诉浏览器使用本地缓存。 否则，返回最新的资源。 拓展ctrl+F5和F5的区别F5只是刷新本地缓存，强缓存无效，协商缓存有效；ctrl+F5是强缓存与协商缓存均无效，重新向服务器请求。 禁止浏览器缓存方法 设置响应头 12//把Cache-Control设置为no-cache&lt;meta HTTP-EQUIV=&quot;Cache-Control&quot; CONTENT=&quot;no-cache&quot;&gt; 在访问的url后添加一个参数，可以是随机数或者时间戳。这样url时刻在变化，就要重新发送http请求]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器渲染机制]]></title>
    <url>%2F2020%2F05%2F14%2F%E5%89%8D%E7%AB%AF%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[进程和线程 进程时cpu资源分配的最小单位，是能拥有资源和独立运行的最小的单位。 线程是cpu调度的最小单位，是建立在进程基础上的一次程序运行单位。 对于操作系统来说，一个任务就是一个进程，一个进程至少有一个线程 浏览器的多进程架构 主进程负责浏览器界面的显示与交互。各个页面的管理,创建和销毁其他进程。网络的资源管理、下载等。 第三方插件进程每种类型的插件对应一个进程,仅当使用该插件时才创建。 GPU 进程最多只有一个,用于 3D 绘制等 渲染进程称为浏览器渲染进程或浏览器内核,内部是多线程的。主要负责页面渲染,脚本执行,事件处理等。 渲染进程浏览器的渲染进程是多线程的 GUI 渲染线程 负责渲染浏览器界面，解析 HTML、CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。 注意，==GUI 渲染线程与 JS 引擎线程是互斥的==，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。 JS 引擎线程 Javascript 引擎，也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎） JS 引擎线程负责解析 Javascript 脚本，运行代码。 JS 引擎一直等待着任务队列中任务的到来,然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序。 注意，==GUI 渲染线程与 JS 引擎线程是互斥的==，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。 事件触发线程 归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解,JS 引擎自己都忙不过来，需要浏览器另开线程协助） 当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程，如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理 注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行） 定时触发器线程 传说中的 setInterval 与 setTimeout 所在线程 浏览器定时计数器并不是由 JavaScript 引擎计数的，（因为 JavaScript 引擎是单线程的， 如果处于阻塞线程状态就会影响记计时的准确） 因此通过单独线程来计时并触发定时（计时完毕后,添加到事件队列中，等待 JS 引擎空闲后执行） 注意，W3C 在 HTML 标准中规定,规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。 异步 http 请求线程 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求。 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。 题目1. 为什么 Javascript 要是单线程的 ? 如果 JavaScript 是多线程的方式来操作这些 UI DOM,则可能出现 UI 操作的冲突。 如果 Javascript 是多线程的话,在多线程的交互下,处于 UI 中的 DOM 节点就可能成为一个临界资源, 假设存在两个线程同时操作一个 DOM,一个负责修改一个负责删除,那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。 当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性,Javascript 在最初就选择了单线程执行。 2. 为什么 JS 阻塞页面加载 ? 由于 JavaScript 是可操纵 DOM 的,如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了。 因此为了防止渲染出现不可预期的结果,浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系。 3. css 加载会造成阻塞吗 ？ CSS 加载不会阻塞 DOM 的解析，会阻塞 Dom 的渲染 DOM 和 CSSOM 通常是并行构建的,所以 CSS 加载不会阻塞 DOM 的解析。 然而,由于 渲染树 是依赖于 DOM树 和 CSSOM树 的,所以他必须等待到 CSSOM树 构建完成,也就是 CSS 资源加载完成(或者 CSS 资源加载失败)后,才能开始渲染。因此,CSS 加载会阻塞 Dom 的渲染。 css 会阻塞后面 js 的执行。 由于 GUI 渲染线程与 JavaScript 引擎为互斥的关系。因此,样式表会在后面的 js 执行前先加载执行完毕,所以css 会阻塞后面 js 的执行。 4. DOMContentLoaded 与 load 的区别 ? 当 DOMContentLoaded 事件触发时,仅当 DOM 解析完成后,不包括样式表,图片。 当文档中没有脚本时,浏览器解析完文档便能触发 DOMContentLoaded 事件。如果文档中包含脚本,则脚本会阻塞文档的解析,而脚本需要等 CSSOM 构建完成才能执行。在任何情况下,DOMContentLoaded 的触发不需要等待图片等其他资源加载完成。 当 onload 事件触发时,页面上所有的 DOM,样式表,脚本,图片等资源已经加载完毕。 DOMContentLoaded -&gt; load 5. defer 和 async 的区别 ? 没有 defer 或 async,浏览器会立即加载并执行指定的脚本,“立即”指的是在渲染该 script 标签之下的文档元素之前,也就是说不等待后续载入的文档元素,读到就加载并执行。 有 async,加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。 有 defer,加载后续文档元素的过程将和 script.js 的加载并行进行（异步）,但是 script.js 的执行要在所有元素解析完成之后,DOMContentLoaded 事件触发之前完成。 总结 defer 和 async 在网络读取（下载）这块儿是一样的,都是异步的（相较于 HTML 解析），差别在于脚本下载完之后何时执行,显然 defer 是最接近我们对于应用脚本加载和执行的要求的 关于 defer，它是按照加载顺序执行脚本的；async 则是乱序执行的，反正对它来说脚本的加载和执行是紧紧挨着的,所以不管你声明的顺序如何,只要它加载完了就会立刻执行 仔细想想,async 对于应用脚本的用处不大,因为它完全不考虑依赖（哪怕是最低级的顺序执行）,不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网：TCP]]></title>
    <url>%2F2020%2F05%2F14%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9ATCP%2F</url>
    <content type="text"><![CDATA[TCP和UDP 都是运输层协议 tcp有连接，可靠：数据包校验、对失序数据包重排序、丢弃重复数据、应答机制、超时重传、流量控制。 udp无连接，快。只是传输数据，不管服务器是否收到。 TCP拥塞控制防止过多数据注入到网络中，这样可以使网络中的路由器或链路不致过载。 慢开始 把初始拥塞窗口cwnd设置为1或2个发送方的最大报文段（SMSS），由小到大逐渐增大发送窗口。每经过一个传输轮次，cwnd加倍。 把拥塞窗口允许发送的报文段都连续发送出去，收到对已发送的最后一个字节的确认，为一个传输轮次，时间为一个往返时间。 拥塞避免 让拥塞窗口缓慢增大，没经过一个往返时间RTT就加1 快重传 让发送方尽早知道发生了个别报文段丢失 快恢复 发送方知道丢失报文段，则不启动慢开始，用快恢复，调整门限值cwnd/2. TCP建立连接——三次握手 客户端发送连接请求报文，将SYN位置设为1 服务器端收到报文后回复ACK+SYN报文。 客户端接收到报文后也向服务器端发送ACK报文，这个报文发送完毕后，完成了三次握手。 通过三次握手确认双方收发功能都正常，四次也可以但是显得比较多余。 TCP释放连接——四次挥手（断开连接） 客户端向服务器传送断开的请求包。客户端进入FIN_WAIT_1状态。 服务器端确定收到断开的请求，回复ACK报文。客户端进入FIN_WAIT_2状态。 服务器端向客户端FIN报文，请求关闭连接。服务器端进入LAST_ACK状态。 客户端收到FIN报文后，回复ACK报文。客户端进入TIME_WAIT状态。服务器端收到ACK报文就会关闭连接（不然一直处于LAST_ACK状态），客户端没有收到服务器端的回复，证明服务器端已关闭连接，客户端也可以关闭连接了。]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网：http和https]]></title>
    <url>%2F2020%2F05%2F14%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9Ahttp%E5%92%8Chttps%2F</url>
    <content type="text"><![CDATA[关于https用处： 建立一个信息安全通道，来保证数据传输的安全。 确认网站的真实性，防止钓鱼网站。 https就是在http下加入了ssl层，从而保护了交换数据隐私和完整性，提供了对网站服务器身份认证的功能，简单来说就是安全版的http。 http和https的区别 同属于应用层的协议 http协议是运行在tcp之上的，所有传输的内容都是未加密的，也就是明文的。https协议是运行在SSL\TLS之上的，而SSL\TLS协议运行在tcp之上，在http和tcp之间，所有传输的内容都经过加密的，比http更安全。（加密采用对称加密，而密钥的传输利用非对称加密） http默认使用端口80。https默认使用端口443。 https的工作原理 使用HTTPS的url访问服务器，客户端向服务器端请求建立SSL连接。（可以说TLS为SSL的新版本） 服务器收到客户端请求后，会将网站的证书信息（证书包含公钥）传送一份给客户端。 客户端浏览器和服务器端协商信息加密的等级。 客户端浏览器根据协商好的安全等级，建立会话密钥，然后利用网站的公钥加密会话密钥，并传送给服务器。 服务器利用私钥解密会话密钥，并利用会话密钥加密与客户端之间的通信。 非对称密码解密速度比较慢，但比较安全；对称密码解密速度比较快。所以用对称密码加密数据，非对称密码加密对称密钥。 非对称加密算法中私钥是基于不同的算法生成不同的随机数，私钥通过一定的加密算法推导出公钥，但私钥到公钥的推导过程是单向的，也就是说公钥无法反推导出私钥。]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：青蛙跳台阶和斐波那契数列]]></title>
    <url>%2F2020%2F03%2F17%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E5%92%8C%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[简单一次跳一层或两层，求跳上一个n级的台阶总共有多少种跳法。因为n级台阶，第一步有n种跳法：跳1级、跳2级跳1级，剩下n-1级，则剩下跳法是f(n-1)跳2级，剩下n-2级，则剩下跳法是f(n-2) f(0)=0f(1)=1f(2)=2f(n)=f(n-1)+f(n-2) 1234567891011function jump(n)&#123; if(n==0)&#123; return 0; &#125;else if(n==1)&#123; return 1; &#125;else if(n==2)&#123; return 2; &#125;else&#123; return jump(n-1)+jump(n-2); &#125;&#125; 复杂一次可以跳上1级台阶，也可以跳上2级……也可以跳上n级。求跳上一个n级的台阶总共有多少种跳法。因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级跳1级，剩下n-1级，则剩下跳法是f(n-1)跳2级，剩下n-2级，则剩下跳法是f(n-2)所以f(n)=f(n-1)+f(n-2)+…+f(1)因为f(n-1)=f(n-2)+f(n-3)+…+f(1)所以f(n)=2*f(n-1) 123456789function jumpII(number)&#123; if(number == 0)&#123; return 0; &#125;else if(number == 1)&#123; return 1; &#125; return 2*jumpII(number-1)&#125; 斐波那契数列斐波那契数列，又称黄金分割数列、因数学家列昂纳多·斐波那契以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、…… 性能优化之缓存 缓存: 存储数据的容器(cache) 在js中, 可以使用数组或者是对象进行存储数据,用键存储值,这样就可以实现既能存值也能取值 用缓存的基本思路 创建一个空对象，作为缓存的容器。 首先去缓存容器中查看缓存中是否有对应的数据，如果有，直接取出来使用。 如果没有，就先计算结果，然后把结果存储到缓存容器中，方便下次复用。123456789101112131415161718var cache = &#123; &#125;;var count = 0;function fib(n)&#123; count++; if(n === 1 || n === 2)&#123; return 1; &#125; if(cache[n])&#123; return cache[n]; &#125;else&#123; var ret = fib(n - 1) + fib(n - 2); cache[n] = ret; return ret; &#125;&#125;console.log(fib(10));console.log(&quot;fib函数调用的次数 &quot; + count); 总结 缓存: 存数据(该案例中,用键存月份,值存的对数) 在js中,缓存中如何表示, 对象 || 数组]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端SEO（搜索引擎优化）和语义化]]></title>
    <url>%2F2020%2F02%2F23%2F%E5%89%8D%E7%AB%AF%2F%E5%89%8D%E7%AB%AFSEO%EF%BC%88%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96%EF%BC%89%E5%92%8C%E8%AF%AD%E4%B9%89%E5%8C%96%2F</url>
    <content type="text"><![CDATA[合理的title、description、keywords title值强调重点，要靠前，不同页面title不要相同。 description对页面内容高度概括，长度合适，不同页面有所不同。 keywords列举重点关键词即可，不要过分堆砌关键词。 语义化语义化的标签，旨在让标签有自己的含义，就是用合理、正确的标签来展示内容，比如h1~h6定义标题。 优点 易于用户阅读，css样式丢失的时候能让页面呈现清晰的结构。 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。 方便其他设备解析，如盲人阅读器根据语义渲染网页 有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。 常见语义化标签12345678910111213141516171819202122&lt;title&gt;：页面主体内容。&lt;hn&gt;：h1~h6，分级标题，&lt;h1&gt; 与 &lt;title&gt; 协调有利于搜索引擎优化。&lt;ul&gt;：无序列表。&lt;li&gt;：有序列表。&lt;small&gt;：呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权。&lt;strong&gt;：和 em 标签一样，用于强调文本，但它强调的程度更强一些。&lt;em&gt;：将其中的文本表示为强调的内容，表现为斜体。&lt;mark&gt;：使用黄色突出显示部分文本。&lt;figure&gt;：规定独立的流内容（图像、图表、照片、代码等等）（默认有40px左右margin）。&lt;figcaption&gt;：定义 figure 元素的标题，应该被置于 figure 元素的第一个或最后一个子元素的位置。&lt;cite&gt;：表示所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。&lt;blockquoto&gt;：定义块引用，块引用拥有它们自己的空间。&lt;q&gt;：短的引述（跨浏览器问题，尽量避免使用）。&lt;time&gt;：datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。&lt;abbr&gt;：简称或缩写。&lt;dfn&gt;：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。&lt;address&gt;：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）。&lt;del&gt;：移除的内容。&lt;ins&gt;：添加的内容。&lt;code&gt;：标记代码。&lt;meter&gt;：定义已知范围或分数值内的标量测量。（Internet Explorer 不支持 meter 标签）&lt;progress&gt;：定义运行中的进度（进程）。 h5新增语义化标签1234567&lt;header&gt; 定义文档或者文档的部分区域的页眉&lt;nav&gt; 描述一个含有多个超链接的区域&lt;main&gt; 定义文档的主要内容，该内容在文档中应当是独一无二的&lt;article&gt; 表示文档、页面、应用或网站中的独立结构&lt;aside&gt; 表示一个和其余页面内容几乎无关的部分&lt;footer&gt; 定义最近一个章节内容或者根节点元素的页脚&lt;section&gt; 表示文档中的一个区域（或节），比如，内容中的一个专题组。 重要内容的html代码放最前搜索引擎抓取html的顺序是从上到下，保证重要内容一定会被抓取 重要内容不要用js输出爬虫不会执行js获取内容 提高网站速度网站速度也是搜索引擎排序的一个重要指标]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：二进制转十进制]]></title>
    <url>%2F2020%2F02%2F23%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6%2F</url>
    <content type="text"><![CDATA[解法一按权相加1234567function toDecimal(str)&#123; var res = 0; for(var i=str.length-1;i&gt;=0;i--)&#123; res = str[i]===&apos;1&apos; ? Math.pow(2,str.length-1-i) + res : res; &#125; return res;&#125; 123456789function toDecimal(str)&#123; var res = 0; var temp = 1; for(var i=str.length-1;i&gt;=0;i--)&#123; res = str[i]===&apos;1&apos; ? res + temp : res; temp *= 2; &#125; return res;&#125; 解法二parseInt 的第二个参数表示要解析的数字的基数123function toDecimal(str)&#123; return parseInt(str,2);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网：http报文结构]]></title>
    <url>%2F2020%2F02%2F23%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9Ahttp%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[http报文的产生HTTP通信过程包括客户端往服务器端发送请求以及服务器端给客户端返回响应两个过程。在这两个过程中就会产生请求报文和响应报文。 什么是HTTP报文呢？HTTP报文是用于HTTP协议交互的信息，HTTP报文本身是由多行数据构成的字符串文本。客户端的HTTP报文叫做请求报文，服务器端的HTTP报文叫做响应报文。 报文结构 HTTP报文由报文首部和报文主体构成，中间由一个空行分隔。 报文首部是客户端或服务器端需处理的请求或响应的内容及属性， 可以传递额外的重要信息。 报文首部包括请求行和请求头部。 报文主体主要包含应被发送的数据。 通常，不一定有报文主体。 http请求报文一个HTTP请求报文由请求行、请求头部、空行和请求数据4个部分构成。 请求行数据格式由三个部分组成：请求方法、URI、HTTP协议版本，他们之间用空格分隔。12// 该部分位于数据首行，基本格式为：GET /index.html HTTP/1.1 该部分的请求方法字段给出了请求类型，URI给出请求的资源位置(/index.html)。HTTP中的请求类型包括:GET、POST、HEAD、PUT、DELETE。一般常用的为GET和POST方式。最后HTTP协议版本给出HTTP的版本号。 http响应报文HTTP响应报文由状态行（HTTP版本、状态码（数字和原因短语））、响应头部、空行和响应体4个部分构成。 状态行主要给出响应HTTP协议的版本号、响应返回状态码、响应描述，同样是单行显示。格式为：1HTTP/1.1 200 OK 状态码告知从服务器端返回的请求的状态，一般由一个三位数组成,分别以整数1～5开头组成。 报文首部结构 由首部字段名和字段值构成的，中间用冒号“:”分割。 首部字段格式： 首部字段名:字段值。 类型 通用首部字段：请求报文和响应报文两方都会使用的首部。 请求首部字段：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。 响应首部字段：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。 实体首部字段：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等和实体有关的信息。]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行内元素、块元素、行内块元素]]></title>
    <url>%2F2020%2F02%2F22%2F%E5%89%8D%E7%AB%AF%2F%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E3%80%81%E5%9D%97%E5%85%83%E7%B4%A0%E3%80%81%E8%A1%8C%E5%86%85%E5%9D%97%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[行内元素 设置宽高无效。 margin水平方向有效，垂直方向无效。 padding水平方向有效，垂直方向在显示上有效果即会增大元素的内容范围，但对其他元素无影响。 不会自动进行换行。 123456789101112131415161718常见行内元素a - 锚点b - 粗体(不推荐)big - 大字体br - 换行em - 强调font - 字体设定(不推荐)i - 斜体img - 图片input - 输入框label - 表格标签select - 项目选择small - 小字体文本span - 常用内联容器，定义文本内区块strong - 粗体强调textarea - 多行文本输入框u - 下划线var - 定义变量 块元素 能够识别宽高。 margin和padding的上下左右均对其有效。 可以自动换行。 多个块状元素标签写在一起，默认排列方式为从上至下。 12345678910111213141516171819常见块元素address - 地址enter - 居中对齐块dir - 目录列表div - 常用块级容器，也是css layout的主要标签dl - 定义列表form - 交互表单h1 - 大标题h2 - 副标题h3 - 3级标题h4 - 4级标题h5 - 5级标题h6 - 6级标题hr - 水平分隔线menu - 菜单列表ol - 排序表单p - 段落table - 表格ul - 非排序列表（无序列表） 可变元素可变元素由上下文语境来决定是块元素还是内联元素 1234567button - 按钮del - 删除文本iframe - inline frameins - 插入的文本map - 图片区块（map）object - object对象script - 客户端脚本 行内块元素 不自动换行 能够识别宽高 默认排列方式为从左到右 三者转换使用display属性能够将三者任意转换： display:inline;转换为行内元素 display:block;转换为块状元素 display:inline-block;转换为行内块状元素]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSocket]]></title>
    <url>%2F2020%2F02%2F15%2F%E5%89%8D%E7%AB%AF%2FWebSocket%2F</url>
    <content type="text"><![CDATA[长连接和短连接长连接是存在于网络层的一种连接状态，而实现它则需要在传输层进行开发，因为它是基于对真实数据的收发，需要在底层进行管控。 http http1.0不支持长连接，http1.1支持长连接 http1.x是文本协议，http2.0是二进制协议 HTTP作为应用层协议，其实它的生命周期在服务器返回结果时就已经结束了，而所谓的支持长连接，其实是基于’Keep-Alive’请求头所约定，从而向下进行长连接发起的一种机制。该长连接依然是基于TCP的。 短连接所谓短连接，即连接只保持在数据传输过程，请求发起，连接建立，数据返回，连接关闭。它适用于一些实时数据请求，配合轮询来进行新旧数据的更替。 长连接长连接便是在连接发起后，在请求关闭连接前客户端与服务端都保持连接，实质是保持这个通信管道，之后便可以对其进行复用。它适用于涉及消息推送，请求频繁的场景（直播，流媒体）。连接建立后，在该连接下的所有请求都可以重用这个长连接管道，避免了频繁了连接请求，提升了效率。 轮询 所谓轮询，即是浏览器通过JavaScript启动一个定时器，然后以固定的间隔给服务器发请求，询问服务器有没有新消息这样一个机制。 然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。 只要有请求的的地方，都可以实现轮询，譬如各种事件驱动模型。它的长短是在于某次请求的返回周期。 短轮询短轮询指的是在循环周期内，不断发起请求，每一次请求都立即返回结果，根据新旧数据对比决定是否使用这个结果。 长轮询而长轮询即是在请求的过程中，若是服务器端数据并没有更新，那么则将这个连接挂起，直到服务器推送新的数据，再返回，然后再进入循环周期。 由上可以看到，长短轮询的理想实现都应当基于长连接，否则若是循环周期太短，那么服务器的荷载会相当重；当然，即便是在长连接下，访问人数过多，长短轮询都有可能造成服务器的瞬时访问量庞大，这就需要一些相应的优化实践了。 websocket WebSocket是HTML5新增的一种在单个 TCP 连接上进行全双工通讯的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。 在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 为什么http不能实现这是因为HTTP协议是一个请求－响应协议，请求必须先由浏览器发给服务器，服务器才能响应这个请求，再把数据发送给浏览器。换句话说，浏览器不主动请求，服务器是没法主动发数据给浏览器的。 用轮询是可以实现的，但这个机制的缺点一是实时性不够，二是频繁的请求会给服务器带来极大的压力。 websocket实现WebSocket并不是全新的协议，而是利用了HTTP协议来建立连接。 实际上HTTP协议是建立在TCP协议之上的，TCP协议本身就实现了全双工通信，但是HTTP协议的请求－应答机制限制了全双工通信。WebSocket连接建立以后，其实只是简单规定了一下：接下来，咱们通信就不使用HTTP协议了，直接互相发数据吧。 创建websocket连接首先，WebSocket连接必须由浏览器发起，因为请求协议是一个标准的HTTP请求，格式如下： 1234567GET ws://localhost:3000/ws/chat HTTP/1.1Host: localhostUpgrade: websocketConnection: UpgradeOrigin: http://localhost:3000Sec-WebSocket-Key: client-random-stringSec-WebSocket-Version: 13 该请求和普通的HTTP请求有几点不同： GET请求的地址不是类似/path/，而是以ws://开头的地址； 请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接； Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据； Sec-WebSocket-Version指定了WebSocket的协议版本。 一个WebSocket连接就建立成功，浏览器和服务器就可以随时主动发送消息给对方。消息有两种，一种是文本，一种是二进制数据。通常，我们可以发送JSON格式的文本。 浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。 安全的websocket安全的WebSocket连接机制和HTTPS类似。首先，浏览器用wss://xxx创建WebSocket连接时，会先通过HTTPS创建安全的连接，然后，该HTTPS连接升级为WebSocket连接，底层通信走的仍然是安全的SSL/TLS协议。 浏览器很显然，要支持WebSocket通信，浏览器得支持这个协议，这样才能发出ws://xxx的请求。目前，支持WebSocket的主流浏览器如下： Chrome Firefox IE &gt;= 10 Sarafi &gt;= 6 Android &gt;= 4.4 iOS &gt;= 8 服务器由于WebSocket是一个协议，服务器具体怎么实现，取决于所用编程语言和框架本身。Node.js本身支持的协议包括TCP协议和HTTP协议，要支持WebSocket协议，需要对Node.js提供的HTTPServer做额外的开发。已经有若干基于Node.js的稳定可靠的WebSocket实现，我们直接用npm安装使用即可。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回流（Reflow）和重绘（Repaint）]]></title>
    <url>%2F2020%2F02%2F15%2F%E5%89%8D%E7%AB%AF%2F%E5%9B%9E%E6%B5%81%EF%BC%88Reflow%EF%BC%89%E5%92%8C%E9%87%8D%E7%BB%98%EF%BC%88Repaint%EF%BC%89%2F</url>
    <content type="text"><![CDATA[浏览器渲染解析HTML，生成DOM树，解析CSS，生成CSSOM树。将DOM树和CSSOM树结合，生成渲染树（Render Tree）。 回流当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流。 每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。 重绘当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。 回流必定触发重绘，而重绘不一定触发回流。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面渲染过程（输入一个url）]]></title>
    <url>%2F2020%2F02%2F13%2F%E5%89%8D%E7%AB%AF%2F%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%EF%BC%88%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAurl%EF%BC%89%2F</url>
    <content type="text"><![CDATA[输入一个url到网页呈现 输入网址 发送到DNS服务器，并获取域名对应的web服务器对应的ip地址。 与web服务器建立TCP连接 浏览器向web服务器发送http请求 web服务器响应请求，并返回指定url数据 浏览器下载web服务器返回的数据。 解析 HTML 文件,构建 DOM 树,同时浏览器主进程负责下载 CSS 文件 CSS 文件下载完成,解析 CSS 文件生成cssom树，调用JS执行引擎执行JS代码，然后将DOM树和CSSOM树结合生成渲染树。 根据渲染树来布局，计算每个节点的布局信息，将各个节点绘制到屏幕上来渲染页面，直至显示完成。 若dom树生成过程中遇到script标签，则暂停，执行js直至完成再继续生成。 若执行js时需要操作cssom，还得等css加载执行完生成cssom才能继续执行。 因此，css资源要先于js资源加载，js放于页面底部，尽量少影响dom树的生成 各种拓展页面加载白屏原因： 在弱网络下，网络延迟，JS加载延迟，会阻塞页面。 客户端存在bug，缓存模块错乱，不缓存js等后来挂起的文件，以及乱缓存index.html。 如果页面完全一片空白。极有可能是后端出现问题，后端配置无错误输出，并且服务状态500，这个时候页面就是一片空白。如果是前端导致的，那么极有可能是单页应用异常，比如到了一个没有设置的新的页面。1、打开能看到源码和request、response的浏览器，如chrome，查看源码输出2、如果是后端问题，那么后端查看accesslog、程序日志，看看是否有问题3、如果是前端问题，那么根据给出的js异常之类的排查 统计白屏数量：监听某个主div的变化，在规定时间内该DIV没有变化，那就可以进行白屏统计了。 监控白屏时间：监听某个主div的变化，直至页面渲染。 优化：尽量减少文件夹的嵌套，文件名不要过长。 一个网站很卡找原因首先用3g网络测试一下：如果卡就是http请求数据可能过大。可以合并JS脚本和CSS文件，css精灵图，对HTTP传输进行gzip压缩。css放顶部，javascript放底部。 可能服务端出问题：比如用户访问量大，并发量大。mysql没有优化好，造成死锁。 可以用CDN加速把数据放在离用户更近的位置。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：多层数组转化为一层]]></title>
    <url>%2F2020%2F01%2F14%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%A4%9A%E5%B1%82%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%B8%80%E5%B1%82%2F</url>
    <content type="text"><![CDATA[题目给定一个数组，将多层数组转化为一层。 注意，数组元素不一定是数字，有可能为对象或字符串。 测试用例121. [&apos;1&apos;,[2,3],-1] // [&apos;1&apos;,2,3,-1]2. [&apos;1&apos;,[2,3],&#123;a:-1&#125;] // [&apos;1&apos;,2,3,&#123;a:-1&#125;] 解法思路 遍历数组，取出元素放入新数组，若元素为数组则递归取出 算法123456789101112131415/** * @param &#123;array&#125; arr * @param &#123;array&#125; res * @return &#123;array&#125; */var flatten = function (arr, res) &#123; for(let i in arr) &#123; if(arr[i] instanceof Array) &#123; test(arr[i],res) &#125; else &#123; res.push(arr[i]); &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode：验证回文串]]></title>
    <url>%2F2019%2F12%2F19%2F%E7%AE%97%E6%B3%95%2FLeetCode%EF%BC%9A%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 测试用例121. &quot;A man, a plan, a canal: Panama&quot; // true2. &quot;race a car&quot; // false 解法思路 先判空字符串 对非空字符串，先用正则把除字母和数字之外的字符去除，再全部转换为小写字母 把字符串分割为数组，翻转，再拼接为字符串，与原字符串进行对比 算法1234567891011121314/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isPalindrome = function(s) &#123; if(s === &apos;&apos;) &#123; return true; &#125; s = s.replace(/[^0-9a-zA-Z]/g, &apos;&apos;).toLowerCase(); if(s === s.split(&apos;&apos;).reverse().join(&apos;&apos;))&#123; return true; &#125; return false;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode：有效的括号]]></title>
    <url>%2F2019%2F12%2F06%2F%E7%AE%97%E6%B3%95%2FLeetCode%EF%BC%9A%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[题目给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 测试用例123451. &quot;()&quot; // true2. &quot;()[]&#123;&#125;&quot; // true3. &quot;(]&quot; // false4. &quot;([)]&quot; // false5. &quot;&#123;[]&#125;&quot; // true 解法一思路 使用字符串的replace方法进行匹配替换，直到全部匹配成功，字符串长度为0，返回true 或直到没有相匹配的项，匹配前的字符串与匹配后的字符串相等，则返回false 算法12345678910111213141516171819/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isValid = function(s) &#123; if(s.length === 0) &#123; return true; &#125; while(s.length !== 0) &#123; var temp = s; s = s.replace(&apos;()&apos;,&apos;&apos;); s = s.replace(&apos;[]&apos;,&apos;&apos;); s = s.replace(&apos;&#123;&#125;&apos;,&apos;&apos;); if(s === temp) &#123; return false; &#125; &#125; return true;&#125;; 解法二思路 构造哈希表，遍历字符串 对于左括号，把相应的右括号放进栈里 对于右括号，若与栈顶匹配，则把栈顶去除；若是不匹配，则往栈顶添加undefined，为了防止开头就是右括号的情况 算法1234567891011121314151617181920/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isValid = function(s) &#123; var map = &#123; &apos;(&apos;: &apos;)&apos;, &apos;[&apos;: &apos;]&apos;, &apos;&#123;&apos;: &apos;&#125;&apos; &#125; var stack = []; for(let i in s) &#123; if(s[i] !== stack[stack.length-1]) &#123; stack.push(map[s[i]]) &#125; else &#123; stack.pop(); &#125; &#125; return stack.length === 0 ? true : false;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode：罗马数字转整数]]></title>
    <url>%2F2019%2F12%2F06%2F%E7%AE%97%E6%B3%95%2FLeetCode%EF%BC%9A%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 测试用例123451. &quot;III&quot; // 32. &quot;IV&quot; // 43. &quot;IX&quot; // 94. &quot;LVIII&quot; // 58 解释: L = 50, V= 5, III = 35. &quot;MCMXCIV&quot; // 1994 解释:M = 1000, CM = 900, XC = 90, IV = 4 解法思路 根据题目中的所有情况写出哈希表 先匹配特殊情况，由于是匹配两个字符串，所以应考虑到最后一个字符串没有下一个的情况，所以先判断是否到最后了 若匹配，直接加，并使指针跳过这两个字符串 若不匹配，则直接得出该字符串的值，指针正常指向下一个 算法12345678910111213141516171819202122232425262728293031/** * @param &#123;string&#125; s * @return &#123;number&#125; */var romanToInt = function(s) &#123; var map = &#123; I: 1, IV: 4, V: 5, IX: 9, X: 10, XL: 40, L: 50, XC: 90, C: 100, CD: 400, D: 500, CM: 900, M: 1000 &#125; var res = 0; for(let i=0;i&lt;s.length;i++) &#123; if(i+1 &lt; s.length &amp;&amp; map[s.substr(i,2)]) &#123; res += map[s.substr(i,2)]; i++; &#125; else &#123; res += map[s.substr(i,1)]; &#125; &#125; return res;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网：cdn]]></title>
    <url>%2F2019%2F11%2F16%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9Acdn%2F</url>
    <content type="text"><![CDATA[是什么内容分发网络。使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。 cdn缓存用户浏览器和服务器端之间加入cdn 用户在浏览网站的时候，向服务器请求到资源后，cdn会在本地保存网站中的图片或者js、css等其他文件的副本，通过http响应头中的cache-control字段设置数据缓存时间，这样用户再次访问该网站的时候，浏览器就不用再下载全部的文件，减少了下载量意味着提高了页面加载的速度。 再次浏览网站时，客户端浏览器会先向CDN边缘节点发起请求，CDN边缘节点会检测用户请求数据的缓存是否过期，如果没有过期，则直接响应用户请求，此时一个http请求结束；如果数据已经过期，那么CDN还需要向源站发出回源请求,来拉取最新的数据。]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些调试小技巧]]></title>
    <url>%2F2019%2F07%2F29%2F%E5%89%8D%E7%AB%AF%2F%E4%B8%80%E4%BA%9B%E8%B0%83%E8%AF%95%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[一些常用的快捷键 快捷键 功能 ctrl + o 搜索文件 ctrl + shift + F 在所有文件中搜索特定的文字 ctrl + shift + o 在某个文件中搜索特定的文字 ctrl + G 跳转到某一行 ctrl + L 清除控制台的信息 ctrl + [ / ctrl + ] 标签切换 ctrl + shift + c 审查元素 shift + Enter / sources -&gt; snippets 在控制台编写多行代码 选中，H 显示/隐藏元素 一些常用的功能 通过js代码来设置断点：debugger，或者直接在sources中打断点，查看堆栈，了解函数调用情况 elements的event listeners中可以查看元素事件监听器 选中元素，右击Break on.. -&gt; Attributes Modifications，元素改变时启动断点 开发者工具打开的情况下右击chrome的刷新按钮，可清除缓存并硬重载]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器兼容问题]]></title>
    <url>%2F2019%2F04%2F25%2F%E5%89%8D%E7%AB%AF%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[css不同浏览器的标签默认的margin和padding不同 12345//解决*&#123; padding:0; margin:0;&#125; 对于一些新特性，低版本浏览器不兼容，可以用渐进增强或优雅降级。 js阻止冒泡12345678function canclebubble(event)&#123; var event = event||window.event; //兼容火狐 if(event.stopPropagation)&#123; event.stopPropagation(); //标准浏览器 &#125;else&#123; event.cancaleBubble==true; //老ie &#125; &#125; 取消默认事件12345678function stopevent(event)&#123; var event = event||window.event; //兼容火狐 if(event.preventDefault)&#123; event.preventDefault(); //标准浏览器 &#125;else&#123; event.returnValue==false; //老ie &#125; &#125; 注意 event代表事件的状态，例如触发event对象的元素、鼠标的位置及状态、按下的键等等； event对象只在事件发生的过程中才有效。 firefox里的event跟IE里的不同，IE里的是全局变量，随时可用；firefox里的要用参数引导才能用，是运行时的临时变量。 在IE/Opera中是window.event，在Firefox中是event；而事件的对象，在IE中是window.event.srcElement，在Firefox中是event.target，Opera中两者都可用。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渐进增强和优雅降级]]></title>
    <url>%2F2019%2F04%2F25%2F%E5%89%8D%E7%AB%AF%2F%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E5%92%8C%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[渐进增强针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。123456.transition&#123; -webkit-transition: all .5s; -moz-transition: all .5s; -o-transition: all .5s; transition: all .5s; &#125; 优雅降级一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。123456.transition&#123; transition: all .5s; -o-transition: all .5s; -moz-transition: all .5s; -webkit-transition: all .5s;&#125; 区别 渐进增强观点认为应该关注于内容本身。 优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：如何找出单链表中的倒数第k个元素]]></title>
    <url>%2F2019%2F04%2F25%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E6%89%BE%E5%87%BA%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[首先遍历一遍单链表，求出整个单链表的长度n，然后将倒数第k个，转换为正数第n-k个，接下来遍历一次就可以得到结果。 优化：设置两个指针p1和p2，p1在p2前，两者相差k-1个节点，当p1指向null时，p2刚好指向目标元素。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构：树的深度遍历和广度遍历]]></title>
    <url>%2F2019%2F04%2F22%2F%E5%85%B6%E4%BB%96%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[普通树深度遍历先访问根结点，然后遍历左子树接着是遍历右子树。利用堆栈的先进后出。 广度遍历从根开始访问,按照根节点左右顺序访问.每次把同层节点左右孩子访问完毕.再访问下一层，所以用队列的先进先出实现。 二叉树前序遍历根 左 右 中序遍历左 根 右 后序遍历左 右 根]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网：DNS查询过程]]></title>
    <url>%2F2019%2F04%2F22%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9ADNS%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[迭代+递归 在DNS解析器缓存中查找某主机的ip地址 向其本地域名服务器进行递归查找。 本地域名服务器查不到，就向根域名服务器进行迭代查询。 根域名服务器告诉本地域名服务器，下一步该向顶级域名服务器查找。 本地域名服务器向顶级域名服务器查找。 顶级域名服务器告诉本地域名服务器，下一步该向权限域名服务器查找。 权限域名服务器返回目标主机的ip地址。 本地域名服务器就把ip地址告诉目标主机。]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题（一）]]></title>
    <url>%2F2019%2F04%2F21%2F%E7%AE%97%E6%B3%95%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 123456789101112131415var reverse = function(x) &#123; var arr = x.toString().split(&apos;&apos;); if(arr[0]==&apos;-&apos;)&#123; var temp = arr.slice(1,arr.length); temp.reverse().unshift(&quot;-&quot;); x = parseInt(temp.join(&apos;&apos;)); &#125;else&#123; x = parseInt(arr.reverse().join(&apos;&apos;)); &#125; if(x&gt;=-Math.pow(2,31)&amp;&amp;x&lt;=Math.pow(2,31))&#123; return x; &#125;else&#123; return 0; &#125;&#125;; 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。 123456789101112131415161718192021var longestCommonPrefix = function(strs) &#123; var str=&quot;&quot;; if(strs.length == 1)&#123; str = strs[0]; &#125;else if(strs.length &gt;= 2)&#123; for(var i=1;i&lt;=Math.min(strs[0].length,strs[1].length);i++)&#123; if(strs[0].slice(0,i)==strs[1].slice(0,i))&#123; str = strs[0].slice(0,i); continue; &#125;else&#123; break; &#125; &#125; for(var j=2;j&lt;strs.length;j++)&#123; while(str!=&quot;&quot;&amp;&amp;strs[j].substr(0,str.length)!=str)&#123; str = str.slice(0,str.length-1); &#125; &#125; &#125; return str;&#125;; 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。即先开的后闭合。 123&quot;([)]&quot; //false&quot;&#123;[]&#125;&quot; //true&quot;&quot; //true 注意空字符串可被认为是有效字符串。 123456789101112131415161718var isValid = function(s) &#123; var temp = []; for(var i in s)&#123; if(s[i]==&quot;(&quot;)&#123; temp.push(&quot;)&quot;); &#125;else if(s[i]==&quot;[&quot;)&#123; temp.push(&quot;]&quot;); &#125;else if(s[i]==&quot;&#123;&quot;)&#123; temp.push(&quot;&#125;&quot;); &#125;else if(s[i]!=temp.pop())&#123; return false; &#125; &#125; return !temp.length; //只开不闭temp.length为true //空字符串temp.length为false //其余有效字符串temp会被移除空&#125;; 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 12345678var searchInsert = function(nums, target) &#123; for(var i=0;i&lt;nums.length;i++)&#123; if(nums[i]&gt;=target)&#123; return i &#125; &#125; return nums.length;&#125;; 给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指由字母组成，但不包含任何空格的字符串。 123456789101112var lengthOfLastWord = function(s) &#123; var len = s.length; var count = 0; while(len!=0&amp;&amp;s[len-1]==&quot; &quot;)&#123; len--; &#125; while(s[len-1]!=&quot; &quot;&amp;&amp;len&gt;0)&#123; count++; len--; &#125; return count;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2019%2F04%2F18%2F%E5%89%8D%E7%AB%AF%2Fcanvas%2F</url>
    <content type="text"><![CDATA[Canvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等。 属性 height width 一个Canvas定义了一个指定尺寸的矩形框1&lt;canvas id=&quot;test-canvas&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt; 检测浏览器支持由于浏览器对HTML5标准支持不一致，所以，通常在canvas内部添加一些说明性HTML代码，如果浏览器支持Canvas，它将忽略canvas内部的HTML，如果浏览器不支持Canvas，它将显示canvas内部的HTML 123&lt;canvas id=&quot;test-stock&quot; width=&quot;300&quot; height=&quot;200&quot;&gt; &lt;p&gt;Current Price: 25.51&lt;/p&gt;&lt;/canvas&gt; 在使用Canvas前，还需要用canvas.getContext来测试浏览器是否支持Canvas 123456var canvas = document.getElementById(&apos;test-canvas&apos;);if (canvas.getContext) &#123; console.log(&apos;你的浏览器支持Canvas!&apos;);&#125; else &#123; console.log(&apos;你的浏览器不支持Canvas!&apos;);&#125; 方法canvas绘图以左上角的（0， 0）为基准原点1234let canvas = document.querySelector(&apos;#canvas&apos;); // 得到canvas//得到canvas上下文环境let ctx = canvas.getContext(&apos;2d&apos;)//绘制2d图形let gl = canvas.getContext(&quot;webgl&quot;);//绘制3d图形 绘制矩形ctx.rect(x,y,width,height); 创建矩形。 但并不会真正将矩形画出，只能调用stroke() 或 fill()后才会真正作用于画布。 先填充再描边。 可通过canvas.width或canvas.height获取画布的宽度和高度 ctx.fillRect(x,y,width,height) 执行填充操作，绘制一个已填色的、以(x,y)位置为起点、大小为width x height的矩形。 有填充颜色，默认为black。 ctx.fillStyle=””为图形设置填充颜色 ctx.strokeRect(x,y,width,height); 绘制一个不填色、以(x,y)位置为起点、大小为width x height的矩形。 有边框颜色，默认为black。 ctx.strokeStyle=””为图形设置边框颜色 ctx.clearRect(x,y,width,height); 将(x,y)位置大小为width x height的矩形变为透明。 Internet Explorer 9、Firefox、Opera、Chrome 以及 Safari 支持 clearRect() 方法。 若canvas设置了背景颜色是不能被清除的，因为那是画布的背景颜色，clearRect清除的是绘制的图形，使绘制的图形变为透明，显现出画布背景色。 绘制复杂形状ctx.lineWidth=x;设置线宽为x，不需要加px ctx.fill();填充图形，可利用fillStyle设置填充颜色 ctx.stroke();绘制图形，可利用strokeStyle设置边框颜色 ctx.beginPath();清除原来的痕迹,绘制图形之前要先调用 ctx.closePath();自动完成闭合 ctx.moveTo(x,y);从(x,y)点开始绘图 ctx.lineTo(x,y);绘图终点为(x,y) ctx.arc(x, y, r, 起始弧度， 终点弧度，是否逆时针) 圆心为(x,y),半径为r 弧度 = Math.PI*角度 设置完弧线，要用moveTo()进行绘制 绘制文本ctx.font = “24px 宋体”设置字体大小、型号 ctx.fillText(“文字内容”,left,top); 绘制实心文字。 left为距画布最左边距离，top为距画布最上边距离。 可通过fillStyke设置文字填充颜色 ctx.strokeText(“文字内容”,left,top); 绘制空心文字。 left与top同上。 可通过strokeStyle设置文字边框颜色。 设置文字阴影这些要在设置文字内容之前设置 ctx.shadowOffsetX = x; x轴偏移量，默认位于元素正下方。 ctx.shadowOffsetY = y; y轴偏移量，默认位于元素正下方。 ctx.shadowBlur = num; 设置模糊系数。默认为0不模糊。 ctx.shadowColor = “”; 设置阴影颜色，同时要设置shadowBlur，否则看不见 用canvas画出一个(0,0)坐标绿色的100x100矩形框，再从(10,10)坐标将50x50的区域变成透明 123456789&lt;canvas id=&quot;test&quot; width=&quot;100px&quot; height=&quot;100px&quot;&gt;&lt;/canvas&gt;&lt;script&gt;var canvas = document.getElementById(&quot;test&quot;);var ctx = canvas.getContext(&quot;2d&quot;);ctx.fillStyle = &quot;green&quot;;ctx.fillRect(0,0,100,100);ctx.clearRect(10,10,50,50);&lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统：进程、线程、程序]]></title>
    <url>%2F2019%2F04%2F12%2F%E5%85%B6%E4%BB%96%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[程序只是一组指令的有序集合。 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是资源分配的最小单位。 线程是程序执行的最小单位。 一个程序至少一个进程，一个进程至少一个线程。 一个线程只能属于一个进程，但是一个进程可以拥有多个线程 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。 而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。 多线程处理就是允许一个进程中在同一时刻执行多个任务。 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网：http的header字段]]></title>
    <url>%2F2019%2F04%2F12%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9Ahttp%E7%9A%84header%E5%AD%97%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[http头 = 通用头 + 请求头 + 响应头 通用头(General)通用头域包含请求和响应消息都支持的头域，提供了与报文相关的最基本的信息。 header 含义 Request URL 请求的URL Request Method 请求的方法 Status Code HTTP 状态码 Remote Address 远程IP地址 Referrer Policy 记录了是从哪个链接跳来的 响应头(Response Headers) header 含义 示例 Accept-Ranges 表明服务器是否支持指定范围请求及哪种类型的分段请求 Accept-Ranges: bytes Age 从原始服务器到代理缓存形成的估算时间（以秒计，非负） Age: 12 Allow 对某网络资源的有效的请求行为，不允许则返回405 Allow: GET, HEAD Cache-Control 告诉所有的缓存机制是否可以缓存及哪种类型 Cache-Control: no-cache Content-Encoding web服务器支持的返回内容压缩编码类型。 Content-Encoding: gzip Content-Language 响应体的语言 Content-Language: en,zh Content-Length 响应体的长度 Content-Length: 348 Content-Location 请求资源可替代的备用的另一地址 Content-Location: /index.htm Content-MD5 返回资源的MD5校验值 Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ== Content-Range 在整个返回体中本部分的字节位置 Content-Range: bytes 21010-47021/47022 Content-Type 返回内容的MIME类型 Content-Type: text/html; charset=utf-8 Date 原始服务器消息发出的时间 Date: Tue, 15 Nov 2010 08:12:31 GMT ETag 请求变量的实体标签的当前值 ETag: “737060cd8c284d8af7ad3082f209582d” Expires 响应过期的日期和时间 Expires: Thu, 01 Dec 2010 16:00:00 GMT Last-Modified 请求资源的最后修改时间 Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT Location 用来重定向接收方到非请求URL的位置来完成请求或标识新的资源 Location: http://www.zcmhi.com/archives/94.html Pragma 包括实现特定的指令，它可应用到响应链上的任何接收方 Pragma: no-cache Proxy-Authenticate 它指出认证方案和可应用到代理的该URL上的参数 Proxy-Authenticate: Basic refresh 应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持） Refresh: 5; url=http://www.zcmhi.com/archives/94.html Retry-After 如果实体暂时不可取，通知客户端在指定时间之后再次尝试 Retry-After: 120 Server web服务器软件名称 Server: Apache/1.3.27 (Unix) (Red-Hat/Linux) Set-Cookie 设置Http Cookie Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 Trailer 指出头域在分块传输编码的尾部存在 Trailer: Max-Forwards Transfer-Encoding 文件传输编码 Transfer-Encoding:chunked Vary 告诉下游代理是使用缓存响应还是从原始服务器请求 Vary: * Via 告知代理客户端响应是通过哪里发送的 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 警告实体可能存在的问题 Warning: 199 Miscellaneous warning WWW-Authenticate 表明客户端请求实体应该使用的授权方案 WWW-Authenticate: Basic 请求头(Request Headers) header 含义 示例 Accept 指定客户端能够接收的内容类型 Accept: text/plain, text/html Accept-Charset 浏览器可以接受的字符编码集。 Accept-Charset: iso-8859-5 Accept-Encoding 指定浏览器可以支持的web服务器返回内容压缩编码类型。 Accept-Encoding: compress, gzip Accept-Language 浏览器可接受的语言 Accept-Language: en,zh Accept-Ranges 可以请求网页实体的一个或者多个子范围字段 Accept-Ranges: bytes Authorization HTTP授权的授权证书 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Cache-Control 指定请求和响应遵循的缓存机制 Cache-Control: no-cache Connection 表示是否需要持久连接。（HTTP 1.1默认进行持久连接） Connection: close Cookie HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。 Cookie: $Version=1; Skin=new; Content-Length 请求的内容长度 Content-Length: 348 Content-Type 请求的与实体对应的MIME信息 Content-Type: application/x-www-form-urlencoded Date 请求发送的日期和时间 Date: Tue, 15 Nov 2010 08:12:31 GMT Expect 请求的特定的服务器行为 Expect: 100-continue From 发出请求的用户的Email From: user@email.com Host 指定请求的服务器的域名和端口号 Host: www.zcmhi.com If-Match 只有请求内容与实体相匹配才有效 If-Match: “737060cd8c284d8af7ad3082f209582d” If-Modified-Since 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码 If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT If-None-Match 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 If-None-Match: “737060cd8c284d8af7ad3082f209582d” If-Range 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag If-Range: “737060cd8c284d8af7ad3082f209582d” If-Unmodified-Since 只在实体在指定时间之后未被修改才请求成功 If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT Max-Forwards 限制信息通过代理和网关传送的时间 Max-Forwards: 10 Pragma 用来包含实现特定的指令 Pragma: no-cache Proxy-Authorization 连接到代理的授权证书 Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Range 只请求实体的一部分，指定范围 Range: bytes=500-999 Referer 先前网页的地址，当前请求网页紧随其后,即来路 Referer: http://www.zcmhi.com/archives/71.html TE 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息 TE: trailers,deflate;q=0.5 Upgrade 向服务器指定某种传输协议以便服务器进行转换（如果支持） Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 User-Agent User-Agent的内容包含发出请求的用户信息 User-Agent: Mozilla/5.0 (Linux; X11) Via 通知中间网关或代理服务器地址，通信协议 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 关于消息实体的警告信息 Warn: 199 Miscellaneous warning]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网：计算机网络体系结构]]></title>
    <url>%2F2019%2F04%2F12%2F%E8%AE%A1%E7%BD%91%2F%E8%AE%A1%E7%BD%91%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[TCP/IP体系结构五层协议 应用层（http，ftp） 运输层（TCP，UDP） 网络层（IP） 数据链路层 物理层 四层协议 应用层（http，ftp） 运输层（TCP，UDP） 网际层IP 网络接口层 OSI模型 应用层（HTTP） 表示层 会话层（SSL\TLS） 运输层（TCP，UDP） 网络层（IP） 数据链路层 物理层]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：把十六进制的ip地址转换为十进制的]]></title>
    <url>%2F2019%2F04%2F10%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E6%8A%8A%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%9A%84ip%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E8%BF%9B%E5%88%B6%E7%9A%84%2F</url>
    <content type="text"><![CDATA[12345678910function change(ip)&#123; var temp = []; for(var i=0;i&lt;ip.length;i+=2)&#123; temp.push(ip.substr(i,2)) &#125; return temp.map(function(value)&#123; return parseInt(value,16); &#125;).join(&quot;.&quot;);&#125;console.log(change(&quot;C0A80000&quot;)); //&quot;192.168.0.0&quot; 拓展 12345在ip地址中，8位二进制取一个.且二进制的4位对应十六进制的1位因此8位二进制对应一个十进制整数2位十六进制对应一个十进制整数]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：快速排序]]></title>
    <url>%2F2019%2F04%2F09%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序分为交换排序、选择排序、插入排序、归并排序、基数排序快速排序和冒泡排序数据交换排序 首先，定义一个quickSort函数，它的参数是一个数组。 123function quickSort(arr)&#123; &#125; 然后，检查数组的元素个数，如果小于等于1，就返回。 12345function quickSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr; &#125;&#125; 接着，选择”基准”（pivot），并将其与原数组分离，再定义两个空数组，用来存放一左一右的两个子集。 123456789function quickSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr; &#125; var pivotIndex = Math.floor(arr.length/2); var pivot = arr.splice(pivotIndex,1)[0]; var left = []; var right = [];&#125; 然后，开始遍历数组，小于”基准”的元素放入左边的子集，大于等于基准的元素放入右边的子集。 12345678910111213141516function quickSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr; &#125; var pivotIndex = Math.floor(arr.length/2); var pivot = arr.splice(pivotIndex,1)[0]; var left = []; var right = []; for(var i in arr)&#123; if(arr[i] &lt; pivot)&#123; left.push(arr[i]); &#125;else&#123; right.push(arr[i]); &#125; &#125;&#125; 最后，使用递归不断重复这个过程，就可以得到排序后的数组。1234567891011121314151617function quickSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr; &#125; var pivotIndex = Math.floor(arr.length/2); var pivot = arr.splice(pivotIndex,1)[0]; var left = []; var right = []; for(var i in arr)&#123; if(arr[i] &lt; pivot)&#123; left.push(arr[i]); &#125;else&#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot],quickSort(right));&#125; 优化：选一个好的基准：随机选取三个数，排序取中 时间复杂度：nlogn]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型：json和xml]]></title>
    <url>%2F2019%2F03%2F29%2F%E5%85%B6%E4%BB%96%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9Ajson%E5%92%8Cxml%2F</url>
    <content type="text"><![CDATA[json json是一种轻量级的数据交换格式。 兼容性高。 格式简单，易读写。 易于解析。 xml xml是一种扩展标记语言。 可用来标记数据，定义数据类型。 格式统一。 文件庞大，格式复杂。 客户端和服务器端都需要大量代码来解析，导致代码复杂难以维护。]]></content>
      <categories>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM和DOM]]></title>
    <url>%2F2019%2F03%2F28%2F%E5%89%8D%E7%AB%AF%2FBOM%E5%92%8CDOM%2F</url>
    <content type="text"><![CDATA[BOM和DOM DOM（文档对象模型）是 HTML 和 XML 的应用程序接口。 DOM可以将任何HTML或XML文档描绘成一个由多层次节点构成的结构。 BOM （浏览器对象模型）主要处理浏览器窗口和框架。 javacsript是通过访问BOM对象来访问、控制、修改客户端浏览器。 由于BOM的window包含了document，document对象又是DOM的根节点。可以说，BOM包含了DOM。 浏览器提供出来给予访问的是BOM对象，从BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档。 拓展：遍历dom树]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：二分查找]]></title>
    <url>%2F2019%2F03%2F28%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[二分法查找，也称折半查找，是一种在有序数组中查找特定元素的搜索算法。 首先，从有序数组的中间的元素开始搜索， 如果该元素正好是目标元素（即要查找的元素），则搜索过程结束，否则进行下一步。 如果目标元素大于或者小于中间元素， 则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作。 如果某一步数组为空，则表示找不到目标元素。 12345678910111213141516171819function search(arr,key)&#123; var low = 0; var high = arr.length-1; while(low &lt;= high)&#123; var mid = parseInt((low+high)/2); if(key == arr[mid])&#123; return mid; &#125;else if(key &lt; arr[mid])&#123; high = mid-1; &#125;else if(key &gt; arr[mid])&#123; low = mid+1; &#125;else&#123; return -1; &#125; &#125;&#125;console.log(search([0,1,2,3,5,6,7],5));//4console.log(search([0,1,2,3,5,6,7],4));//undefined]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟dom]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%89%8D%E7%AB%AF%2F%E8%99%9A%E6%8B%9Fdom%2F</url>
    <content type="text"><![CDATA[是什么可以看作是一个使用javascript模拟了DOM结构的树形结构，这个树结构包含整个DOM结构的信息。 为什么之前使用原生js或者jquery写页面的时候会发现操作DOM是一件非常麻烦的一件事情，且在浏览器里一遍又一遍的渲染DOM是非常非常消耗性能的。在js做dom对比，减少对dom的操作，而不是每一次都要渲染，这样效率会提高。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种算法（三）]]></title>
    <url>%2F2019%2F03%2F19%2F%E7%AE%97%E6%B3%95%2F%E5%90%84%E7%A7%8D%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[有一个字符串有很多is，写一个方法只保留一个is？ 123456789function deleteIs(str)&#123; var index = str.search(&quot;is&quot;); var left = str.slice(0,index+2); var right = str.slice(index+2,str.length); right = right.split(&quot;is&quot;).join(&quot;&quot;); return left.concat(right); &#125;console.log(deleteIs(&quot;thisismybook&quot;));//thismybook 有3个-10-10之间的整数，写一个方法这三个数一共有多少可能相加等于10。 改写数组的push方法，保持原有逻辑，添加一个console.log(arguments)，即push什么打印什么。 12345Array.prototype.push = function(val)&#123; console.log(val);&#125;var temp = [1,2,5];temp.push(7);//打印7 传入一个无序数组，要求n数相加，获取特定的sum 12345678910111213141516 function getResult(arr,n,sum)&#123; if(n==0&amp;&amp;sum==0)&#123; return true; &#125; if(n&lt;0)&#123; return false; &#125; if(n&gt;0)&#123; for(var i in arr)&#123; var temp = arr.slice(i+1,arr.length); return getResult(temp,n-1,sum-arr[i]) || getResult(temp,n,sum); &#125; &#125;&#125;console.log(getResult([1,2,3,4],2,7)); //true 用正则表达式去掉两边的空格 123456function remove(str)&#123; var reg = /(^\s+)|(\s+?)/g; return str.replace(reg,&quot;&quot;);&#125;console.log(remove(&quot;this is book&quot;));//&quot;thisisbook&quot; 给定一个非空的数字数组，数组有且只有一个非重复项，实现一个方法获取落单项 12345678910111213function getSingleNumber(arr)&#123; var temp = []; for(var i in arr)&#123; if(temp.indexOf(arr[i]) == -1)&#123; temp.push(arr[i]); &#125;else&#123; temp.splice(temp.indexOf(arr[i]),1); &#125; &#125; return temp[0];&#125;console.log(getSingleNumber([0,1,0,0])); //1 请实现一个函数merge，传入一个数组，合并数组中【相邻且重复】的元素 123456789101112function merge(arr)&#123; var reg = /(.)\1*/g; var str = arr.join(&quot;&quot;); str = str.replace(reg,&quot;$1&quot;); arr = str.split(&quot;&quot;); arr = arr.map(function(val)&#123; return parseInt(val); &#125;) return arr;&#125;console.log(merge([3,2,2,4,5,5,6,2,1]));//[3,2,4,5,6,2,1]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种算法（二）]]></title>
    <url>%2F2019%2F03%2F19%2F%E7%AE%97%E6%B3%95%2F%E5%90%84%E7%A7%8D%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[求“123456789876543212345678987654321…”中的第n位123456789function index(n)&#123; if(n%16&lt;10)&#123; return n%16; &#125;else&#123; return 9-(n%16-9); &#125;&#125;console.log(index(26));//8 实现add(1);//1add(1)(2); //3add(1)(2)(3); //6 12345678910111213141516171819var add = function(a) &#123; var sum = a; var s = function(b) &#123; sum += b; //s，继续累加后面的执行参数。 return s; &#125;; //当要打印一个对象时，会自动调用 valueOf()或 toString方法 s.toString = function() &#123; return sum; &#125;; //获取第一个参数赋值给sum后，s。 return s;&#125;;add(1)(2)(3);//6//第一次调用add(),初始化了s，并将a保存在s的作用链中。//然后返回s保证了第二次调用的是s函数。//第二次之后的调用也是调用s，而在s中将传入的参数与保存在作用链中a相加并付给sum。 给定一个数组，返回所有的数字。如[1,’3’,false,null,100]=&gt;[1,3,100] 123456789101112131415function search(arr)&#123; var temp = []; for(var i in arr)&#123; if(typeof arr[i] == &quot;string&quot; || typeof arr[i] == &quot;number&quot;)&#123; temp.push(arr[i]); &#125; &#125; temp = temp.map(function(val)&#123; if（typeof parseInt（val） == &quot;number&quot;） return parseInt(val); &#125;) return temp;&#125;console.log(search([1,&apos;3&apos;,false,null,100])); //[1,3,100]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种算法（一）]]></title>
    <url>%2F2019%2F03%2F17%2F%E7%AE%97%E6%B3%95%2F%E5%90%84%E7%A7%8D%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[求1+2+3+…+n1234567function Sum_Solution(n) &#123; var result = n; if(n &gt; 0) result += Sum_Solution(n-1); return result;&#125;console.log(Sum_Solution(3)); //6 统计一个数字在无序数组中出现的次数123456789101112131415function count(arr,num)&#123; arr.sort(function(a,b)&#123; return a-b; &#125;); var result; var left = arr.indexOf(num); var right = arr.lastIndexOf(num,arr.length-1); if(arr.indexOf(num) == -1)&#123; result = 0; &#125;else&#123; result = right-left+1; &#125; return result;&#125;console.log(count([5,5,5,5,5,2,3],5)); //5 找出数组中任意一个重复的数字12345678910111213141516function duplicate(numbers, duplication)&#123; // write code here //这里要特别注意~找到任意重复的一个值并赋值到duplication[0] //函数返回True/False var temp = []; for(var i in numbers)&#123; if(temp.indexOf(numbers[i])==-1)&#123; temp.push(numbers[i]); &#125;else&#123; duplication[0] = numbers[i]; return true; &#125; &#125; return false;&#125;console.log(duplicate([5,5,5,5,5,2,3],[]));//true 快速排序 1234567891011121314151617function quickSort(arr)&#123; if(arr.length &lt;= 1)&#123; return arr; &#125; var pivotIndex = Math.floor(arr.length/2); var pivot = splice(pivotIndex,1)[0]; var left = []; var right = []; for(var i in arr)&#123; if(arr[i] &lt; pivot)&#123; left.push(arr[i]); &#125;else&#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot],quickSort(right));&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法：实现给数字添加千分位符的方法]]></title>
    <url>%2F2019%2F03%2F16%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%AE%9E%E7%8E%B0%E7%BB%99%E6%95%B0%E5%AD%97%E6%B7%BB%E5%8A%A0%E5%8D%83%E5%88%86%E4%BD%8D%E7%AC%A6%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[toLocaleString方法12const num = 12345678;num.toLocaleString(); toLacalString：返回这个数字在特定语言环境下的表示字符串。 在没有指定区域的基本使用时，返回使用默认的语言环境和默认选项格式化的字符串。 正则表达式1234567const num = 12345678;var reg=/\d&#123;1,3&#125;(?=(\d&#123;3&#125;)+$)/g;num.replace(reg,&quot;$&amp;,&quot;);1. 正则表达式 \d&#123;1,3&#125;(?=(\d&#123;3&#125;)+$) 表示前面有1~3个数字，后面的至少由一组3个数字结尾。2. ?=表示正向引用，可以作为匹配的条件，但匹配到的内容不获取，并且作为下一次查询的开始。3. $&amp; 表示与正则表达式相匹配的内容。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[h5和css3的新特性]]></title>
    <url>%2F2019%2F03%2F06%2F%E5%89%8D%E7%AB%AF%2Fh5%E5%92%8Ccss3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[HTML5绘画标签canvas用于媒介回放的video、audio本地离线存储localStorage长期存储数据，浏览器关闭后数据不丢失 sessionStorage数据在浏览器关闭后自动删除； 语义化更好的内容元素比如article、footer、header、nav、section； 表单控件calendar、data、time、email、url、search； webworker、websocket、Geolocation； 移除的元素： 纯表现的元素：basefont、big、center、font、s、strike、tt 对可用性产生负面影响的元素：frame、frameset、noframes CSS3RGBA和透明度word-wrap（对长的不可分割单词换行）1word-wrap: normal|break-word; 文字阴影12text-shadow：5px 5px 5px #FF0000;//水平阴影，垂直阴影，模糊距离，阴影颜色 @font-face规则定义自己的字体 圆角（边框半径）border-radius 属性用于创建圆角 边框图片border-image box-sizing盒阴影1box-shadow:10px 10px 5px #88888 媒体查询定义两套css，当浏览器的尺寸变化时会采用不同的属性]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地存储方式]]></title>
    <url>%2F2019%2F03%2F05%2F%E5%89%8D%E7%AB%AF%2F%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[cookie、localStorage、sessionStorage相同：在本地（浏览器端）存储数据。 不同 localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。 sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下。 localStorage是永久存储，除非手动删除。 sessionStorage当会话结束（当前页面关闭的时候，自动销毁） cookie的数据会在每一次发送http请求的时候，同时发送给服务器，而localStorage、sessionStorage不会。 每个cookie存放的内容大小有限制，一般为4kb。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C：冒泡法和选择法]]></title>
    <url>%2F2018%2F12%2F05%2F%E7%AE%97%E6%B3%95%2FC%EF%BC%9A%E5%86%92%E6%B3%A1%E6%B3%95%E5%92%8C%E9%80%89%E6%8B%A9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[冒泡法算法示例用起泡法对10个整数按升序排序。 算法分析如果有n个数，则要进行n-1趟比较。在第1趟比较中要进行n-1次相邻元素的两两比较，在第j趟比较中要进行n-j次两两比较。比较的顺序从前往后，经过一趟比较后，将最值沉底（换到最后一个元素位置），最大值沉底为升序，最小值沉底为降序。 算法源代码12345678910111213141516171819202122232425#include &lt;stdio.h&gt; int main() &#123; int a[10],i,j,t; printf(&quot;Please input 10 numbers: &quot;); /*输入源数据*/ for(i=0;i&lt;10;i++) scanf(&quot;%d&quot;,&amp;a[i]); /*排序*/ for(j=0;j&lt;9;j++) /*外循环控制排序趟数，n个数排n-1趟*/ for(i=0;i&lt;9-j;i++) /*内循环每趟比较的次数，第j趟比较n-j次*/ if(a[i]&gt;a[i+1]) /*相邻元素比较，逆序则交换*/ &#123; t=a[i]; a[i]=a[i+1]; a[i+1]=t; &#125; /*输出排序结果*/ printf(&quot;The sorted numbers: &quot;); for(i=0;i&lt;10;i++) printf(&quot;%d &quot;,a[i]); printf(&quot;\n&quot;); return 0; &#125; 选择法算法示例要求用选择法对10个整数按降序排序。 算法分析每趟选出一个最值和无序序列的第一个数交换，n个数共选n-1趟。第i趟假设i为最值下标，然后将最值和i+1至最后一个数比较，找出最值的下标，若最值下标不为初设值，则将最值元素和下标为i的元素交换。 算法源代码12345678910111213141516171819202122#include &lt;stdio.h&gt; int main() &#123; int a[10],i,j,k,t,n=10; printf(&quot;Please input 10 numbers:&quot;); for(i=0;i&lt;10;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(i=0;i&lt;n-1;i++) /*外循环控制趟数，n个数选n-1趟*/ &#123; k=i; /*假设当前趟的第一个数为最值,记在k中 */ for(j=i+1;j&lt;n;j++) /*从下一个数到最后一个数之间找最值*/ if(a[k]&lt;a[j]) /*若其后有比最值更大的*/ k=j; /*则将其下标记在k中*/ if(k!=i) /*若k不为最初的i值，说明在其后找到比其更大的数*/ &#123; t=a[k]; a[k]=a[i]; a[i]=t; &#125; /*则交换最值和当前序列的第一 个数*/ &#125; printf(&quot;The sorted numbers: &quot;); for(i=0;i&lt;10;i++) printf(&quot;%d &quot;,a[i]); printf(&quot;\n&quot;); &#125; 区别：（个人见解） 冒泡法要进行对n个数进行n-1趟，第j趟要进行n-j次比较，每次比较相邻的数不符合则要交换，每趟最多需要n-j次数的交换 选择法也要进行n-1趟，每趟是选出最值，而选最值是把下标交换，直到选出最值的下标，把最值和第一位交换，每趟最多仅需1次数的交换 简单地说，冒泡法每次都是数的交换（各个下标对应的数是变化的），而选择法是通过下标交换（这时候各个下标对应的数是不变的）选出最值的下标，最后再进行数的交换]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron进阶：打开新窗口]]></title>
    <url>%2F2018%2F11%2F14%2F%E5%85%B6%E4%BB%96%2FElectron%E8%BF%9B%E9%98%B6%EF%BC%9A%E6%89%93%E5%BC%80%E6%96%B0%E7%AA%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[标签实现新窗口打开 增加 target=”_blank”属性 router-link标签只有tag=”a”模式下 target=”_blank” 属性才会生效（vue2） 编程式导航123456let routeData = this.$router.resolve(&#123; name: &quot;searchGoods&quot;, query: params, params:&#123;catId:params.catId&#125; &#125;); window.open(routeData.href, &apos;_blank&apos;);]]></content>
      <categories>
        <category>Electron</category>
      </categories>
      <tags>
        <tag>Electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron：结合vue创建桌面应用]]></title>
    <url>%2F2018%2F11%2F14%2F%E5%85%B6%E4%BB%96%2FElectron%EF%BC%9A%E7%BB%93%E5%90%88vue%E5%88%9B%E5%BB%BA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[首先创建项目并安装好依赖12345vue init webpack test-electroncd test-electronnpm installnpm install electron --save-devnpm install electron-packager --save-dev 其次将零基础中的main.js拷贝到新建项目的build目录下，并更名为electron.js 按照实际项目路径更改electron.js中的路径 12345mainWindow.loadURL(url.format(&#123; pathname: path.join(__dirname, &apos;../dist/index.html&apos;), protocol: &apos;file:&apos;, slashes: true &#125;)) 最后在新建项目package.json文件中增加一条指令 1234567&quot;scripts&quot;: &#123; ... &quot;lint&quot;: &quot;eslint --ext .js,.vue src test/unit/specs test/e2e/specs&quot;, &quot;build&quot;: &quot;node build/build.js&quot;, //增加这条,JSON文件不支持注释，引用时请清除 &quot;electron_dev&quot;: &quot;npm run build &amp;&amp; electron build/electron.js&quot; &#125;, 启动12npm run build //生成dist目录npm run electron_dev //启动electron PS 打包前：更改config/index.js中生产模式下（build）的assetsPublicPth, 原本为 /, 改为 ./ 。]]></content>
      <categories>
        <category>Electron</category>
      </categories>
      <tags>
        <tag>Electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron：从零到完成一个桌面应用]]></title>
    <url>%2F2018%2F10%2F20%2F%E5%85%B6%E4%BB%96%2FElectron%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%88%B0%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Electron 开发环境 安装node 安装cnpm（或者npm） 安装electron 安装打包工具 1npm install -g electron-packager 经典例子electron-quick-start一个简约的记事本12345678//克隆这仓库 git clone https://github.com/electron/electron-quick-start//进入仓库 cd electron-quick-start//安装依赖库 cnpm install//运行应用，也可以用： cnpm run start cnpm start electron-api-demos介绍了主要的一些功能及实现代码 1234git clone https://github.com/electron/electron-api-demoscd electron-api-demoscnpm installcnpm start 开始开发安装electron推荐的安装方法是把electron作为您 app 中的开发依赖项，使您可以在不同的 app 中使用不同的 Electron 版本 在根目录下运行 1npm install --save-dev electron 当然，也可以在 $PATH 中全局安装1npm install electron -g 创建Electron简单文件结构在根目录下创建package.json文件，内容如下 1234567891011&#123; &quot;name&quot;: &quot;test&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;electron .&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;electron&quot;: &quot;^3.0.4&quot; &#125;&#125; 在根目录下创建main.js，内容如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const &#123; app, BrowserWindow &#125; = require(&apos;electron&apos;) // Keep a global reference of the window object, if you don&apos;t, the window will // be closed automatically when the JavaScript object is garbage collected. let win function createWindow () &#123; // 创建浏览器窗口。 win = new BrowserWindow(&#123; width: 800, height: 600 &#125;) // 然后加载应用的 index.html。 win.loadFile(&apos;index.html&apos;) // 打开开发者工具 win.webContents.openDevTools() // 当 window 被关闭，这个事件会被触发。 win.on(&apos;closed&apos;, () =&gt; &#123; // 取消引用 window 对象，如果你的应用支持多窗口的话， // 通常会把多个 window 对象存放在一个数组里面， // 与此同时，你应该删除相应的元素。 win = null &#125;) &#125; // Electron 会在初始化后并准备 // 创建浏览器窗口时，调用这个函数。 // 部分 API 在 ready 事件触发后才能使用。 app.on(&apos;ready&apos;, createWindow) // 当全部窗口关闭时退出。 app.on(&apos;window-all-closed&apos;, () =&gt; &#123; // 在 macOS 上，除非用户用 Cmd + Q 确定地退出， // 否则绝大部分应用及其菜单栏会保持激活。 if (process.platform !== &apos;darwin&apos;) &#123; app.quit() &#125; &#125;) app.on(&apos;activate&apos;, () =&gt; &#123; // 在macOS上，当单击dock图标并且没有其他窗口打开时， // 通常在应用程序中重新创建一个窗口。 if (win === null) &#123; createWindow() &#125; &#125;) // 在这个文件中，你可以续写应用剩下主进程代码。 // 也可以拆分成几个文件，然后用 require 导入。 然后创建index.html文件，内容如下 12345678910&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;TEST&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;span style=&quot;color:#fff;&quot;&gt;Hello World&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 启动app1npm start 或者在package.json中配置1&quot;scripts&quot;: &#123;&quot;start&quot;: &quot;electron .&quot;&#125; 则可以输入一下命令启动1electron . 打包全局安装electron-packager]]></content>
      <categories>
        <category>Electron</category>
      </categories>
      <tags>
        <tag>Electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github 搭建属于自己的博客（进阶）NexT主题]]></title>
    <url>%2F2018%2F05%2F04%2F%E5%85%B6%E4%BB%96%2FHexo%2BGithub%20%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89NexT%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[主题安装安装NexT在站点目录下（hexo），输入命令： 1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题在站点目录中（blog），打开配置文件_config.yml，修改1theme：next 验证主题1$ hexo s 主题设定以下所有设置注意格式 NexT主题设定可以在next主题目录下的_config.yml文件中修改 12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 基础设置在站点目录下的配置文件_cofig.yml中修改 12345678# Sitetitle: your blog titlesubtitle:description: describe yourselfkeywords:author: yournamelanguage: zh-Hans //简体中文timezone: 修改菜单项在主题目录下修改配置文件_cofig.yml中的menu 123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 这些配置都要与你主题目录下的languages文件中对应的yml文档里配置相关联 12345678910menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 限定主页文章高度修改主题目录下的值 123auto_excerpt: enable: true length: 150 设置头像修改主题目录下Sidebar Avatar的avatar值1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /images/avatar.jpg 地址可以是网络地址，也可以是本地地址（放置在source/images/ 目录下） 添加标签页面点击标签，跳转的页面会显示page not found 此时需要在站点目录的source文件夹里新建tags文件夹，并新建index.md，添加： 12345---title: tagsdate: type: &quot;tags&quot;--- 当要为某一篇文章添加标签，只需在blog/source/_post目录下的具体文章的tags中添加标签即可 实现点击出现桃心效果将代码copy到/themes/next/source/js/src里面新建的love.js中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950! function(e, t, a) &#123; function n() &#123; c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;), o(), r() &#125; function r() &#123; for (var e = 0; e &lt; d.length; e++) d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = &quot;left:&quot; + d[e].x + &quot;px;top:&quot; + d[e].y + &quot;px;opacity:&quot; + d[e].alpha + &quot;;transform:scale(&quot; + d[e].scale + &quot;,&quot; + d[e].scale + &quot;) rotate(45deg);background:&quot; + d[e].color + &quot;;z-index:99999&quot;); requestAnimationFrame(r) &#125; function o() &#123; var t = &quot;function&quot; == typeof e.onclick &amp;&amp; e.onclick; e.onclick = function(e) &#123; t &amp;&amp; t(), i(e) &#125; &#125; function i(e) &#123; var a = t.createElement(&quot;div&quot;); a.className = &quot;heart&quot;, d.push(&#123; el: a, x: e.clientX - 5, y: e.clientY - 5, scale: 1, alpha: 1, color: s() &#125;), t.body.appendChild(a) &#125; function c(e) &#123; var a = t.createElement(&quot;style&quot;); a.type = &quot;text/css&quot;; try &#123; a.appendChild(t.createTextNode(e)) &#125; catch (t) &#123; a.styleSheet.cssText = e &#125; t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a) &#125; function s() &#123; return &quot;rgb(&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;)&quot; &#125; var d = []; e.requestAnimationFrame = function() &#123; return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function(e) &#123; setTimeout(e, 1e3 / 60) &#125; &#125;(), n()&#125;(window, document); 打开\themes\next\layout_layout.swig文件,在末尾（在前面引用会出现找不到的bug） ，引用love.js 1&lt;script src=&quot;/js/src/love.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 添加动态背景打开\themes\next\layout_layout.swig文件，在 之前添加代码(注意不要放在&lt; /head&gt;的后面) 123&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 打开开\themes\next_config.yml,在里面修改为如下代码 1canvas_nest: true 在网站底部加上访问量打开\themes\next\layout_partials\footer.swig文件,在类copyright前加上这段代码： 1&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 然后在合适的位置添加显示统计的代码： 12345&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 在每篇文章末尾添加“本文结束”标记在路径 \themes\next\layout_macro 中新建 passage-end-tag.swig 文件,并添加以下内容 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout_macro\post.swig文件，在post-body 之后， post-footer 之前添加如下代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 打开主题配置文件,在末尾添加 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 侧边栏社交链接在主题配置文件中修改： 12345678910111213# Social linkssocial: GitHub: https://github.com/your-user-name Twitter: https://twitter.com/your-user-name 微博: http://weibo.com/your-user-name# Social Iconssocial_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter 微博: weibo 添加小图标在主题配置文件中修改： 123favicon: #small: /images/favicon.ico medium: /images/favicon.ico NexT主题美化 除了NexT还有很多其他好看的主题，百度会有很多方法的]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github 搭建属于自己的博客（基础）]]></title>
    <url>%2F2018%2F05%2F03%2F%E5%85%B6%E4%BB%96%2FHexo%2BGithub%20%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[搭建环境准备Node.js 的安装和准备12$ node -v$ npm -v git的安装和准备1$ git --version github账户的配置 github账户注册 创建新仓库 注意：仓库名称一定为 github用户名.github.io 仓库设置 接下来开启github pages功能 ，点击界面右侧的 Settings，你将会打开这个库的settings页面，向下拖动，直到看见GitHub Pages 安装hexo在任意一个地方创建文件夹hexo，进入到该目录输入： 1$ npm install hexo-cli -g 然后可能会看到一个WARN，并不会影响操作，继续输入： 1$ npm install hexo --save 1$ hexo -v hexo的相关配置 初始化hexo 12$ hexo init &lt;新文件夹&gt; $ cd &lt;新文件夹&gt; 首次体验hexo 123$ hexo g$ hexo s //若一直无法跳转，则是端口被占用$ hexo server -p 5000 //改变端口号 配置Git个人信息如果之前已经配置好git个人信息，请跳过这一个步骤 设置Git的user name和email 12$ git config --global user.name &quot;yourusername&quot;$ git config --global user.email &quot;youremail&quot; 生成密钥 1$ ssh-keygen -t rsa -C &quot;youremail&quot; 配置Deployment在_config.yml文件中，找到Deployment，然后按照如下修改： 1234deploy: type: git repo: https://github.com/yourname/yourname.github.io.git branch: master 写博客、发布新文章 新建一篇博客 1$ hexo new post &quot;article title&quot; 用MarDown编辑器打开就可以编辑文章了 生成、部署 123$ hexo g // 生成$ hexo s // 本地预览$ hexo d // 部署 1$ hexo d -g //在部署前先生成 踩坑提醒 注意需要提前安装一个扩展 1npm install hexo-deployer-git --save 如果没有执行这行命令，将会提醒 deloyer not found:git]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F03%2F%E5%85%B6%E4%BB%96%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>demo</category>
      </categories>
      <tags>
        <tag>demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习路线规划]]></title>
    <url>%2F2018%2F01%2F23%2F%E5%89%8D%E7%AB%AF%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[前端学习路线规划一、代码编写工具sublime Text 3: sublime text编辑器单从界面看非常简洁，可以说让人一见倾心的感觉。完全符合码农的口味~~。功能上也不复杂，就跟记事本似的，很容易上手。 可以自由扩展，sublime提供了安装插件的方式，可以任意安装你想要的插件. 二、学习路线规划1. 熟练使用 HTML、CSSHTML 是标签语言，可以构建前端页面的骨架；CSS是层叠样式控制表，可以构建前端页面的外貌 这部分比较简单，到网上搜资料，书籍视频非常多。css中盒子模型，流动，block，inline，层叠，样式优先级等这些比较重要。最后再深入了解下浏览器差异性，ie9以下兼容简单了解就行了，ie9以下浏览器被淘汰掉是趋势，低版本没必要浪费大量时间去学习兼容主流浏览器，google chrome浏览器、firefox浏览器、safari浏览器、opera浏览器即可。浏览器差异内容很多，建议在实践中多多积累。 12推荐书籍：《Head First HTML 与 CSS (第2版)》 《CSS 禅意花园(修订版)》 2.javascript部分（最重要的部分）难点，也是重点，要学的内容实在很多，如果没有其他编程语言的基础的话，学起来可能要费些力，有很多比较抽象的概念，必须要深入理解，比如闭包、原型、面向对象、封装等，要理解透彻。看书是必不可少的，找一本优秀的js书从头到尾深入学习了。另外，js面向对象编程必须要学习，非常重要，个人推荐一本书《javascript高级程序设计》。边学边练，实践出真知。 1234推荐教程：网易云课堂上 李炎恢老师的视频，讲得很详细，讲的是和那本红宝书一样的内容 多动手写demo推荐书籍：《Javascript 权威指南》 《JavaScript 高级程序设计(第3版)》 3.jQuery学习（这不是一个框架，是一个类库）这些基础知识掌握好之后，还需要学jQuery，这是一个非常优秀的Javascript库，大型开发必备。它简化了Javascript的复杂操作，消除了Javascript跨平台兼容问题，提供了大量实用方法，有良好的文档和帮助手册，是一个非常成熟的Javascript库。 12推荐教程：网易云课堂上 李炎恢老师的视频，多动手写demo推荐书籍：《锋利的jquery》 4.ajax的学习通过在后台与服务器进行数据交换，AJAX可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新，ajax是现在前端后台交互的主要方式。 12掌握的知识点：js原生的发送ajax的方法 jq的简便的发送ajax的方法 5.gitGit是目前世界上最先进的分布式版本控制系统，适合于在团队合作时进行版本控制，提高开发效率 1推荐教程：廖雪峰老师的关于git的教程博客 6.理解前端语言新标准 HTML5、CSS3、ES6 及其特性熟练使用 HTML、CSS、JavaScript 还需要我们理解其语言最新相关标准：HTML5、CSS3 和 ES6(ECMAScript6)。 HTML 5 里新增了许多特性：语义化和新的音频、视频支持等； CSS 3 被划分为模块，解决了 CSS2 为等待各个标准统一而耗费大量时间才能推进的不足之处，同时也提供了 2D、3D、动画效果等新特性； ECMAScript6 等于 JavaScript - DOM - BOM，是 JavaScript 在 2015 年的最新标准，因为 ES6 对标准改动较大，前端开发者常常将一个前端项目是否支持 ES6 作为推进前端新技术的重要桥梁之一。ES6 将箭头函数、let 变量声明命令、Promise 编程、模块化编程等新特性纳入其标准中，得到了各大浏览器最新版本的支持。 12扩展阅读：《ES6 标准入门(第2版)》 《深入理解ES6》 7.掌握浏览器兼容、响应式布局相关解决方案早期占据浏览器半壁江山的IE浏览器上存在的众多浏览器兼容问题，耗费了当时前端开发者的大量开发时间。虽然说现在的前端开发者已经不需要考虑太多的浏览器兼容问题，对其概念的了解有利于了解前端历史包袱或在未来足以应对一些面向特殊群体(早期 IE 浏览器使用者)的前端项目。关于IE浏览器的兼容性问题在李炎恢老师的那个视频有详细的讲解 响应式布局和单页面应用是当代前端开发者的必备技能。从 Web Pages 到 Web App 时代，我们开发的前端项目有越来越多的可能需要同时在电脑端和手机端进行访问，一个有良好响应式布局的前端项目可以一个代码运行在多种不同分辨率的平台之上。 三、现在前端主流的框架1. vuejs :2016年最火的前端框架（MVVC框架）是一套用于构建用户界面的渐进式框架Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 常用于单页面应用的开发 12345678掌握的要点：(vue全家桶) 1.vue-router 2.vuex 3.vue-resource 4.vue-cli 5.Element-ui 推荐教程：详细阅读官网教程，中国人自己研发的，有中文版，不难 2. ReactjsReact 是一个用于构建用户界面的 javascript 库。 React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。 React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。 React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。 React特点： 1234561.声明式设计 −React采用声明范式，可以轻松描述应用。2.高效 −React通过对DOM的模拟，最大限度地减少与DOM的交互。3.灵活 −React可以与已知的库或框架很好地配合。4.JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。5.组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。6.单向响应的数据流 − React实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。 123456掌握的知识点：（React全家桶技术） 1.Reactjs 2.React生命周期 3.React Router 4.Redux 5.React Native(主要用于移动端的开发) 3.AngularJS（国外开发大型项目常用框架）AngularJS的四大功能： MVC 将后台的MVC模式写入了前端语言中。我总觉得前端语言将来会很叼，从node.js开始我就又一种这样的感觉。可能在很久之后取代后端语言不是没有可能的。 模块化 就是一系列函数的集合，当应用被启动时，这些函数就会被执行。主要利用angular.module来定义模块。也是Angular.js的亮点。 指令属性 我自己的理解就是比html标签更加具有属性和方法的指令标签 双向数据绑定 传统的数据绑定是单向绑定，数据只能从model和controller生成需要的html，但是不能返过来使用。只是单方向的。双向数据绑定:也就是说我在前面填写，后面直接生成代码，将填写的显示出来。双向的意思就是如果view修改了属性值，那么model机会看到这个改变。相反也是一样的。 4. 小程序（类似一个前端开发框架）1推荐教程：官网上的小程序开发文档，尝试动手写一下小程序 5.nodejs(前端用来写后台的工具)简单的说 Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。 Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。1推荐教程：官网的教程 四、一些常用的ui框架1. Bootstrape：最好的响应式css框架2. Element-ui：完美适应vuejs的ui框架3. Amazeui：Amaze UI 是一个轻量级、 Mobile first 的前端框架, 基于开源社区流行前端框架编写的。4. Aliceui5.Echart：最好的图表制作框架·····六、前端最好掌握的一些常用技能 Markdown笔记的使用，程序员专用笔记本 github的使用：全球最大的开源代码网站，在上面你可以找到全世界所有出名项目的源代码，被称为人类的知识宝库。 用github page搭建个人博客，上传个人项目到github上，面试加分必备项 移动端的开发 前端web开发命名规范，谷歌、百度命名标准 等等·······]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
